<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo</title>
    <url>/post/b132932/</url>
    <content><![CDATA[<p> Hexo博客是一个基于Nodejs开发的一套博客系统。借助Hexo，开发者可以把自己的Hexo配置和Markdown文章，编译为HTML、JavaScript、CSS的存静态资源。 </p>
<p>本篇主要为为使用 Hexo 博客的一些心得</p>
<h1 id="教程链接"><a href="#教程链接" class="headerlink" title="教程链接"></a>教程链接</h1><ul>
<li><strong>搭建教程：</strong> <a href="https://zhuanlan.zhihu.com/p/606083588">hexo&amp;github 搭建博客（保姆级） - 知乎 (zhihu.com)</a> </li>
<li><strong>博客配置：</strong> <a href="https://zhuanlan.zhihu.com/p/618864711">Hexo+Next主题搭建个人博客+优化全过程（完整详细版） - 知乎 (zhihu.com)</a> </li>
<li><strong>NexT主题配置：</strong> <ul>
<li><a href="https://www.jianshu.com/p/3a05351a37dc">Hexo的Next主题详细配置 - 简书 (jianshu.com)</a> </li>
<li><a href="https://www.jianshu.com/p/cb58558ba222">Hexo+NexT（四）：Hexo站点及Next主题配置详解 - 简书 (jianshu.com)</a></li>
</ul>
</li>
<li><strong>官方文档：</strong> <a href="https://hexo.io/zh-cn/docs/asset-folders.html">资源文件夹 | Hexo</a></li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先需要下载NodeJS（如果是部署到github.io主页的话还要下载Git）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化一个博客项目（是在当前目录生成，所以你要确保当前目录是你想防止博客项目的目录）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注：my-blog 需要替换成你的博客名</span></span><br><span class="line">hexo init my-blog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入项目文件夹</span></span><br><span class="line">cd my-blog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入项目下载npm依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地部署hexo博客</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>然后你就可以访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 看到你的博客了 🤩🤩</p>
<h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>你需要在github或其他地方找到喜欢的博客主题，把主题的所有文件下载下来并解压到上面创建的项目中的themes文件夹（即 **my-blog&#x2F;themes&#x2F;**）并复制主题文件夹名</p>
<p>然后，在<strong>my-blog&#x2F;_config.yml</strong>（项目根配置文件）中，按<kbd>Ctrl</kbd>+<kbd>F</kbd>搜索 theme</p>
<p>将 theme: xxxx 改为 theme: [上面复制的文件夹名]</p>
<h2 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h2><p>如果你是想部署在github.io上的话，我默认你已经安装了git并且创建github账号了（如果不是的话可以上网搜一下教程）</p>
<p>首先在github上创建一个<strong>公共仓库</strong>，取名为 [github用户名].github.io，然后复制该仓库的仓库链接</p>
<p>在博客项目的项目根配置文件中滑到最底部，可以看到deploy字段</p>
<p>把deploy字段改为如图形式</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">仓库链接</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">仓库分支名</span></span><br></pre></td></tr></table></figure>

<p>最后，在命令行中输入 <code>hexo g -d</code> 就可以把博客项目推到仓库了 🤗🤗</p>
<h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><h2 id="新建笔记"><a href="#新建笔记" class="headerlink" title="新建笔记"></a>新建笔记</h2><p>其实不需要在命令行里每次都 hexo new xxx。直接在 [项目路径]\source\_posts 下创md文件，然后在开头加上：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">title: xxxx</span></span><br><span class="line"><span class="code">date: yyyy-MM-dd hh:mm:ss*日期格式*</span></span><br><span class="line"><span class="code">tags: </span></span><br><span class="line"><span class="code">*多个标签要用下面这种方式或者 [tag1,tag2] 的方式分隔 要不然就会把所有标签识别成一个标签*</span></span><br><span class="line"><span class="code">- tag1</span></span><br><span class="line"><span class="code">- tag2</span></span><br><span class="line"><span class="code">...</span></span><br><span class="line"><span class="code">categories: xxx *分类不知道能不能写多个，反正我写就写了一个*</span></span><br><span class="line"><span class="code">mathjax: true *如果文章里有数学公式 要把这个填为true*</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>

<p>其实就和 new 一个文章一样的</p>
<h2 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h2><h3 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h3><p>在b站一个视频看到的主题，黑白配色，感觉还不错 <span class="github-emoji" alias="yum" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8">&#x1f60b;</span></p>
<p>在主题文件夹中的**_config.yml<strong>配置文件（不是项目根配置文件）中编辑 <strong>scheme</strong> 字段可以改变NexT博客的排版主题（我现在用的排版主题是</strong>Gemini**，在左侧会有侧边栏）</p>
<p>关于NexT主题其他的一些配置可以看<a href="#%E6%95%99%E7%A8%8B%E9%93%BE%E6%8E%A5">这里链接</a>的教程</p>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>可以根据标题和内容搜索文章，但是初次使用要加载一段时间（索引文章的标题和内容之类的）</p>
<p>安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>

<p>然后在项目根配置文件里加上：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10</span> <span class="comment"># 好像是分页限制的文章数？</span></span><br></pre></td></tr></table></figure>

<h2 id="文章缩略显示"><a href="#文章缩略显示" class="headerlink" title="文章缩略显示"></a>文章缩略显示</h2><p>网上有好几种实现方法，我这里列举两种：</p>
<ol>
<li><p>在md文件里要缩略的地方加上</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 hexo-excerpt 自动在指定位置缩略显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-excerpt --save</span><br></pre></td></tr></table></figure>

<p>然后在项目根配置文件里加上：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">excerpt:</span></span><br><span class="line">  <span class="attr">depth:</span> <span class="number">2</span> <span class="comment"># 大致是显示的行数，如果文章开头就是代码块会显示完整代码块</span></span><br><span class="line">  <span class="attr">excerpt_excludes:</span> [] </span><br><span class="line">  <span class="attr">more_excludes:</span> []</span><br><span class="line">  <span class="attr">hideWholePostExcerpts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="背景蜘蛛网特效"><a href="#背景蜘蛛网特效" class="headerlink" title="背景蜘蛛网特效"></a>背景蜘蛛网特效</h2><blockquote>
<p>注意：我用的是NexT主题，其他主题可能需要另搜</p>
</blockquote>
<p>在 [项目路径]\themes\hexo-theme-next\layout\_layout.njk 里加上如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.<span class="property">canvas_nest</span> %&#125;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>然后在主题配置文件里加上：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="Markdown渲染引擎"><a href="#Markdown渲染引擎" class="headerlink" title="Markdown渲染引擎"></a>Markdown渲染引擎</h2><p>我看网上好多都说Hexo自带的 hexo-renderer-marked 引擎性能不太行，而且不支持一些像emoji、LaTeX公式之类的Markdown语法。<del>所以我就换成了 hexo-renderer-markdown-it</del>  NexT主题如果把引擎换成markdown-it或者markdown-it-plus会导致文章一级目录跳转不了，只能含泪换回原来的marked <span class="github-emoji" alias="sob" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">&#x1f62d;</span><span class="github-emoji" alias="sob" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">&#x1f62d;</span><br>emoji的问题可以看 <a href="#%E6%98%BE%E7%A4%BAEmoji">Emoji</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">换之前要把原来的引擎卸载</span></span><br><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装新引擎</span></span><br><span class="line">npm install hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure>

<p>安装完好像是不用配置什么就能用，但是不加插件还是显示不了emoji的 <span class="github-emoji" alias="angry" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f620.png?v8">&#x1f620;</span> ，在项目根配置文件里加上：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span></span><br></pre></td></tr></table></figure>

<p>用不用另外安装依赖我也忘了 <span class="github-emoji" alias="joy" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">&#x1f602;</span> ，如果没效果的话就上网搜一搜吧</p>
<h2 id="显示Emoji"><a href="#显示Emoji" class="headerlink" title="显示Emoji"></a>显示Emoji</h2><p>安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-emoji --save</span><br></pre></td></tr></table></figure>

<p>在项目根配置文件中添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">emoji:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">className:</span> <span class="string">github-emoji</span></span><br><span class="line">  <span class="attr">styles:</span></span><br><span class="line">  <span class="attr">customEmojis:</span></span><br></pre></td></tr></table></figure>

<h2 id="更改字体"><a href="#更改字体" class="headerlink" title="更改字体"></a>更改字体</h2><p>谷歌字体一直进不去，啊米诺斯</p>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><h3 id="Mathjax"><a href="#Mathjax" class="headerlink" title="Mathjax"></a>Mathjax</h3><p>我用是Mathjax。但是Mathjax有个问题是显示不了 $\infin$ （如果你看到了的话说明能显示了），在主题配置文件里找到：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># 是否每页都使用mathjax渲染 填false的话就要在需要渲染的文章开头加上mathjax: true</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span> </span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 这个改成true</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">all</span> <span class="comment"># 这个好像是显示公式的序号什么的</span></span><br></pre></td></tr></table></figure>

<p>呃呃，也是忘了要不要安装依赖 <span class="github-emoji" alias="joy" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">&#x1f602;</span><span class="github-emoji" alias="joy" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">&#x1f602;</span></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>在主题配置文件找到 **codeblock ** 字段</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">base16/one-light</span>	<span class="comment"># 这个主题夜间模式也能看清</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">stackoverflow-dark</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>	<span class="comment"># 启用复制按钮</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">flat</span>		<span class="comment"># 复制按钮的样式 mac主题整个代码块样式都会改</span></span><br><span class="line">  <span class="comment"># Fold code block</span></span><br><span class="line">  <span class="attr">fold:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>	<span class="comment"># 启用代码折叠</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">400</span>		<span class="comment"># 代码折叠的高度 单位应该是px</span></span><br></pre></td></tr></table></figure>

<h2 id="标签云"><a href="#标签云" class="headerlink" title="标签云"></a>标签云</h2><p>在项目根配置文件搜 <strong>tag_cloud</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tag_cloud:</span></span><br><span class="line">  <span class="attr">textColor:</span> <span class="string">&#x27;#fc6423&#x27;</span>	<span class="comment"># 词云的文字颜色 </span></span><br><span class="line">  <span class="attr">outlineColor:</span> <span class="string">&#x27;#fff&#x27;</span>	<span class="comment"># 鼠标停留在文字时的背景颜色</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/post/f89cb603/</url>
    <content><![CDATA[<h1 id="概念及用处"><a href="#概念及用处" class="headerlink" title="概念及用处"></a>概念及用处</h1><blockquote>
<p>前置知识：二叉搜索树</p>
</blockquote>
<p>一种用于高效搜索的平衡二叉搜索树</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>节点只能是<font color="red"><strong>红色</strong></font>或<strong>黑色</strong></li>
<li>根节点是<strong>黑色</strong></li>
<li>叶子节点的左右空节点都是<strong>黑色</strong>（每个叶子节点都必须有两个黑色空节点）</li>
<li><font color="red"><strong>红色</strong></font>节点的子节点都是<strong>黑色</strong></li>
<li>从根节点到叶子结点的简单路径都包含相同的<strong>黑色</strong>节点</li>
</ol>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="左右旋转"><a href="#左右旋转" class="headerlink" title="左右旋转"></a>左右旋转</h2><p>定义旋转的根节点为 $r$，冲突节点是 $r$ 在旋转时替换掉的节点（如果存在）</p>
<p>左旋转：将 $r$ 设为 $r$ 的<strong>右子节点</strong>的<strong>左子节点</strong>，若冲突则将<strong>冲突节点</strong>设为 $r$ 的<strong>右子节点</strong></p>
<p>右旋转：将 $r$ 设为 $r$ 的<strong>左子节点</strong>的<strong>右子节点</strong>，若冲突则将<strong>冲突节点</strong>设为 $r$ 的<strong>左子节点</strong></p>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>插入节点后要保证红黑树的性质不变，所以我们将待插入节点标为<font color="red"><strong>红色</strong></font>（红色不会影响<strong>性质1、5</strong>）</p>
<p>但是如果待插入节点的父节点为<font color="red"><strong>红色</strong></font>的话，就不满足<strong>性质4</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP字符串匹配</title>
    <url>/post/9f09feea/</url>
    <content><![CDATA[<h1 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h1><p>顾名思义，就是用来寻找一个源字符串中有没有与目标字符串匹配的一种算法</p>
<p>但它与普通匹配算法最大的不同点就在于它非常快，时间复杂度只有 $O(n)$</p>
<p>后文将源字符串简称为<strong>源串</strong>，目标字符串简称为<strong>目标串</strong></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><blockquote>
<p>前置知识：暴力匹配字符串</p>
</blockquote>
<p>依旧是与传统暴力匹配同样的模式（两个指针遍历字符串）来进行匹配。但与之不同的是，在遇到不匹配的情况时暴力匹配会<strong>直接回溯到最开始与目标串第二个字符对应的下标位置</strong></p>
<p>而KMP算法则是<strong>在匹配前先遍历源串生成一个 next 数组存储不匹配时目标串指针下一步跳转的位置</strong>，使得目标串指针能跳过<strong>尽可能多的 无意义的</strong>字符。大幅提升了匹配的效率</p>
<p>这里的无意义指的是即使匹配了也没有办法让目标串指针向右移动（匹配比原来更多的目标串字符）</p>
<h2 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a>next 数组</h2><p>由上可知，KMP 最重要的部分就是 next 数组，所以 <strong>理解和生成 next 数组</strong> 也就成了最关键的部分</p>
<p>在此之前，我们需要引入一些概念来方便我们理解生成的过程</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="前后缀"><a href="#前后缀" class="headerlink" title="前后缀"></a>前后缀</h4><p>很好理解，就是从字符串最前面或最后面，<strong>向反方向截取 $n(n&lt;字符串长度)$ 个字符</strong> 获得到的子字符串</p>
<p>例：abc</p>
<ul>
<li><p>前：a，ab</p>
</li>
<li><p>后：c，bc</p>
</li>
</ul>
<h4 id="最长相等前后缀"><a href="#最长相等前后缀" class="headerlink" title="最长相等前后缀"></a>最长相等前后缀</h4><p>也很好理解，就是一个字符串的 <strong>最长的 相同的</strong> 前后缀</p>
<p>例：abcba</p>
<ul>
<li>前：a，ab，<strong>abc</strong>，abcb</li>
<li>后：a，ab，<strong>abc</strong>，abcb</li>
</ul>
<p>加粗的是符合定义的前后缀，其长度为 3</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>在暴力匹配中，我们回溯是因为害怕匹配过的字符中存在<strong>与目标串的一个前缀相同的子字符串</strong>，但我们不知道其位置，所以就索性回溯到最初起点的下一位</p>
<p>但是当我们了解了上面的概念之后就可以分析出，当两个指针不匹配时，对于目标串指针匹配过的字符，则说明我们可以把<strong>已匹配的字符的最长相等前缀与后缀</strong>进行对应</p>
<p>举个例子：</p>
<p>在 abababad 中找 abad 时，当匹配到 aba<strong>b</strong> 时会进行回溯。aba 我们已经匹配过了，它的最长相等前后缀长度为 1</p>
<p>那么在回溯时我们就只需要把第一位回溯到 ab<strong>a</strong>babad 中的加粗位置就可以了，不必担心略过了一些重要的字符</p>
<p>所以我们就很好理解了，next 中只需要存储<strong>当前下标之前的子字符串</strong>的最大相等前后缀长度就可以了</p>
<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><blockquote>
<p>$next[i]$ 的意义是：目标串指针在 $i-1$ 下标位置需要回溯时下一步跳转到的<strong>目标串下标位置</strong></p>
<p>其中 $next[0]$ 初始化为 -1</p>
</blockquote>
<p>KMP 算法也是使用双指针（前缀指针 $j$ 和后缀指针 $i$）来生成 next 数组，当两个指针不相等时 $j$ 回溯到 $next[j]$ 位置（这一步可以理解把目标串分成前缀和后缀，<strong>在后缀中搜索前缀不匹配时进行回溯</strong>）</p>
<p>其中 $j$ 要初始化为 -1，$i$ 要初始化为 0。因为要保证 $j$ 和 $i$ 分别遍历前后缀，而只有长度大于 1 的字符串才有前后缀，这样初始化能保证 $i$ 和 $j$ 的差值至少为 1（下标从 $i$ 到 $j$ 的字符串肯定有前后缀）</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><ul>
<li><p>ejr6fnslhbkgjv165gs5e36gb5841s3e65rhbg41sd41rbht35 中找 e65rhbg4</p>
<p>返回 31</p>
</li>
<li><p>s154re6bhrsed56bh36sd5r1thb6541brhn365dr4hb 中找 abc</p>
<p>返回 -1</p>
</li>
</ul>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> *next,string tar,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*next=<span class="number">-1</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">j</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>||tar[i]==tar[j])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(++i&gt;=len)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			*(next+i)=++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j=next[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp_match</span><span class="params">(string org,string tar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">j</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">olen</span><span class="params">(org.size())</span>,<span class="title">tlen</span><span class="params">(tar.size())</span>,next[tlen]</span>;</span><br><span class="line">	<span class="built_in">get_next</span>(next,tar,tlen);</span><br><span class="line">	<span class="keyword">while</span>(j&lt;tlen&amp;&amp;i&lt;olen)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>||org[i]==tar[j])</span><br><span class="line">			i++,j++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j=next[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j&gt;=tlen?i-j:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 31</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">kmp_match</span>(<span class="string">&quot;ejr6fnslhbkgjv165gs5e36gb5841s3e65rhbg41sd41rbht35&quot;</span>,<span class="string">&quot;e65rhbg4&quot;</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// -1</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">kmp_match</span>(<span class="string">&quot;s154re6bhrsed56bh36sd5r1thb6541brhn365dr4hb&quot;</span>,<span class="string">&quot;abc&quot;</span>)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liosq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> 2024/3/17 16:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] getNext(String target, <span class="type">int</span> len) &#123;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || target.charAt(i) == target.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++i &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                next[i] = ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">KMPMatch</span><span class="params">(String origin, String target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetLen</span> <span class="operator">=</span> target.length(), originLen = origin.length(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = getNext(target, targetLen);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; targetLen &amp;&amp; i &lt; originLen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || origin.charAt(i) == target.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j &gt;= targetLen ? i - j : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 31</span></span><br><span class="line">        System.out.println(KMPMatch(<span class="string">&quot;ejr6fnslhbkgjv165gs5e36gb5841s3e65rhbg41sd41rbht35&quot;</span>, <span class="string">&quot;e65rhbg4&quot;</span>));</span><br><span class="line">        <span class="comment">// -1</span></span><br><span class="line">        System.out.println(KMPMatch(<span class="string">&quot;s154re6bhrsed56bh36sd5r1thb6541brhn365dr4hb&quot;</span>, <span class="string">&quot;abc&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNext</span>(<span class="params">target, len</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">        j = -<span class="number">1</span>,</span><br><span class="line">        next = <span class="keyword">new</span> <span class="title class_">Array</span>(len)</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j === -<span class="number">1</span> || target[i] === target[j]) &#123;</span><br><span class="line">            next[++i] = ++j</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">KMPMatch</span>(<span class="params">origin, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">        j = <span class="number">0</span>,</span><br><span class="line">        oLen = origin.<span class="property">length</span>,</span><br><span class="line">        tLen = target.<span class="property">length</span>,</span><br><span class="line">        next = <span class="title function_">getNext</span>(target, tLen)</span><br><span class="line">    <span class="keyword">while</span> (j &lt; tLen &amp;&amp; i &lt; oLen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j === -<span class="number">1</span> || origin[i] === target[j]) &#123;</span><br><span class="line">            i++</span><br><span class="line">            j++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j &gt;= tLen ? i - j : -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 31</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">KMPMatch</span>(<span class="string">&quot;ejr6fnslhbkgjv165gs5e36gb5841s3e65rhbg41sd41rbht35&quot;</span>, <span class="string">&quot;e65rhbg4&quot;</span>))</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">KMPMatch</span>(<span class="string">&quot;s154re6bhrsed56bh36sd5r1thb6541brhn365dr4hb&quot;</span>, <span class="string">&quot;abc&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_next</span>(<span class="params">target: <span class="built_in">str</span>, <span class="built_in">len</span>: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="built_in">next</span> = [-<span class="number">1</span>]</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>:</span><br><span class="line">        <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> target[i] == target[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>.append(j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = <span class="built_in">next</span>[j]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kmp_match</span>(<span class="params">origin: <span class="built_in">str</span>, target: <span class="built_in">str</span></span>):</span><br><span class="line">    origin_len = <span class="built_in">len</span>(origin)</span><br><span class="line">    target_len = <span class="built_in">len</span>(target)</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="built_in">next</span> = get_next(target, target_len)</span><br><span class="line">    <span class="keyword">while</span> j &lt; target_len <span class="keyword">and</span> i &lt; origin_len:</span><br><span class="line">        <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> origin[i] == target[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = <span class="built_in">next</span>[j]</span><br><span class="line">    <span class="keyword">return</span> i - j <span class="keyword">if</span> j &gt;= target_len <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kmp_match(<span class="string">&#x27;ejr6fnslhbkgjv165gs5e36gb5841s3e65rhbg41sd41rbht35&#x27;</span>, <span class="string">&#x27;e65rhbg4&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(kmp_match(<span class="string">&#x27;s154re6bhrsed56bh36sd5r1thb6541brhn365dr4hb&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(next []<span class="type">int</span>, target <span class="type">string</span>, <span class="built_in">len</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">	j := <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>; &#123;</span><br><span class="line">		<span class="keyword">if</span> j == <span class="number">-1</span> || target[i] == target[j] &#123;</span><br><span class="line">			i++</span><br><span class="line">			j++</span><br><span class="line">			<span class="keyword">if</span> i &gt;= <span class="built_in">len</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			next[i] = j</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			j = next[j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KMPMatch</span><span class="params">(origin <span class="type">string</span>, target <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	oLen := <span class="built_in">len</span>(origin)</span><br><span class="line">	tLen := <span class="built_in">len</span>(target)</span><br><span class="line">	next := <span class="built_in">make</span>([]<span class="type">int</span>, tLen)</span><br><span class="line">	getNext(next, target, tLen)</span><br><span class="line">	<span class="keyword">for</span>  j &lt; tLen &amp;&amp; i &lt; oLen &#123;</span><br><span class="line">		<span class="keyword">if</span> j == <span class="number">-1</span> || origin[i] == target[j] &#123;</span><br><span class="line">			j++</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			j = next[j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> j &gt;= tLen &#123;</span><br><span class="line">		<span class="keyword">return</span> i - j</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 31</span></span><br><span class="line">	<span class="built_in">println</span>(KMPMatch(<span class="string">&quot;ejr6fnslhbkgjv165gs5e36gb5841s3e65rhbg41sd41rbht35&quot;</span>, <span class="string">&quot;e65rhbg4&quot;</span>))</span><br><span class="line">	<span class="comment">// -1</span></span><br><span class="line">	<span class="built_in">println</span>(KMPMatch(<span class="string">&quot;s154re6bhrsed56bh36sd5r1thb6541brhn365dr4hb&quot;</span>, <span class="string">&quot;abc&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>字符串</tag>
        <tag>JavaScript</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/post/c517589e/</url>
    <content><![CDATA[<h1 id="概念及用处"><a href="#概念及用处" class="headerlink" title="概念及用处"></a>概念及用处</h1><p>并查集（Union Find）是一种可以用来判断同属一个集合中相互关联的元素属于几个集合</p>
<p>当遇到需要把图中的 <strong>连通节点作为一个整体</strong> 时，可以用到并查集</p>
<p>比如：问A与B点、B与C点间各有一条路径，问是否存在一条直接或间接路径使A点能通往C点</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>将所有联系的节点都赋予一个父节点（根节点），通过判断两个节点的父节点是否相同来判断其是否属于同一个连通的集合中</p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>使用数组或哈希图（序号不大时用数组下标表示序号，序号太大用map存序号 -&gt; 根节点序号的映射）</p>
<p>存储一个数对 $(x,p_x)$ 其中 $x$ <strong>表示节点序号</strong>（保证唯一），<strong>而$p_x$ 表示 $x$ 的根节点序号</strong></p>
<p>初始化令集合内所有数对的 $p_x&#x3D;x$</p>
<h2 id="查询根节点"><a href="#查询根节点" class="headerlink" title="查询根节点"></a>查询根节点</h2><p>对传入节点序号 $x$ 进行以下操作：</p>
<ol>
<li>判断 $p_x$ 是否等于 $x$</li>
<li>若等于，则令 $x&#x3D;p_x$ 重复进行第1步操作</li>
<li>若不等于，则返回 $p_x$</li>
</ol>
<p>返回值即为 $x$ 的根节点序号</p>
<h2 id="合并根节点"><a href="#合并根节点" class="headerlink" title="合并根节点"></a>合并根节点</h2><p>传入节点序号 $a$ 和 $b$ ，进行以下操作：</p>
<ol>
<li>查询 $a , b$ 的根节点序号 $p_a , p_b$ </li>
<li>令 $p_{p_b}&#x3D;p_a$ （即将 $b$ 根节点的树合并到 $a$ 根节点的树下）</li>
</ol>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>对于每个节点来说，查询根节点总要递归经过一些中间节点很影响查询效率</p>
<p>所以我们可以在 <a href="#%E6%9F%A5%E8%AF%A2%E6%A0%B9%E8%8A%82%E7%82%B9">查询</a> 操作的第3步时令 $p_x&#x3D;p_{p_x}$ 后，返回 $p_x$</p>
<h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>当合并两个节点时，我们总是默认令 $b$ 树合并到 $a$ 树上。这会导致当 $b$ 树高度比 $a$ 树高时，合并后的树高度更高一层（如果此时 $a$ 树合并到 $b$ 树上，合并后高度为 $b$ 树高度）</p>
<p>所以我们需要再合并时判断两树的高度，我们把以一个节点为根节点的树的高度成为秩（$rank_x$）</p>
<p>再创建一个数组或图，存储一个根节点序号 -&gt; 秩的映射（数对），初始化 $rank$ 都为1</p>
<p>然后在合并操作前判断 $rank_{p_a}$ 与 $rank_{p_b}$ 的大小，令秩小的根节点合并到秩大的根节点所在树下</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>除了 C++ 其他用的都是哈希表形式实现的，两种方式各有优缺点</p>
<ul>
<li><strong>数组：</strong>访问速度快，序号不大情况下占用内存很小；数组大小受序号大小影响（数组只能开 $2^{32}-1$ 个元素）</li>
<li><strong>哈希表：</strong>访问速度也快但没有数组快，占用内存较大；可以接受多种形式的序号（字符串、数字等）</li>
</ul>
<p>代码都是用全局变量来写的，函数也没有考虑非法参数之类的情况，参考个思路就行了</p>
<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>在代码实现后使用的都是基于以下数据（每步下为节点的状态）：</p>
<ul>
<li>初始输入序号为：0，1，2，3，5 的节点</li>
</ul>
<blockquote>
<p><strong>0	1	2	3	5</strong></p>
</blockquote>
<ul>
<li>让 1 合并到 0 上</li>
</ul>
<blockquote>
<p><strong>0	2	3	5</strong></p>
<p><strong>1</strong></p>
</blockquote>
<ul>
<li>让 1 合并到 2 上</li>
</ul>
<blockquote>
<p>​	<strong>0		 3	5</strong></p>
<p><strong>1	  2</strong></p>
</blockquote>
<ul>
<li>让 3 合并到 5 上</li>
</ul>
<blockquote>
<p>​	<strong>0			3</strong></p>
<p><strong>1      2		5</strong></p>
</blockquote>
<ul>
<li>让 5 合并到 0 上</li>
</ul>
<blockquote>
<p>​	 <strong>0</strong></p>
<p><strong>1   2   3</strong></p>
<p>​		   <strong>5</strong></p>
</blockquote>
<p>所以最终：</p>
<ul>
<li>3 的父节点为 0</li>
<li>5 的父节点的秩为 3</li>
</ul>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 66</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unf</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> par,rank;</span><br><span class="line">&#125;uf[MAX_N];</span><br><span class="line"><span class="comment">// 查找x的根节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==uf[x].par)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="comment">// 路径压缩 </span></span><br><span class="line">	uf[x].par=<span class="built_in">find</span>(uf[x].par);</span><br><span class="line">	<span class="keyword">return</span> uf[x].par;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按秩合并两个节点所在树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a,<span class="type">const</span> <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">idx</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> rt[<span class="number">2</span>]=&#123;<span class="built_in">find</span>(a),<span class="built_in">find</span>(b)&#125;;</span><br><span class="line">	<span class="comment">// 秩相同说明树的高度肯定会增加 </span></span><br><span class="line">	<span class="keyword">if</span>(uf[rt[<span class="number">0</span>]].rank==uf[rt[<span class="number">1</span>]].rank)</span><br><span class="line">		uf[rt[<span class="number">0</span>]].rank++;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(uf[rt[<span class="number">0</span>]].rank&lt;uf[rt[<span class="number">1</span>]].rank)</span><br><span class="line">		idx=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 合并根节点和秩 </span></span><br><span class="line">	uf[rt[!idx]].par=rt[idx];</span><br><span class="line">	uf[rt[!idx]].rank=uf[rt[idx]].rank;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAX_N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		uf[i].par=i;</span><br><span class="line">		uf[i].rank=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  0</span></span><br><span class="line">	<span class="comment">//  1</span></span><br><span class="line">	<span class="built_in">merge</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//   0</span></span><br><span class="line">	<span class="comment">// 1   2</span></span><br><span class="line">	<span class="built_in">merge</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//   0   | 5</span></span><br><span class="line">	<span class="comment">// 1   2 | 3</span></span><br><span class="line">	<span class="built_in">merge</span>(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//    0</span></span><br><span class="line">	<span class="comment">// 1  2  5</span></span><br><span class="line">	<span class="comment">//       3</span></span><br><span class="line">	<span class="built_in">merge</span>(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="comment">// out: 0 3</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">find</span>(<span class="number">3</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;uf[<span class="built_in">find</span>(<span class="number">5</span>)].rank;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unf = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x: <span class="built_in">int</span></span>):</span><br><span class="line">    par = unf[x][<span class="string">&#x27;par&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> par == x:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    unf[x][<span class="string">&#x27;par&#x27;</span>] = find(par)</span><br><span class="line">    <span class="keyword">return</span> unf[x][<span class="string">&#x27;par&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>):</span><br><span class="line">    roots = [find(a), find(b)]</span><br><span class="line">    merge_root = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> unf[roots[<span class="number">0</span>]][<span class="string">&#x27;rank&#x27;</span>] == unf[roots[<span class="number">1</span>]][<span class="string">&#x27;rank&#x27;</span>]:</span><br><span class="line">        unf[roots[<span class="number">0</span>]][<span class="string">&#x27;rank&#x27;</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> unf[roots[<span class="number">0</span>]][<span class="string">&#x27;rank&#x27;</span>] &lt; unf[roots[<span class="number">1</span>]][<span class="string">&#x27;rank&#x27;</span>]:</span><br><span class="line">        merge_root = <span class="number">1</span></span><br><span class="line">    unf[roots[<span class="number">1</span> - merge_root]][<span class="string">&#x27;par&#x27;</span>] = roots[merge_root]</span><br><span class="line">    unf[roots[<span class="number">1</span> - merge_root]][<span class="string">&#x27;rank&#x27;</span>] = unf[roots[merge_root]][<span class="string">&#x27;rank&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">nodes: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        unf[node] = &#123;</span><br><span class="line">            <span class="string">&#x27;par&#x27;</span>: node,</span><br><span class="line">            <span class="string">&#x27;rank&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">merge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">merge(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">merge(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">merge(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 0 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;find(<span class="number">3</span>)&#125;</span> <span class="subst">&#123;unf[find(<span class="number">5</span>)][<span class="string">&#x27;rank&#x27;</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liosq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> 2024/3/9 20:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFindTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> parent;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> rank;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> rank)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">            <span class="built_in">this</span>.rank = rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, UnionFind&gt; unionFindMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span>[] nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> node : nodes) &#123;</span><br><span class="line">            unionFindMap.put(node, <span class="keyword">new</span> <span class="title class_">UnionFind</span>(node, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> unionFindMap.get(x).parent;</span><br><span class="line">        <span class="keyword">if</span> (x == parent) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        unionFindMap.get(x).parent = find(parent);</span><br><span class="line">        <span class="keyword">return</span> unionFindMap.get(x).parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mergeRoot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] roots = &#123;find(a), find(b)&#125;;</span><br><span class="line">        <span class="keyword">if</span> (unionFindMap.get(roots[<span class="number">0</span>]).rank == unionFindMap.get(roots[<span class="number">1</span>]).rank) &#123;</span><br><span class="line">            unionFindMap.get(roots[<span class="number">0</span>]).rank++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unionFindMap.get(roots[<span class="number">0</span>]).rank &lt; unionFindMap.get(roots[<span class="number">1</span>]).rank) &#123;</span><br><span class="line">            mergeRoot = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unionFindMap.get(roots[<span class="number">1</span> - mergeRoot]).parent = roots[mergeRoot];</span><br><span class="line">        unionFindMap.get(roots[<span class="number">1</span> - mergeRoot]).rank = unionFindMap.get(roots[mergeRoot]).rank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        init(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;);</span><br><span class="line">        merge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        merge(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        merge(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        merge(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 0 3</span></span><br><span class="line">        System.out.println(find(<span class="number">3</span>) + <span class="string">&quot; &quot;</span> + unionFindMap.get(find(<span class="number">5</span>)).rank);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unf = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params">nodes</span>) &#123;</span><br><span class="line">    nodes.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">        unf[node] = &#123;</span><br><span class="line">            <span class="attr">par</span>: node,</span><br><span class="line">            <span class="attr">rank</span>: <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> par = unf[x].<span class="property">par</span></span><br><span class="line">    <span class="keyword">if</span> (x === par) <span class="keyword">return</span> x</span><br><span class="line">    unf[x].<span class="property">par</span> = <span class="title function_">find</span>(par)</span><br><span class="line">    <span class="keyword">return</span> unf[x].<span class="property">par</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> roots = [<span class="title function_">find</span>(a), <span class="title function_">find</span>(b)]</span><br><span class="line">    <span class="keyword">if</span> (unf[roots[<span class="number">0</span>]].<span class="property">rank</span> === unf[roots[<span class="number">1</span>]].<span class="property">rank</span>)</span><br><span class="line">        unf[roots[<span class="number">0</span>]].<span class="property">rank</span>++</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (unf[roots[<span class="number">0</span>]].<span class="property">rank</span> &lt; unf[roots[<span class="number">1</span>]].<span class="property">rank</span>)</span><br><span class="line">        idx = <span class="number">1</span></span><br><span class="line">    unf[roots[<span class="number">1</span> - idx]].<span class="property">par</span> = roots[idx]</span><br><span class="line">    unf[roots[<span class="number">1</span> - idx]].<span class="property">rank</span> = unf[roots[idx]].<span class="property">rank</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">init</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="title function_">merge</span>(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="title function_">merge</span>(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="title function_">merge</span>(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="title function_">merge</span>(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 0 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;find(<span class="number">3</span>)&#125;</span> <span class="subst">$&#123;unf[find(<span class="number">5</span>)].rank&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双层map</span></span><br><span class="line"><span class="keyword">var</span> unf <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">init</span><span class="params">(nodes []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">    	<span class="comment">// 嵌套的map也要分配内存空间</span></span><br><span class="line">		unf[node] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">		unf[node][<span class="string">&quot;par&quot;</span>] = node</span><br><span class="line">		unf[node][<span class="string">&quot;rank&quot;</span>] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	par := unf[x][<span class="string">&quot;par&quot;</span>]</span><br><span class="line">	<span class="keyword">if</span> x == par &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	unf[x][<span class="string">&quot;par&quot;</span>] = find(par)</span><br><span class="line">	<span class="keyword">return</span> unf[x][<span class="string">&quot;par&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	idx := <span class="number">0</span></span><br><span class="line">	roots := []<span class="type">int</span>&#123;find(a), find(b)&#125;</span><br><span class="line">	<span class="keyword">if</span> unf[roots[<span class="number">0</span>]][<span class="string">&quot;rank&quot;</span>] == unf[roots[<span class="number">1</span>]][<span class="string">&quot;rank&quot;</span>] &#123;</span><br><span class="line">		unf[roots[<span class="number">0</span>]][<span class="string">&quot;rank&quot;</span>]++</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> unf[roots[<span class="number">0</span>]][<span class="string">&quot;rank&quot;</span>] &lt; unf[roots[<span class="number">1</span>]][<span class="string">&quot;rank&quot;</span>] &#123;</span><br><span class="line">		idx = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	unf[roots[<span class="number">1</span>-idx]][<span class="string">&quot;par&quot;</span>] = roots[idx]</span><br><span class="line">	unf[roots[<span class="number">1</span>-idx]][<span class="string">&quot;rank&quot;</span>] = unf[roots[idx]][<span class="string">&quot;rank&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// go在定义map后要分配内存空间</span></span><br><span class="line">	unf = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	_init([]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;)</span><br><span class="line">	merge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	merge(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">	merge(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">	merge(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="comment">// 0 3</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d %d&quot;</span>, find(<span class="number">3</span>), unf[find(<span class="number">5</span>)][<span class="string">&quot;rank&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>JavaScript</tag>
        <tag>Golang</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>localsend</title>
    <url>/post/f6962113/</url>
    <content><![CDATA[<h1 id="localsend"><a href="#localsend" class="headerlink" title="localsend"></a>localsend</h1><blockquote>
<p><a href="https://github.com/localsend/localsend">localsend&#x2F;localsend: An open-source cross-platform alternative to AirDrop (github.com)</a></p>
</blockquote>
<p>让你能在局域网内将数据传输给其他设备</p>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p>传输双方设备都前往 <a href="https://localsend.org/zh-CN/download?os=windows">LocalSend - 下载</a> 找到对应安装包，即可完成安装</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>双方设备登录 localsend 软件，然后通过局域网搜索到对应设备连接即可</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟利息计算</title>
    <url>/post/7bd5c796/</url>
    <content><![CDATA[<p>输入每月收入，和理财的年化利率上下限，用随机数模拟每天实际的收益，然后累加在一起</p>
<p>最后反复模拟上面的过程，取近似平均值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 99999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 获取某年总天数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gd</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((y%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">100</span>)||(y%<span class="number">400</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">3200</span>)||y%<span class="number">172800</span>==<span class="number">0</span>)?<span class="number">366</span>:<span class="number">365</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取某年某月总天数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gd</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">gd</span>(y)<span class="number">-365</span>+<span class="number">28</span>;</span><br><span class="line">	<span class="keyword">if</span>(m&gt;<span class="number">7</span>)</span><br><span class="line">		<span class="keyword">return</span> ((m<span class="number">-7</span>)&amp;<span class="number">1</span>)?<span class="number">31</span>:<span class="number">30</span>;</span><br><span class="line">	<span class="keyword">return</span> (m&amp;<span class="number">1</span>)?<span class="number">31</span>:<span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">double</span> &amp;c,<span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	c+=c*r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">double</span> c,<span class="type">double</span> yx,<span class="type">double</span> nz,<span class="type">double</span> yrl,<span class="type">double</span> yrh,<span class="type">int</span> cy,<span class="type">int</span> cm,<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> yr;</span><br><span class="line">	<span class="keyword">for</span>(;cnt;cm++,cnt--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(cm==<span class="number">13</span>)</span><br><span class="line">			cy++,cm-=<span class="number">12</span>,c+=nz;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> d=<span class="built_in">gd</span>(cy,cm);d&gt;<span class="number">0</span>;d--)</span><br><span class="line">		&#123;</span><br><span class="line">			yr=(<span class="built_in">rand</span>()%(N+<span class="number">1</span>)/(<span class="type">float</span>)(N+<span class="number">1</span>))*(yrh-yrl)+yrl;</span><br><span class="line">			<span class="built_in">calc</span>(c,yr/<span class="built_in">gd</span>(cy));</span><br><span class="line">		&#125;</span><br><span class="line">		c+=yx;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="type">double</span> c,yx,nz,yrl,yrh;</span><br><span class="line">	<span class="type">int</span> cy,cm,ty,tm,m;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;当前金额；每月收入；年终奖；年利率下限，上限（百分比%）；当前年份，月份；目标年份，月份；模拟次数\n&quot;</span>;</span><br><span class="line">	cin&gt;&gt;c&gt;&gt;yx&gt;&gt;nz&gt;&gt;yrl&gt;&gt;yrh&gt;&gt;cy&gt;&gt;cm&gt;&gt;ty&gt;&gt;tm&gt;&gt;m;</span><br><span class="line">	yrl/=<span class="number">100</span>;</span><br><span class="line">	yrh/=<span class="number">100</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">((ty-cy)*<span class="number">12</span>+tm-cm)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">tot</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		tot=tot+(<span class="built_in">solve</span>(c,yx,nz,yrl,yrh,cy,cm,cnt)-tot)/i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;总金额：%.2f\t总利息：%.2f\n&quot;</span>,tot,tot-c-cnt*yx-(ty-cy)*nz);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码记录</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/post/a378bd8e/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>由于使用 Python 一般都是需要用来做一些和人工智能相关的东西，所以可以直接安装 Anaconda（一个 Python 整合包）</p>
<h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>如果是直接安装了 Anaconda，里面会自带 pip，一款包下载工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载包 直接在‘包名’后加‘==[版本号]’可指定版本</span></span><br><span class="line">pip install [包名]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前已下载的所有包 可以结合管道来过滤出自己想搜索的包</span></span><br><span class="line">pip list</span><br></pre></td></tr></table></figure>

<h2 id="poetry"><a href="#poetry" class="headerlink" title="poetry"></a>poetry</h2><p>一款包管理和打包工具。如果在 Python 项目中看见了 <code>pyproject.toml</code> 这个文件，就可以用 <code>poetry install</code> 直接下载其中指定的依赖包</p>
<h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><h2 id="pip-设置国内镜像源"><a href="#pip-设置国内镜像源" class="headerlink" title="pip 设置国内镜像源"></a>pip 设置国内镜像源</h2><table>
<thead>
<tr>
<th align="center">来源</th>
<th align="center">链接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">清华</td>
<td align="center"><a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></td>
</tr>
<tr>
<td align="center">阿里云</td>
<td align="center"><a href="http://mirrors.aliyun.com/pypi/simple">http://mirrors.aliyun.com/pypi/simple</a></td>
</tr>
<tr>
<td align="center">中国科技大学</td>
<td align="center"><a href="https://pypi.mirrors.ustc.edu.cn/simple">https://pypi.mirrors.ustc.edu.cn/simple</a></td>
</tr>
<tr>
<td align="center">华中理工大学</td>
<td align="center"><a href="http://pypi.hustunique.com/">http://pypi.hustunique.com</a></td>
</tr>
<tr>
<td align="center">山东理工大学</td>
<td align="center"><a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org</a></td>
</tr>
<tr>
<td align="center">豆瓣</td>
<td align="center"><a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认源的url</span> </span><br><span class="line">pip config set global.index-url &quot;https://xxx&quot;</span><br></pre></td></tr></table></figure>

<h2 id="poetry-设置国内源"><a href="#poetry-设置国内源" class="headerlink" title="poetry 设置国内源"></a>poetry 设置国内源</h2><blockquote>
<p><strong>参考教程：</strong><a href="https://www.resourch.com/archives/66.html#heading-0">poetry如何更换国内源（清华源&#x2F;阿里源&#x2F;豆瓣源） - 数据科学SourceResearch (resourch.com)</a></p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1>]]></content>
      <categories>
        <category>笔记</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>P1006 [NOIP 2008 提高组] 传纸条</title>
    <url>/post/aa086c33/</url>
    <content><![CDATA[<h1 id="P1006-NOIP-2008-提高组-传纸条-洛谷-luogu-com-cn"><a href="#P1006-NOIP-2008-提高组-传纸条-洛谷-luogu-com-cn" class="headerlink" title="[P1006 NOIP 2008 提高组] 传纸条 - 洛谷 (luogu.com.cn)"></a>[P1006 <a href="https://www.luogu.com.cn/problem/P1006">NOIP 2008 提高组] 传纸条 - 洛谷 (luogu.com.cn)</a></h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>算法题</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows</title>
    <url>/post/0/</url>
    <content><![CDATA[<h1 id="文件图标变为空白图片"><a href="#文件图标变为空白图片" class="headerlink" title="文件图标变为空白图片"></a>文件图标变为空白图片</h1><p>大概率是图标缓存没了</p>
<ol>
<li><strong><code>Win+R</code> 输入 <code>%localappdata%</code></strong> 或<strong>进入<code>C:\Users\[用户名]\AppData\Local</code>目录下</strong></li>
<li>删除 <code>IconCache.db</code> 文件（如果没找到，就开启<strong>隐藏的项目</strong>）</li>
<li>重启电脑，或重启资源管理器（<strong>在任务管理器里右键进程重启</strong>）</li>
</ol>
<p>解决原理就是删除错误的缓存，让系统重新创建新的图标缓存</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>操作系统</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行 - 国内</title>
    <url>/post/e1a7f1fd/</url>
    <content><![CDATA[<h1 id="高铁"><a href="#高铁" class="headerlink" title="高铁"></a>高铁</h1><ul>
<li>高铁一般<strong>发车前15分钟开始检票</strong>，<strong>发车前3分钟停止检票</strong>，安检和地铁差不多只用个两三分钟；建议<strong>抵达高铁站时至少预留20分钟时间</strong></li>
<li>有的高铁车型是<strong>没有插座</strong>的，如果手机没电了尽量带个充电宝或者出行前充满</li>
<li>如果有的AB检票口都可以检票，选个靠近自己车厢的检票口</li>
<li><strong>出发是上高铁；到达是下高铁</strong></li>
</ul>
<h1 id="飞机"><a href="#飞机" class="headerlink" title="飞机"></a>飞机</h1><ul>
<li><p>飞机早订票晚订票各有好处。早订票可以尽早值机<strong>抢到经济舱第一排位置</strong>；晚订票能<strong>抢到更低价格</strong></p>
</li>
<li><p>一订完票就马上去值机，不然<strong>第一排、靠窗、靠过道</strong>的位置都被抢光了</p>
</li>
<li><p>飞机一般<strong>起飞前30分钟开始检票</strong>，<strong>起飞前15分钟停止检票</strong>，且安检流程较为严格（要求把<strong>外套、电脑、充电宝、雨伞</strong>等物品单独放进筐里）；大部分机场都是远离市区的，考虑到<strong>取票、安检、前往登机口、登机</strong>等多种因素，建议<strong>抵达机场时至少预留40分钟时间</strong></p>
</li>
<li><p>飞机登机时会很挤，<strong>登机检票建议很早或很晚去排队</strong>（如果随身行李比较多建议早排队）</p>
</li>
<li><p>最好<strong>登机前或者飞机启动前上个厕所</strong>，飞机上升时不能上厕所，滑行加速时也不好上厕所</p>
</li>
<li><p>即使飞行时段覆盖饭点，<strong>飞机也不一定提供餐食</strong>，一定要在订票前关注好飞机是否提供餐食（正餐、小食、点餐）</p>
</li>
<li><p><strong>飞机飞行全程不能使用充电宝</strong>，如果随身带了充电宝，可以在飞机启动前先用会</p>
</li>
<li><p>大部分飞机座位都很挤，如果想看电影的话，最多用个平板，电脑一般放不下（非经济舱除外）</p>
</li>
<li><p><strong>出发是上飞机；到达是下飞机</strong></p>
</li>
</ul>
<h1 id="地铁卡"><a href="#地铁卡" class="headerlink" title="地铁卡"></a>地铁卡</h1><p>国内大部分城市都有地铁，可以用<strong>支付宝出行</strong>扫进出站的地铁码</p>
<p>还挺方便的，扣钱是直接用支付宝支付的，到了新城市会提示你是否切换地铁卡，直接注册一个卡就行了</p>
<h1 id="酒店"><a href="#酒店" class="headerlink" title="酒店"></a>酒店</h1><ul>
<li><p>图便宜可以住多人青旅，30 多一晚</p>
</li>
<li><p>如果想住单人，也可以选那种改造的小酒店，一晚也能不过百</p>
</li>
<li><p>百元以内，就别想住正常的电竞酒店了，只能电竞和酒店二选一</p>
</li>
</ul>
<h1 id="行李"><a href="#行李" class="headerlink" title="行李"></a>行李</h1><p>如果酒店退房了，还想再多玩一会但是嫌行李麻烦，可以把行李寄存到景点附近的店铺里（我在武汉黄鹤楼附近是不到 10 块一个小时）</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>国内</tag>
      </tags>
  </entry>
  <entry>
    <title>Web反爬机制</title>
    <url>/post/5991018/</url>
    <content><![CDATA[<h1 id="无法打开调试工具"><a href="#无法打开调试工具" class="headerlink" title="无法打开调试工具"></a>无法打开调试工具</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>页面禁用了 F12、Ctrl + Shift + L 的键盘事件</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在浏览器菜单中选择打开**”开发者工具”**即可</p>
<h1 id="无限-debugger"><a href="#无限-debugger" class="headerlink" title="无限 debugger"></a>无限 debugger</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>js 定时循环执行 debugger 语句</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><h3 id="全局禁用断点"><a href="#全局禁用断点" class="headerlink" title="全局禁用断点"></a>全局禁用断点</h3><p>在调试工具源代码页按 Ctrl + F8，或者找到**”停用断点”**按钮</p>
<h3 id="禁用特定行断点"><a href="#禁用特定行断点" class="headerlink" title="禁用特定行断点"></a>禁用特定行断点</h3><p>在执行 debugger 行添加条件断点 false</p>
<blockquote>
<p>写成了一行的代码会失效，例如 <code>setInterval(() =&gt; &#123; debugger &#125;, 100)</code></p>
</blockquote>
<h3 id="替换-js-文件"><a href="#替换-js-文件" class="headerlink" title="替换 js 文件"></a>替换 js 文件</h3><p>搜索或堆栈分析，定位到 debugger 语句所在 js 文件，将语句注释掉并替换 js 文件</p>
<blockquote>
<p>有的网站会用 base64 对 js 语句进行加密，然后用 eval 执行</p>
</blockquote>
<h1 id="接口签名加密"><a href="#接口签名加密" class="headerlink" title="接口签名加密"></a>接口签名加密</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>客户端请求接口时携带<strong>对本地信息进行加密后的签名</strong></p>
<h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>逆向分析网站 js，在本地生成签名信息</p>
<h1 id="人机验证码"><a href="#人机验证码" class="headerlink" title="人机验证码"></a>人机验证码</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>用图形、滑块、拼图等多种形式，来判断操作者是否为机器</p>
<h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><h3 id="滑块验证码"><a href="#滑块验证码" class="headerlink" title="滑块验证码"></a>滑块验证码</h3><blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://www.jianshu.com/p/a3a0949a4e9a">禁用4399浏览器开发者工具无限debugger - 简书 (jianshu.com)</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1505309">突破前端反调试–阻止页面不断debugger-腾讯云开发者社区-腾讯云 (tencent.com)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark</title>
    <url>/post/d2cc9b2a/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记-金融知识</title>
    <url>/post/3c7b500b/</url>
    <content><![CDATA[<h1 id="柯布-道格拉斯生产函数"><a href="#柯布-道格拉斯生产函数" class="headerlink" title="柯布-道格拉斯生产函数"></a>柯布-道格拉斯生产函数</h1><p>$Y&#x3D;A_{t}L^{\alpha}<em>{t}K^{\beta}</em>{t}$，劳动 <strong>L</strong>abour；资本 <strong>K</strong>apital（Capital）</p>
<p>当 $\alpha+\beta&#x3D;1$ 时，$\alpha$ 和 $\beta$ 分别代表<strong>劳动</strong>和<strong>资本</strong>所得在总产量中所占的相对份额</p>
<h1 id="市场失灵的原因"><a href="#市场失灵的原因" class="headerlink" title="市场失灵的原因"></a>市场失灵的原因</h1><ol>
<li>垄断</li>
<li>外部影响</li>
<li>公共物品</li>
<li>信息不对称</li>
</ol>
<h1 id="竞争性消费"><a href="#竞争性消费" class="headerlink" title="竞争性消费"></a>竞争性消费</h1><p>竞争性是指消费者对某一种公共物品的消费会<strong>影响其他人对该公共物品的消费</strong></p>
<h1 id="派生存款"><a href="#派生存款" class="headerlink" title="派生存款"></a>派生存款</h1><p>原始存款通过银行放贷能够派生出的其他存款</p>
<p>举个简单例子来理解一下：</p>
<ol>
<li>张三在银行 A 存了 100 元，此时银行 A 获得了 100 元原始存款</li>
<li>银行会拿这 100 元去放贷，但按照法律要求必须要<strong>保留一部分存款准备金来应对取款</strong>，假设法定存款准备金率是 10%，那么就可以放出 90 元的贷款</li>
<li>李四在银行 A 贷款了这 90 元，并且有可能把这个贷款存到了银行 A 中</li>
</ol>
<p>第三步开始就可以循环进行，这样银行 A 利用张三存的 100 元创造出了远超于 100 元的派生的存款金额</p>
<p>一般来说，若法定存款准备金率为 $r$，原始存款为 $D$，则派生存款为 $D(\frac{1}{r}-1)$</p>
<h1 id="金融模式"><a href="#金融模式" class="headerlink" title="金融模式"></a>金融模式</h1><h2 id="P2C"><a href="#P2C" class="headerlink" title="P2C"></a>P2C</h2><p>网上有两种说法 Production to Consumer 和 Person to Company</p>
<ol>
<li><strong>Production to Consumer</strong>：生产产品送到消费者手中，传统的顾客商品模式</li>
<li><strong>Person to Company</strong>：个人和企业间的融资借贷模式</li>
</ol>
<h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><p>应该是 Person to Person？还是 Peer to Peer，总之意思都是个人对个人的网络借贷模式</p>
<h1 id="社会融资规模"><a href="#社会融资规模" class="headerlink" title="社会融资规模"></a>社会融资规模</h1><p>社会融资规模是指实体经济在一定时期内从<strong>金融体系中获得的资金总量</strong></p>
<p>社会融资规模主要包括：</p>
<ol>
<li>人民币贷款</li>
<li>外币贷款</li>
<li>委托贷款</li>
<li>信托贷款</li>
<li>未贴现的银行承兑汇票</li>
<li>企业债券</li>
<li>非金融企业境内股票融资</li>
<li>保险公司赔偿</li>
<li>投资性房地产</li>
<li>其他金融工具融资</li>
</ol>
<h1 id="基金类型"><a href="#基金类型" class="headerlink" title="基金类型"></a>基金类型</h1><ol>
<li><strong>股票型基金</strong>：80% 以上基金资产投资于股票。<strong>高风险、高收益</strong></li>
<li><strong>债务型基金</strong>：80% 以上基金资产投资于债券。<strong>较低风险、较低收益</strong></li>
<li><strong>货币市场基金</strong>：仅投资于<strong>货币市场工具</strong>的基金，这类基金的资产主要投资于短期货币工具，如商业票据、银行定期存单、短期政府债券、短期企业债券等短期有价证券。<strong>低风险、低收益、高流动性</strong></li>
<li><strong>混合型基金</strong>：投资于股票、债券、货币市场工具，且股票和债券投资的比例不符合前述规定</li>
</ol>
<h1 id="速动比率"><a href="#速动比率" class="headerlink" title="速动比率"></a>速动比率</h1><p>速动比率 &#x3D; 速动资产 &#x2F; 流动负债。其中，速动资产是指<strong>货币资金、交易性金融资产和各种应收款项等</strong>，可以在较短时间内变现的资产</p>
<p>它是<strong>衡量企业流动资产中可以立即变现用于偿还流动负债的能力</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>金融</category>
      </categories>
      <tags>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行 - 国外</title>
    <url>/post/c2abf603/</url>
    <content><![CDATA[<h1 id="通用注意事项"><a href="#通用注意事项" class="headerlink" title="通用注意事项"></a>通用注意事项</h1><h2 id="护照"><a href="#护照" class="headerlink" title="护照"></a>护照</h2><p>在支付宝搜护照点”预约办证”，可以在所在地附近选择办理点</p>
<p>办理期限：7-15个工作日；办理费用为 120 元（网上说 200 元，不知道哪个准）</p>
<p>护照有效期限不超过 10 年</p>
<h2 id="签证"><a href="#签证" class="headerlink" title="签证"></a>签证</h2>]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>国外</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter</title>
    <url>/post/e5974716/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="flutter-指令无响应"><a href="#flutter-指令无响应" class="headerlink" title="flutter 指令无响应"></a>flutter 指令无响应</h2><p>在 CMD 输入 <code>flutter --version</code> 无响应，打开 bin 目录运行 <code>flutter.bat</code> 也同样无响应</p>
<p>上网搜索说是镜像地址的原因，但在添加了这两个环境变量后仍然无响应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUTTER_STORAGE_BASE_URL: https://storage.flutter-io.cn</span><br><span class="line">PUB_HOSTED_URL: https://pub.flutter-io.cn</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>xpath</title>
    <url>/post/25900800/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用来定位 XML 元素的一种表达式，类似正则表达式</p>
<p>写爬虫的时候会经常用到 XPATH，例如用 selenium 定位 html 网页元素；用 uiautomator2 定位 app 元素等等</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="单元素"><a href="#单元素" class="headerlink" title="单元素"></a>单元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第 1 个 div 元素中的第 2 个 a 元素</span><br><span class="line">//div[1]/a[2]</span><br><span class="line"></span><br><span class="line"># 第 1 个 div 元素中的最后一个任意元素</span><br><span class="line">//div[1]/*[last()]</span><br><span class="line"></span><br><span class="line"># class 和 id 属性都为 test 的 div 元素</span><br><span class="line">//div[@class=&quot;test&quot; and @id=&quot;test&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="多元素"><a href="#多元素" class="headerlink" title="多元素"></a>多元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第 1 个 ul 元素中的所有 li 元素中的第 1 个 div 元素</span><br><span class="line">//ul[1]/li/div[1]</span><br><span class="line"></span><br><span class="line"># class 属性为 test 的所有 li 元素中的第 1 个 div 元素</span><br><span class="line">//li[@class=&quot;test&quot;]/div[1]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>42. 接雨水</title>
    <url>/post/2bfb457f/</url>
    <content><![CDATA[<h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h1><h2 id="O-n-O-1"><a href="#O-n-O-1" class="headerlink" title="$O(n)+O(1)$"></a>$O(n)+O(1)$</h2><p>两次遍历，第一次遍历<strong>从左向右</strong>，维护最高值，如果不能更新最高值则积累雨水；第二次遍历<strong>从右向左</strong>，仍然维护最高值，每次遍历都减去<strong>第一次遍历最高值和当前最高值之差</strong>，并且只遍历到<strong>第一次遍历最高值处</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">h</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">hi</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">len</span><span class="params">(height.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;h)</span><br><span class="line">                hi=i,h=height[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans+=height[hi]-height[i];</span><br><span class="line">        h=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;hi;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;h)</span><br><span class="line">                h=height[i];</span><br><span class="line">            ans=ans-height[hi]+h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="O-n-O-n"><a href="#O-n-O-n" class="headerlink" title="$O(n)+O(n)$"></a>$O(n)+O(n)$</h2><p><strong>单调栈</strong>，维护高度单调递减的下标栈，在维护栈的时候计算积累的雨水的宽度和高度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=42 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [42] 接雨水</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> h.length, ans = <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> left, right, i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; h[stack.peek()] &lt;= h[i]) &#123;</span><br><span class="line">        right = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left = stack.peek();</span><br><span class="line">        ans += (Math.min(h[left], h[i]) - h[right]) * (i - left - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

<h2 id="O-n-O-n-1"><a href="#O-n-O-n-1" class="headerlink" title="$O(n)+O(n)$"></a>$O(n)+O(n)$</h2><p><strong>动态规划</strong>，维护 $left[i],right[i]$ 数组，分别记录下标小于或大于 $i$ 的元素中的最大值，这样就可以确定<strong>每格最终会积累多少雨水</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=42 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [42] 接雨水</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> h.length, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n], right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    left[<span class="number">0</span>] = h[<span class="number">0</span>];</span><br><span class="line">    right[n - <span class="number">1</span>] = h[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      left[i] = Math.max(left[i - <span class="number">1</span>], h[i]);</span><br><span class="line">      right[n - i - <span class="number">1</span>] = Math.max(right[n - i], h[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      ans += Math.min(left[i], right[i]) - h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
        <tag>Java</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>weditor</title>
    <url>/post/c99061c2/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用来解析手机页面的元素组成的 Web 版工具，<strong>基于 Python 实现</strong></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装及运行"><a href="#安装及运行" class="headerlink" title="安装及运行"></a>安装及运行</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接安装版本也行 但因为我系统路径包含中文报错了 就装了旧版本</span></span><br><span class="line">pip install weditor==<span class="number">0.6</span>.<span class="number">4</span></span><br><span class="line"><span class="comment"># 安装 uiautomator2</span></span><br><span class="line">pip install uiautomator2==<span class="number">2.16</span>.<span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>由于我连手机一直没成功，所以我这里介绍连接模拟器（雷电模拟器）的方法</p>
<ol>
<li>将雷电模拟器的<strong>网络设置</strong>中，打开<strong>网络桥接模式</strong>，并且将桥接网卡设置为<strong>电脑用的本地网卡</strong></li>
<li>在模拟器的安装目录中，将 adb.exe 替换为电脑的 adb.exe</li>
<li>在安装目录打开 cmd 控制台，执行 <code>python -m uiautomator2 init</code></li>
<li>如果第 3 步最后显示 <code>Successfully init AdbDevice</code> 就可以了，在模拟器打开新添加的<strong>小黄车应用 ATX</strong></li>
<li>执行 <code>adb devices</code> 查看<strong>模拟器的序号</strong></li>
<li>执行 <code>python -m  weditor</code>，运行后会弹出浏览器的页面</li>
<li>在 <strong>Connect</strong> 按钮旁边输入框内输入<strong>模拟器的序号</strong>，点击 <strong>Connect</strong> 按钮连接手机或者模拟器等设备</li>
<li>连接成功后 <strong>Connect</strong> 按钮内会有一个绿色的草 Logo，点击 <strong>Dump Hierarchy</strong> 刷新界面，就可以分析当前模拟器页面的元素组成了</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>爬虫</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>应用软件</title>
    <url>/post/d3ce328c/</url>
    <content><![CDATA[<p>记录一些实际生活中用到的比较好用的应用软件，方便自己在以后更换设备时迁移应用和数据信息等等</p>
<h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><h2 id="滴答清单"><a href="#滴答清单" class="headerlink" title="滴答清单"></a>滴答清单</h2><p>很轻松地添加待办事项，对于我这种比较健忘的人来说很有帮助</p>
<p>软件有收费功能（日历式显示待办、代办设置时间段、关联微信等等），但免费功能就已经能满足大部分的需求了</p>
<h2 id="flomo"><a href="#flomo" class="headerlink" title="flomo"></a>flomo</h2><p>记笔记的应用，不像滴答清单一样能通知提醒，但是用来当一个便签一样记录下自己随笔也是不错的</p>
<p>也是有收费功能（每日回顾、反向链接、密码锁等等），也是一样，对我来说免费的就足够了</p>
<blockquote>
<p><strong>为什么不用系统自带便签</strong></p>
<p>因为我不确定会不会一直使用这个品牌的手机，数据同步不好搞，虽然随笔可能不是很重要，但是既然能数据同步为什么不同步呢</p>
</blockquote>
<h2 id="小黑盒"><a href="#小黑盒" class="headerlink" title="小黑盒"></a>小黑盒</h2><p>可以在手机上看 steam 游戏的实时价格</p>
<h2 id="Spotify"><a href="#Spotify" class="headerlink" title="Spotify"></a>Spotify</h2><p>一句话，<strong>能免费听周总的歌</strong></p>
<blockquote>
<p>国内平台的歌单迁移，可以去这个网站解决 <a href="https://yyrcd.com/n2s/">迁移 网易云 &#x2F; QQ 音乐到 Apple Music, Youtube Music, Spotify | yyrcd</a></p>
</blockquote>
<h1 id="桌面端"><a href="#桌面端" class="headerlink" title="桌面端"></a>桌面端</h1><h2 id="Lyricify"><a href="#Lyricify" class="headerlink" title="Lyricify"></a>Lyricify</h2><p>适配 Spotify 显示桌面歌词，Github 开源免费下载 <a href="https://github.com/WXRIW/Lyricify-App">GitHub - WXRIW&#x2F;Lyricify-App: Lyricify</a></p>
<h2 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h2><p>截屏软件，按 F1 可以快速截屏，同时还能把截屏固定到屏幕上</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>消费</title>
    <url>/post/5350dbd0/</url>
    <content><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><table>
<thead>
<tr>
<th align="center">品牌</th>
<th align="center">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="水杯"><a href="#水杯" class="headerlink" title="水杯"></a>水杯</h1><ul>
<li>塑料水杯材质不要选 <strong>PC[聚碳酸酯]</strong> 的，选 <strong>PP[聚丙烯] &#x2F; TRITAN &#x2F; PPSU</strong> 材质的都可以（越往后越贵）</li>
</ul>
<h2 id="保温杯"><a href="#保温杯" class="headerlink" title="保温杯"></a>保温杯</h2><table>
<thead>
<tr>
<th align="center">品牌</th>
<th align="center">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="center">富光 600ml</td>
<td align="center">69.9</td>
</tr>
<tr>
<td align="center">小米 350ml</td>
<td align="center">49</td>
</tr>
<tr>
<td align="center">膳魔师 500ml</td>
<td align="center">98</td>
</tr>
</tbody></table>
<ul>
<li>内胆有 316L 和 304 不锈钢的材质，目前看来膳魔师内胆用的是 304，其他用的是 316L</li>
</ul>
<h1 id="灯"><a href="#灯" class="headerlink" title="灯"></a>灯</h1><h2 id="屏幕挂灯"><a href="#屏幕挂灯" class="headerlink" title="屏幕挂灯"></a>屏幕挂灯</h2><table>
<thead>
<tr>
<th align="center">品牌</th>
<th align="center">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="center">明基 ScreenBar Pro</td>
<td align="center">979</td>
</tr>
<tr>
<td align="center">小米</td>
<td align="center">168</td>
</tr>
<tr>
<td align="center">飞利浦</td>
<td align="center">239</td>
</tr>
<tr>
<td align="center">雷神 ThundeRobot</td>
<td align="center">119</td>
</tr>
</tbody></table>
<h1 id="纸巾"><a href="#纸巾" class="headerlink" title="纸巾"></a>纸巾</h1><h2 id="抽纸"><a href="#抽纸" class="headerlink" title="抽纸"></a>抽纸</h2><table>
<thead>
<tr>
<th align="center">品牌</th>
<th align="center">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="center">京东京造 24*110抽</td>
<td align="center">30</td>
</tr>
<tr>
<td align="center">洁柔 24*110抽</td>
<td align="center">37</td>
</tr>
<tr>
<td align="center">维达 24*150抽</td>
<td align="center">44</td>
</tr>
<tr>
<td align="center">心相印 27*120抽</td>
<td align="center">45</td>
</tr>
<tr>
<td align="center">清风 24*130抽</td>
<td align="center">47</td>
</tr>
</tbody></table>
<h2 id="卷纸"><a href="#卷纸" class="headerlink" title="卷纸"></a>卷纸</h2><table>
<thead>
<tr>
<th align="center">品牌</th>
<th align="center">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="center">维达 12*140g</td>
<td align="center">21.9</td>
</tr>
<tr>
<td align="center">心相印 12*140g</td>
<td align="center">20.98</td>
</tr>
<tr>
<td align="center">维达 30*140g（带芯）</td>
<td align="center">41.9</td>
</tr>
<tr>
<td align="center">洁柔 30*140g（带芯）</td>
<td align="center">69.9</td>
</tr>
<tr>
<td align="center">清风 30*140g（带芯）</td>
<td align="center">69.9</td>
</tr>
<tr>
<td align="center">心相印 27*140（带芯）</td>
<td align="center">39.9</td>
</tr>
</tbody></table>
<h1 id="插排"><a href="#插排" class="headerlink" title="插排"></a>插排</h1><table>
<thead>
<tr>
<th align="center">品牌</th>
<th align="center">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="center">飞利浦 3+3USB 1.8m</td>
<td align="center">39.9</td>
</tr>
<tr>
<td align="center">小米 3+3USB 1.8m</td>
<td align="center">49</td>
</tr>
<tr>
<td align="center">小米 8 3m（4双口）</td>
<td align="center">39.9</td>
</tr>
<tr>
<td align="center">公牛 4 1.8m</td>
<td align="center">29.9</td>
</tr>
</tbody></table>
<h1 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h1><p>鼠标回报率 1k 就够了；无线鼠标电池一般在 300-500 毫安；主控尽量选 Nordic 的，也有用的 Realtek 的（网上褒贬不一）</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>学习记录</title>
    <url>/post/8ad1a2bc/</url>
    <content><![CDATA[<h1 id="2024-9-3"><a href="#2024-9-3" class="headerlink" title="2024-9-3"></a>2024-9-3</h1><table>
<thead>
<tr>
<th>certify</th>
<th>证明</th>
</tr>
</thead>
<tbody><tr>
<td>leisure</td>
<td>休闲</td>
</tr>
<tr>
<td>overlap</td>
<td>重叠、交叠</td>
</tr>
<tr>
<td>outweigh</td>
<td>超过</td>
</tr>
<tr>
<td>undertake</td>
<td>承担、负责</td>
</tr>
<tr>
<td>entitle</td>
<td>使享有权利；给…题名</td>
</tr>
<tr>
<td>reluctant</td>
<td>不情愿</td>
</tr>
<tr>
<td>accommodate</td>
<td>适应、给…提供空间</td>
</tr>
<tr>
<td>fierce</td>
<td>凶猛</td>
</tr>
<tr>
<td>intense</td>
<td>激烈、强烈、尖锐</td>
</tr>
<tr>
<td>impart</td>
<td>通知、透露</td>
</tr>
<tr>
<td>diffuse</td>
<td>传播</td>
</tr>
<tr>
<td>extent</td>
<td>程度、范围、面积</td>
</tr>
<tr>
<td>dab</td>
<td>轻触、轻拍</td>
</tr>
<tr>
<td>embark</td>
<td>开始</td>
</tr>
<tr>
<td>concede</td>
<td>承认</td>
</tr>
<tr>
<td>dread</td>
<td>畏惧</td>
</tr>
<tr>
<td>counter</td>
<td>反驳、抵制</td>
</tr>
<tr>
<td>prospect</td>
<td>希望、前景</td>
</tr>
<tr>
<td>inflict</td>
<td>使……遭受打击</td>
</tr>
<tr>
<td>levy</td>
<td>征收、征税</td>
</tr>
<tr>
<td>slack</td>
<td>松弛、懈怠</td>
</tr>
<tr>
<td>integrate</td>
<td>整合、合并</td>
</tr>
<tr>
<td>depose</td>
<td>宣誓作证；罢免（君王）</td>
</tr>
<tr>
<td>warrant</td>
<td>保证</td>
</tr>
<tr>
<td>compensate</td>
<td>补偿、弥补</td>
</tr>
<tr>
<td>cram</td>
<td>把…塞进</td>
</tr>
<tr>
<td>speculate</td>
<td>推测、猜测</td>
</tr>
<tr>
<td>dominate</td>
<td>支配、控制</td>
</tr>
</tbody></table>
<h1 id="2024-9-6"><a href="#2024-9-6" class="headerlink" title="2024-9-6"></a>2024-9-6</h1><table>
<thead>
<tr>
<th>cease</th>
<th>停止、终止</th>
</tr>
</thead>
<tbody><tr>
<td>deficit</td>
<td>赤字</td>
</tr>
<tr>
<td>criteria</td>
<td>标准</td>
</tr>
<tr>
<td>tariff</td>
<td>关税</td>
</tr>
<tr>
<td>compassion</td>
<td>同情、怜悯</td>
</tr>
<tr>
<td>accompaniment</td>
<td>伴奏</td>
</tr>
<tr>
<td>labor</td>
<td>劳动力</td>
</tr>
<tr>
<td>march</td>
<td>前进</td>
</tr>
<tr>
<td>commitment</td>
<td>献身、奉献、承诺</td>
</tr>
<tr>
<td>sponsor</td>
<td>发起者、倡议者</td>
</tr>
<tr>
<td>investor</td>
<td>投资者</td>
</tr>
<tr>
<td>obstacle</td>
<td>障碍</td>
</tr>
<tr>
<td>strain</td>
<td>损伤</td>
</tr>
<tr>
<td>in stock</td>
<td>有存货</td>
</tr>
<tr>
<td>fishery</td>
<td>渔场、渔业</td>
</tr>
<tr>
<td>resolution</td>
<td>解决、决议、决心</td>
</tr>
<tr>
<td>evacuate</td>
<td>撤离</td>
</tr>
<tr>
<td>resident</td>
<td>居民</td>
</tr>
<tr>
<td>relieve</td>
<td>解除、减轻、缓和</td>
</tr>
<tr>
<td>postage</td>
<td>邮资</td>
</tr>
<tr>
<td>serene</td>
<td>宁静的、安详的</td>
</tr>
<tr>
<td>retain</td>
<td>保留</td>
</tr>
<tr>
<td>withdraw</td>
<td>撤回；脱离</td>
</tr>
<tr>
<td>eliminate</td>
<td>消除、消灭</td>
</tr>
<tr>
<td>facilitate</td>
<td>促进、促使</td>
</tr>
<tr>
<td>flop</td>
<td>失败</td>
</tr>
<tr>
<td>offbeat</td>
<td>离奇的、标新立异的</td>
</tr>
<tr>
<td>fond</td>
<td>喜欢</td>
</tr>
<tr>
<td>glup</td>
<td>吞咽；忍住</td>
</tr>
<tr>
<td>waffle</td>
<td>华夫饼；无聊话</td>
</tr>
<tr>
<td>perch</td>
<td>栖息</td>
</tr>
<tr>
<td>succumb</td>
<td>屈服、因…死亡（to）</td>
</tr>
<tr>
<td>whiff</td>
<td>一吹、一吸</td>
</tr>
<tr>
<td>turbulent</td>
<td>湍急的、混乱的</td>
</tr>
<tr>
<td>stink</td>
<td>发臭、臭名昭著</td>
</tr>
<tr>
<td>constitute</td>
<td>构成、组成；任命</td>
</tr>
</tbody></table>
<h1 id="2024-9-7"><a href="#2024-9-7" class="headerlink" title="2024-9-7"></a>2024-9-7</h1><table>
<thead>
<tr>
<th>dismiss</th>
<th>解雇</th>
</tr>
</thead>
<tbody><tr>
<td>nevertheless</td>
<td>然而</td>
</tr>
<tr>
<td>grapple</td>
<td>扭打；设法解决；抓住</td>
</tr>
<tr>
<td>revive</td>
<td>使复活&#x2F;恢复</td>
</tr>
<tr>
<td>rehearse</td>
<td>排练；背诵；重复</td>
</tr>
<tr>
<td>restore</td>
<td>归还；使复原</td>
</tr>
<tr>
<td>shuttle</td>
<td>班车；公共汽车</td>
</tr>
<tr>
<td>contention</td>
<td>看法；争论</td>
</tr>
<tr>
<td>orient</td>
<td>面向，朝向</td>
</tr>
<tr>
<td>penetrate</td>
<td>渗透，穿透；被领悟</td>
</tr>
<tr>
<td>demonstrate</td>
<td>证明，演示</td>
</tr>
<tr>
<td>facility</td>
<td>设施，设备；天赋</td>
</tr>
<tr>
<td>far and away</td>
<td>无疑的</td>
</tr>
<tr>
<td>cut and dried</td>
<td>已成定局</td>
</tr>
<tr>
<td>hard and fast</td>
<td>明确的</td>
</tr>
<tr>
<td>fair and square</td>
<td>光明正大的</td>
</tr>
<tr>
<td>undermine</td>
<td>破坏</td>
</tr>
<tr>
<td>undergo</td>
<td>经历</td>
</tr>
</tbody></table>
<h1 id="2024-9-8"><a href="#2024-9-8" class="headerlink" title="2024-9-8"></a>2024-9-8</h1><table>
<thead>
<tr>
<th>reword</th>
<th>改写，重述</th>
</tr>
</thead>
<tbody><tr>
<td>remuneration</td>
<td>酬劳</td>
</tr>
<tr>
<td>dedicate</td>
<td>奉献</td>
</tr>
<tr>
<td>extinguish</td>
<td>熄灭，扑灭</td>
</tr>
<tr>
<td>exaggerate</td>
<td>夸张，夸大</td>
</tr>
<tr>
<td>ornament</td>
<td>装饰</td>
</tr>
<tr>
<td>luxury</td>
<td>设置的</td>
</tr>
<tr>
<td>exhibit</td>
<td>展览</td>
</tr>
<tr>
<td>plight</td>
<td>困境</td>
</tr>
<tr>
<td>wage</td>
<td>工资</td>
</tr>
<tr>
<td>pension</td>
<td>养老金</td>
</tr>
<tr>
<td>derive</td>
<td>获得，取得；产生</td>
</tr>
<tr>
<td>thrive</td>
<td>兴旺，繁荣</td>
</tr>
<tr>
<td>transit</td>
<td>通行；过渡</td>
</tr>
<tr>
<td>transmit</td>
<td>传输，传送；传播</td>
</tr>
<tr>
<td>transact</td>
<td>交易，做业务</td>
</tr>
<tr>
<td>liability</td>
<td>责任</td>
</tr>
</tbody></table>
<h1 id="2024-9-9"><a href="#2024-9-9" class="headerlink" title="2024-9-9"></a>2024-9-9</h1><table>
<thead>
<tr>
<th>donor</th>
<th>捐赠者</th>
</tr>
</thead>
<tbody><tr>
<td>external</td>
<td>永久、永恒的</td>
</tr>
<tr>
<td>toll</td>
<td>通行费；毁坏</td>
</tr>
<tr>
<td>imperative</td>
<td>迫切的</td>
</tr>
<tr>
<td>resort</td>
<td>求助</td>
</tr>
<tr>
<td>enforce</td>
<td>执行</td>
</tr>
<tr>
<td>sake</td>
<td>缘故</td>
</tr>
<tr>
<td>emphasize</td>
<td>强调</td>
</tr>
<tr>
<td>downplay</td>
<td>淡化</td>
</tr>
<tr>
<td>antique</td>
<td>古董</td>
</tr>
<tr>
<td>crust</td>
<td>地壳；面包皮</td>
</tr>
<tr>
<td>amplify</td>
<td>放大，增强</td>
</tr>
<tr>
<td>foster</td>
<td>促进</td>
</tr>
<tr>
<td>magnify</td>
<td>放大，夸大</td>
</tr>
<tr>
<td>utmost</td>
<td>最大的</td>
</tr>
</tbody></table>
<h1 id="2024-9-17"><a href="#2024-9-17" class="headerlink" title="2024-9-17"></a>2024-9-17</h1><table>
<thead>
<tr>
<th>soy</th>
<th>大豆</th>
</tr>
</thead>
</table>
<h1 id="2024-9-20"><a href="#2024-9-20" class="headerlink" title="2024-9-20"></a>2024-9-20</h1><table>
<thead>
<tr>
<th>linger</th>
<th>徘徊</th>
</tr>
</thead>
<tbody><tr>
<td>prolong</td>
<td>延长</td>
</tr>
<tr>
<td>preside</td>
<td>主持</td>
</tr>
<tr>
<td>plug</td>
<td>插头</td>
</tr>
<tr>
<td>astray</td>
<td>误入歧途</td>
</tr>
<tr>
<td>adrift</td>
<td>漂流</td>
</tr>
<tr>
<td>lump</td>
<td>肿块；懒汉</td>
</tr>
<tr>
<td>endure</td>
<td>忍受；持续</td>
</tr>
<tr>
<td>indispensable</td>
<td>不可或缺的</td>
</tr>
<tr>
<td>exclusive</td>
<td>独有，独家的</td>
</tr>
</tbody></table>
<h1 id="2024-9-22"><a href="#2024-9-22" class="headerlink" title="2024-9-22"></a>2024-9-22</h1><table>
<thead>
<tr>
<th>engage</th>
<th>保证</th>
</tr>
</thead>
<tbody><tr>
<td>enroll</td>
<td>登记</td>
</tr>
<tr>
<td>entice</td>
<td>诱惑、怂恿</td>
</tr>
<tr>
<td>subsidy</td>
<td>补贴、津贴</td>
</tr>
<tr>
<td>never so much as</td>
<td>甚至不</td>
</tr>
<tr>
<td>confidential</td>
<td>受信任、保密的</td>
</tr>
<tr>
<td>due</td>
<td>到期、应有的</td>
</tr>
<tr>
<td>instinct</td>
<td>本能、直觉</td>
</tr>
<tr>
<td>integrity</td>
<td>正直；完整</td>
</tr>
<tr>
<td>give away</td>
<td>赠送、捐赠</td>
</tr>
<tr>
<td>competitiveness</td>
<td>竞争力</td>
</tr>
<tr>
<td>with respect to</td>
<td>关于、谈到</td>
</tr>
</tbody></table>
<h1 id="2024-9-28"><a href="#2024-9-28" class="headerlink" title="2024-9-28"></a>2024-9-28</h1><table>
<thead>
<tr>
<th>ponder</th>
<th>思考、考虑</th>
</tr>
</thead>
<tbody><tr>
<td>contemplate</td>
<td>思考、考虑</td>
</tr>
<tr>
<td>conceive</td>
<td>思考、考虑</td>
</tr>
<tr>
<td>ponder upon</td>
<td>思考</td>
</tr>
<tr>
<td>conceive of</td>
<td>思考</td>
</tr>
<tr>
<td>perspective</td>
<td>观点；视角</td>
</tr>
<tr>
<td>distort</td>
<td>扭曲、歪曲</td>
</tr>
<tr>
<td>detach</td>
<td>拆卸、脱离</td>
</tr>
<tr>
<td>deviate</td>
<td>背离、偏离</td>
</tr>
</tbody></table>
<h1 id="2024-9-29"><a href="#2024-9-29" class="headerlink" title="2024-9-29"></a>2024-9-29</h1><table>
<thead>
<tr>
<th>divine</th>
<th>神圣的</th>
</tr>
</thead>
</table>
<h1 id="2024-10-14"><a href="#2024-10-14" class="headerlink" title="2024-10-14"></a>2024-10-14</h1><table>
<thead>
<tr>
<th>indulge</th>
<th>迁就、纵容</th>
</tr>
</thead>
<tbody><tr>
<td>prioritize</td>
<td>优先考虑</td>
</tr>
<tr>
<td>mesmerize</td>
<td>迷惑</td>
</tr>
<tr>
<td>amendment</td>
<td>修正案</td>
</tr>
<tr>
<td>constitution</td>
<td>宪法</td>
</tr>
</tbody></table>
<h1 id="2024-10-16"><a href="#2024-10-16" class="headerlink" title="2024-10-16"></a>2024-10-16</h1><table>
<thead>
<tr>
<th>compliance</th>
<th>遵守、依从</th>
</tr>
</thead>
<tbody><tr>
<td>obedience</td>
<td>服从、顺从</td>
</tr>
<tr>
<td>blend in</td>
<td>融入</td>
</tr>
<tr>
<td>deviation</td>
<td>背离、偏离</td>
</tr>
<tr>
<td>indifference</td>
<td>不重视、中立</td>
</tr>
<tr>
<td>discrimination</td>
<td>区别对待</td>
</tr>
<tr>
<td>initialtive</td>
<td>主动、首创</td>
</tr>
<tr>
<td>consensus</td>
<td>共识、一致</td>
</tr>
<tr>
<td>rational</td>
<td>合理的、理性的</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>健康</title>
    <url>/post/e57e29d1/</url>
    <content><![CDATA[<h1 id="心脏"><a href="#心脏" class="headerlink" title="心脏"></a>心脏</h1><ul>
<li>心脏如果偶尔<strong>刺痛</strong>的话，可能是神经紊乱，没什么大碍；但如果是钝痛建议去医院查一查</li>
<li>大一点的医院可以做 <strong>24 小时心电图</strong>，如果是心律不齐而且还是不放心的话可以做</li>
<li>心脏不舒服可以考虑做抽血检查<strong>心肌酶</strong>（需要空腹）</li>
<li>如果<strong>较为频繁心脏钝痛</strong>，去医院检查了也没检查出什么，可以尝试下<strong>顺式呼吸</strong>（吸气肚子变大，呼气肚子变小）。说不定可以改善情况（至少对我来说疼痛基本消失了）</li>
</ul>
<h1 id="鼻子"><a href="#鼻子" class="headerlink" title="鼻子"></a>鼻子</h1><h2 id="真菌感染"><a href="#真菌感染" class="headerlink" title="真菌感染"></a>真菌感染</h2><p>鼻翼发红、破皮，可能是真菌感染引起的</p>
<ul>
<li>校医院的医生给开了<strong>莫匹罗星软膏</strong></li>
<li>姐姐说可以涂<strong>红霉素眼膏</strong>（说是比软膏刺激性小）试一试，一天涂两次</li>
</ul>
<h2 id="鼻炎"><a href="#鼻炎" class="headerlink" title="鼻炎"></a>鼻炎</h2><ul>
<li>鼻子打喷嚏后会闻到异味，多半是鼻炎或鼻咽炎引起的，可以用以下药物：<ul>
<li><strong>糠酸莫米松鼻喷雾剂：</strong>30+元一瓶（逸青；60揿50，微克1揿）</li>
<li><strong>呋麻滴鼻液：</strong>3元一支（五景；10ml）</li>
<li><strong>鼻窦炎口服液：</strong>56元一盒（太极；12瓶）</li>
</ul>
</li>
</ul>
<h1 id="肾脏"><a href="#肾脏" class="headerlink" title="肾脏"></a>肾脏</h1><h2 id="肾结石"><a href="#肾结石" class="headerlink" title="肾结石"></a>肾结石</h2><p>第一时间去医院做彩超，确定结石大小</p>
<ul>
<li><p>肾结石较小，可以吃点<strong>扩张尿道</strong>和<strong>消炎</strong>的药，多喝水、运动把结石排出来</p>
</li>
<li><p>肾结石较大，就需要做手术排出了，有小结石的时候一定不要忽视</p>
</li>
</ul>
<blockquote>
<p><strong>预防肾结石，一定要 避免久坐、多喝水、少憋尿！！</strong></p>
</blockquote>
<h1 id="屁股"><a href="#屁股" class="headerlink" title="屁股"></a>屁股</h1><h2 id="痔疮"><a href="#痔疮" class="headerlink" title="痔疮"></a>痔疮</h2><p>便血或纸上带血，且血的颜色鲜红，大概率是痔疮</p>
<ul>
<li>外痔的话，涂点肛周用的痔疮膏可以缓解一下，每天要<strong>坐浴</strong>一会</li>
<li>内痔且不太大的话，可以考虑用以下药物：<ul>
<li><strong>裸花紫珠颗粒：</strong>38+元一盒（普正；3g一袋，9袋）</li>
<li><strong>麝香痔疮栓：</strong>22+元一盒（马应龙；10个；坐浴后用）</li>
<li><strong>抗菌洗剂：</strong>98元一盒（泰康；A剂B剂各8包；坐浴冲泡）</li>
</ul>
</li>
<li>内痔且很大的话，可能需要做手术切除了</li>
</ul>
<blockquote>
<p>少吃辛辣油腻刺激是其次，<strong>最主要的是要 避免久坐，保持肛周卫生，多做提肛运动！！</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium-wire</title>
    <url>/post/2cea8929/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>selenium 的拓展版，可以支持一些更高级的操作（比如我用到的拦截当前网页发生的请求等等）</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pip install selenium-wire</code> 直接安装即可</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="拦截网页请求"><a href="#拦截网页请求" class="headerlink" title="拦截网页请求"></a>拦截网页请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> seleniumwire <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Edge()</span><br><span class="line">driver.get(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接遍历.requests属性即可 每个request有url, headers, body属性</span></span><br><span class="line"><span class="keyword">for</span> request <span class="keyword">in</span> driver.requests:</span><br><span class="line">    <span class="keyword">if</span> request.url == <span class="string">&#x27;my target url&#x27;</span>:</span><br><span class="line">        <span class="comment"># 请求有响应</span></span><br><span class="line">        <span class="keyword">if</span> request.respone:</span><br><span class="line">            <span class="built_in">print</span>(request.response.body)</span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="安装依赖冲突"><a href="#安装依赖冲突" class="headerlink" title="安装依赖冲突"></a>安装依赖冲突</h2><ul>
<li><strong><code>No module named &#39;OpenSSL&#39;</code>：</strong>当时遇到的第一个报错，当时以为是 pyOpenSSL 的问题，但是找了下 selenium-wire 的依赖发现是没有装 <strong>mitmproxy</strong></li>
<li><strong><code>cannot import name &#39;deprecated&#39; from &#39;typing_extensions&#39;</code>：</strong>装完 mitmproxy 后的报错，现在看来应该还是版本的问题，再问了通义千问执行了下 <code>pip install --upgrade selenium-wire mitmproxy pyOpenSSL urllib3 certifi</code> 似乎解决了？</li>
<li><strong><code>No module named &#39;cryptography.exceptions&#39;</code>：</strong>重装了下 cryptography 解决，应该是版本的问题</li>
<li><strong><code>module &#39;lib&#39; has no attribute &#39;X509_V_FLAG_NOTIFY_POLICY&#39;</code>：</strong>看了下堆栈信息，是 OpenSSL 的报错信息，重装了下 pyOpenSSL 解决（应该是除了 selenium-wire 的其他依赖也用了 pyOpenSSL，但是版本要求不一样）</li>
</ul>
<h2 id="拦截请求的-response-body-乱码"><a href="#拦截请求的-response-body-乱码" class="headerlink" title="拦截请求的 response.body 乱码"></a>拦截请求的 <code>response.body</code> 乱码</h2><blockquote>
<p><a href="https://www.saoniuhuo.com/question/detail-2459936.html">Selenium-wire响应对象-以字符串而非字节形式获取响应主体的方法 _大数据知识库 (saoniuhuo.com)</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> seleniumwire.utils <span class="keyword">import</span> decode</span><br><span class="line"></span><br><span class="line"><span class="comment"># response是driver.requests[i]的属性，参考上文操作中的 拦截网页请求</span></span><br><span class="line">content = decode(response.body, response.headers.get(<span class="string">&#x27;Content-Encoding&#x27;</span>, <span class="string">&#x27;identity&#x27;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>爬虫</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>某信公众号数据</title>
    <url>/post/3ffe02a4/</url>
    <content><![CDATA[<p>秋招开始了，因为缺乏一些招聘信息的获取渠道，所以打算自己做个小爬虫爬些招聘信息来</p>
<p>刚开始想着去各大官网爬他们的公告，但是发现有些公司不更新公告，而且公告信息很滞后。所以打算从各大大学的就业公众号出发，写个公众号数据的爬虫</p>
<p>先是直接在网上搜了搜相关的教程，发现还有挺多的而且比较详细。我随便找了一篇看了下，大概思路就是通过微信公众平台的接口直接爬取数据。只不过需要自己注册一个公众号提供一个 <code>token</code>，然后调用查询公众号信息的接口就行了</p>
<p>因为感觉会很有用，所以自己封装了一下，把可复用的方法封装了一下，然后用 pyqt 搞了个简陋的可视化界面。自己反正用的还算可以，主要是因为没时间所以就没有搞太精致，在我的 github 里有开源，仓库名字叫 wechat-public，有感兴趣的可以去看一看 <a href="https://github.com/liosq/wechat-public">liosq&#x2F;wechat-public: 微信公众号爬虫 (github.com)</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket</title>
    <url>/post/2496d8d/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Socket 作为网络通信的一个高度抽象化的接口，可以在创建 Socket 时指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP</p>
<p>Socket 可以视为网络通信的一种媒介，传输数据时需要向 <strong>Socket 缓冲区</strong>（并不是文件的缓冲区，而是一块特定的内存区域）写入数据。最后再写入到网卡中发送</p>
<h1 id="Socket-模型"><a href="#Socket-模型" class="headerlink" title="Socket 模型"></a>Socket 模型</h1><p>以下的几个模型的目标都是<strong>让一个计算机能够处理更多的请求</strong></p>
<h2 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h2><p>采用一个进程处理一个请求的方式，也就是当父进程建立完与客户端的连接后，调用 <code>fork()</code> 函数创建一个子进程来处理请求</p>
<p>这种方式缺点显而易见，创建一个子进程会将父进程的<strong>文件描述符、内存地址空间、程序计数器、执行的代码等</strong>所有相关东西<strong>都复制一份</strong></p>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>在一个进程中创建多个线程处理请求，进程每接收到一个请求，就创建一个新线程来处理</p>
<p>这样<strong>频繁地创建和销毁线程</strong>带来的系统开销也不小，所以可以采用线程池来复用线程，同时进程将请求都放入到一个队列中，线程池获取队列中的请求后进行处理</p>
<p>但是这又引入了新的问题，就是线程安全。想要确保一个线程处理一个请求，需要在获取请求前<strong>加锁</strong></p>
<h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2><p>采用一个进程来维护所有的 Socket 请求</p>
<p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用</p>
<h3 id="select-poll"><a href="#select-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h3><p>将已连接的 Socket 都放进一个<strong>文件描述符集合</strong>中，然后将集合拷贝到<strong>内核空间</strong>中，由内核进行遍历，找出有事件发生的 Socket</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 通过两个方面，很好解决了 select&#x2F;poll 的问题：</p>
<p><strong>第一点，</strong>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <code>O(logn)</code></p>
<p>而 select&#x2F;poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select&#x2F;poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配</p>
<p><strong>第二点，</strong>epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p>
<h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><h2 id="传统拷贝"><a href="#传统拷贝" class="headerlink" title="传统拷贝"></a>传统拷贝</h2><p>通过调用 <code>read()</code>，<code>write()</code> 函数来传输文件</p>
<p>发生了 <strong>4 次用户态和内核态的上下文切换</strong>，和 <strong>4 次拷贝</strong>，流程如下：</p>
<ol>
<li>调用 <code>read()</code> 函数，由<strong>用户态切换到内核态</strong></li>
<li><strong>DMA</strong> 从<strong>磁盘</strong>将文件拷贝到<strong>内核缓冲区</strong></li>
<li><strong>CPU</strong> 从<strong>内核缓冲区</strong>拷贝到<strong>用户缓冲区</strong></li>
<li><code>read()</code> 结束，从<strong>内核态切换到用户态</strong></li>
<li>调用 <code>write()</code> 函数，由<strong>用户态切换到内核态</strong></li>
<li><strong>CPU</strong> 从<strong>用户缓冲区</strong>拷贝到<strong>Socket 缓冲区</strong></li>
<li><strong>DMA</strong> 从<strong>Socket 缓冲区</strong>拷贝到<strong>网卡</strong></li>
<li><code>write()</code> 结束，从<strong>内核态切换到用户态</strong></li>
</ol>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h3><p><code>mmap()</code> 会直接<strong>把内核缓冲区的数据映射到用户缓冲区</strong>，这样操作系统内核和用户空间之间就不需要进行任何数据拷贝操作了</p>
<p>发生了 <strong>4 次用户态和内核态的上下文切换</strong>，和 <strong>3 次拷贝</strong>，流程如下：</p>
<ol>
<li>调用 <code>mmap()</code> 函数，由<strong>用户态切换到内核态</strong></li>
<li><strong>DMA</strong> 从<strong>磁盘</strong>将文件拷贝到<strong>内核缓冲区</strong></li>
<li>用户空间与系统内核<strong>共享内核缓冲区</strong></li>
<li><code>mmap()</code> 结束，从<strong>内核态切换到用户态</strong></li>
<li>调用 <code>write()</code> 函数，由<strong>用户态切换到内核态</strong></li>
<li><strong>CPU</strong> 从<strong>内核缓冲区</strong>拷贝到<strong>Socket 缓冲区</strong></li>
<li><strong>DMA</strong> 从<strong>Socket 缓冲区</strong>拷贝到<strong>网卡</strong></li>
<li><code>write()</code> 结束，从<strong>内核态切换到用户态</strong></li>
</ol>
<h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p><code>sendfile()</code> 函数会<strong>直接将文件内容拷贝到网卡</strong>中，所以就不需要向用户空间传输数据。相应地，用户空间也无法知晓文件数据</p>
<p>发生了 <strong>2 次用户态和内核态的上下文切换</strong>，和 <strong>3 次拷贝</strong>，流程如下：</p>
<ol>
<li>调用 <code>sendfile()</code> 函数，由<strong>用户态切换到内核态</strong></li>
<li><strong>DMA</strong> 从<strong>磁盘</strong>将文件拷贝到<strong>内核缓冲区</strong></li>
<li><strong>CPU</strong> 从<strong>内核缓冲区</strong>拷贝到<strong>Socket 缓冲区</strong></li>
<li><strong>DMA</strong> 从<strong>Socket 缓冲区</strong>拷贝到<strong>网卡</strong></li>
<li><code>sendfile()</code> 结束，从<strong>内核态切换到用户态</strong></li>
</ol>
<p>如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术，就可以<strong>代替 CPU 将内核缓冲区数据拷贝到 Socket 缓冲区</strong></p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84-socket-%E6%A8%A1%E5%9E%8B">9.2 I&#x2F;O 多路复用：select&#x2F;poll&#x2F;epoll | 小林coding (xiaolincoding.com)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux - Socket</title>
    <url>/post/4ad4bf0/</url>
    <content><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h2 id="传统拷贝"><a href="#传统拷贝" class="headerlink" title="传统拷贝"></a>传统拷贝</h2><ul>
<li>从磁盘拷贝到内核缓冲区</li>
<li>内核缓冲区拷贝到用户空间的内存中</li>
<li>从用户空间的内存中</li>
</ul>
<h2 id="mmap-拷贝"><a href="#mmap-拷贝" class="headerlink" title="mmap 拷贝"></a>mmap 拷贝</h2><p>mmap 映射</p>
<h2 id="sendfile-拷贝"><a href="#sendfile-拷贝" class="headerlink" title="sendfile 拷贝"></a>sendfile 拷贝</h2><p>DMA</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>电话卡</title>
    <url>/post/a646ed62/</url>
    <content><![CDATA[<h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><ul>
<li><p><strong>选购电话卡套餐注意事项：</strong></p>
</li>
<li><p>每月<strong>全国通用流量</strong>有多少（一般五六十G）</p>
</li>
<li><p>了解<strong>流量组成</strong>都有哪些，定向流量<strong>适用于哪些APP</strong></p>
</li>
<li><p><strong>通话时长</strong>多少分钟（一般300分钟）</p>
</li>
<li><p><strong>套餐有效期</strong>多少，过了有效期月租会变成多少钱</p>
</li>
<li><p><strong>带不带宽带</strong>，如果加宽带要多少钱（大学的校园卡一般加10-20）</p>
</li>
<li><p><strong>拿到电话卡后注意事项：</strong>拿到卡之后一般是要<strong>线上预约激活</strong>的，激活后才能接收短信打电话之类的；如果拿到了电话卡但是一直不激活的话好像还是会扣钱（问相关人员，我之前的校园卡是不激活还会扣9块会员任选权益的钱）</p>
</li>
<li><p>避雷<strong>电信</strong>的<strong>校园随翼选N选2</strong>套餐（我是湖南办的卡，不确定其他地区是不是也有这种），每个月会给你2个权益点，一个权益点可以换一个权益。但是<strong>尊享特权</strong>、<strong>福利加倍</strong>两个板块每个只能换一次，而大部分有用的权益都在<strong>福利加倍</strong>板块里，<strong>尊享特权</strong>板块毛都没有只有个3小时雷神加速器还算一般。这套餐还不如移动的权益，每个月可以领两个权益，还都是主流应用的权益。</p>
</li>
<li><p>注销不能等欠费自动注销，要不然会失信，以后用不了这个运营商的产品了（十块钱的教训）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>出行</title>
    <url>/post/72a12a55/</url>
    <content><![CDATA[<h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><ul>
<li><strong>出门通勤：</strong>尽量坐地铁出行。长沙的话地铁从<strong>中南大学</strong>坐到<strong>长沙南站</strong>也就3块6</li>
</ul>
<h1 id="电动车"><a href="#电动车" class="headerlink" title="电动车"></a>电动车</h1><h2 id="价格参考"><a href="#价格参考" class="headerlink" title="价格参考"></a>价格参考</h2><ul>
<li><strong>开了一年多</strong>、<strong>续航四十多公里</strong>、<strong>车身较大</strong>的<strong>雅迪欧米-D</strong>，920 元（原价 1100，校园集市上收的，砍了点价）</li>
<li>二手电动车回收的（没讲价）<ul>
<li><strong>小型车：</strong>一千左右</li>
<li><strong>中大型车：</strong>一千二三</li>
</ul>
</li>
</ul>
<h2 id="购买注意事项"><a href="#购买注意事项" class="headerlink" title="购买注意事项"></a>购买注意事项</h2><ul>
<li><strong>电池续航：</strong>小型电动车续航基本连30公里都不到，中大型电动车续航在40-70公里。用的时候看电量主要关注<strong>拉满速度时的显示电量</strong></li>
<li><strong>电池是否可拆卸：</strong>电动车充电一般就这几种方式<ul>
<li>拆下电池带回家充电：方便、省钱，但是放家里充电是否安全需要考虑</li>
<li>去充电站充电：容易被别人拔掉充电线，在人群密度大的地方尤其严重</li>
<li>挂插排停楼下充电：和上面一样，容易被低素质人搞</li>
</ul>
</li>
<li><strong>减震效果：</strong>过减速带的时候，没减震的车能把你魂都震出来</li>
<li><strong>最高时速：</strong>新国标的车超过15码就会响而且限速25，但是一般都可以解限速，大的跑三四十多没什么问题</li>
</ul>
<h2 id="骑行注意事项"><a href="#骑行注意事项" class="headerlink" title="骑行注意事项"></a>骑行注意事项</h2><ul>
<li><strong>原则上要戴头盔</strong>，记得左右观望下看看<strong>原则在不在</strong>（开个玩笑，骑行距离远一定要戴头盔）</li>
<li>如果有时间<strong>检查下坐垫</strong>是否有什么针头之类的，防人之心不可无</li>
<li>刹车尽量<strong>用左刹</strong>（刹后轮），如果速度太快刹车只用前刹<strong>很有可能翻车</strong>（我妈经历过），实在刹不住也尽量先左刹再右刹</li>
<li>后视镜一定要多看，不仅仅是在变道转弯的时候</li>
<li>路面有水一定不要急刹，会翻车</li>
</ul>
<h2 id="相关杂物需求"><a href="#相关杂物需求" class="headerlink" title="相关杂物需求"></a>相关杂物需求</h2><ul>
<li><strong>雨衣：</strong>不用买那种可以包住电动车的雨衣；买正常大小的，坐着时候能包住腿的就够了，不会太大携带很方便</li>
<li><strong>坐垫罩：</strong>罩着坐垫后扯下来放车的篮子里，这样下雪下雨之后就不用拿抹布擦干坐垫了；夏天坐垫太热也能减少点坐垫温度</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>刹车不会解除 P 挡、喇叭不响、左右转灯不亮，可能是电动车<strong>转换器出问题了</strong>，去买电动车的地方问说 <strong>65</strong> 换一个新的（找那种修电动车的小摊 20 就能换，但是要看看参数什么对不对得上），如果是好心商家会给你排查是不是接线的问题</li>
<li>后座打开一般会有<strong>电池开关</strong>，如果在某个地方停很久担心再骑的时候没电，可以把开关关了（关了后被拖走也不会触发报警）</li>
<li>前后刹车如果<strong>螺丝出来了很多</strong>，可能是刹车片磨光了，换一个大概几十块（还没换过）</li>
<li><strong>刹车如果失灵了</strong>随便找个电动车维修地方让他给你弄紧一下就行，一般不用钱</li>
</ul>
<h1 id="自行车"><a href="#自行车" class="headerlink" title="自行车"></a>自行车</h1><h2 id="价格参考-1"><a href="#价格参考-1" class="headerlink" title="价格参考"></a>价格参考</h2><ul>
<li>某东买的<strong>正常规格</strong>凤凰单车，374 元 + 40 元（请师傅装车）</li>
</ul>
<h2 id="相关杂物需求："><a href="#相关杂物需求：" class="headerlink" title="相关杂物需求："></a>相关杂物需求：</h2><ul>
<li><strong>车锁：</strong>买个带密码的粗一点的就够了（因为再怎么结实也会被偷，差不多得了）</li>
</ul>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul>
<li>如果骑着感觉很费劲，检查下是不是刹车片太贴车轮了</li>
</ul>
<h1 id="汽车"><a href="#汽车" class="headerlink" title="汽车"></a>汽车</h1><ul>
<li>自动挡斜坡起步的话一般会有电子手刹，直接踩油门会自动解锁</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>25. K 个一组翻转链表</title>
    <url>/post/290cb30/</url>
    <content><![CDATA[<h1 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h1><h2 id="O-n-O-1"><a href="#O-n-O-1" class="headerlink" title="$O(n)+O(1)$"></a>$O(n)+O(1)$</h2><p>遍历链表，每遍历 $k$ 个节点就将这些节点倒置</p>
<p>思路很简单，但是在实际实现代码过程中会有一些小细节要注意，比如：倒置节点时，怎么做才不会影响这些节点<strong>之前的指针</strong>等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=25 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [25] K 个一组翻转链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start=</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, ans = <span class="keyword">new</span> <span class="title class_">ListNode</span>(), next;</span><br><span class="line">    <span class="keyword">while</span> (cur != tail) &#123;</span><br><span class="line">      next = cur.next;</span><br><span class="line">      cur.next = ans.next;</span><br><span class="line">      ans.next = cur;</span><br><span class="line">      cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail.next = ans.next;</span><br><span class="line">    head = tail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, las = head, lasPre = <span class="keyword">new</span> <span class="title class_">ListNode</span>(), next;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    lasPre.next = head;</span><br><span class="line">    head = lasPre;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">      next = cur.next;</span><br><span class="line">      <span class="keyword">if</span> (++count == k) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        reverse(las, cur);</span><br><span class="line">        lasPre.next = cur;</span><br><span class="line">        las.next = next;</span><br><span class="line">        lasPre = las;</span><br><span class="line">        las = next;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>BD202307-数字串</title>
    <url>/post/54cb3df4/</url>
    <content><![CDATA[<h1 id="码题集OJ-数字串-matiji-net"><a href="#码题集OJ-数字串-matiji-net" class="headerlink" title="码题集OJ-数字串 (matiji.net)"></a><a href="https://www.matiji.net/exam/brushquestion/7/4347/179CE77A7B772D15A8C00DD8198AAC74">码题集OJ-数字串 (matiji.net)</a></h1><h2 id="O-nlog-2n"><a href="#O-nlog-2n" class="headerlink" title="$O(nlog_2n)$"></a>$O(nlog_2n)$</h2><p><strong>高精度 + 后缀数组（倍增 + 基数排序）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1e6</span>+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> rak[N&lt;&lt;<span class="number">1</span>],tmp[N&lt;&lt;<span class="number">1</span>],fir[N],sec[N],cnt[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">string s,a,<span class="built_in">b</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">la</span><span class="params">(a.size())</span>,<span class="title">lb</span><span class="params">(b.size())</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(la&lt;lb)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(la,lb);</span><br><span class="line">		<span class="built_in">swap</span>(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lb;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]+=b[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;la)</span><br><span class="line">				a[i+<span class="number">1</span>]++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				a+=<span class="string">&#x27;1&#x27;</span>,la++;</span><br><span class="line">			a[i]-=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=lb;i&lt;la;i++)</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;la)</span><br><span class="line">				a[i+<span class="number">1</span>]++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				a+=<span class="string">&#x27;1&#x27;</span>,la++;</span><br><span class="line">			a[i]-=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">while</span>(la&gt;<span class="number">1</span>&amp;&amp;a[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">		a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()),la--;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">suf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">m</span><span class="params">(<span class="number">128</span>)</span></span>;</span><br><span class="line">	<span class="comment">// calc first arr</span></span><br><span class="line">	<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		cnt[rak[i]=s[i]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		fir[--cnt[rak[i]]]=i;</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;n;cout&lt;&lt;fir[i++]&lt;&lt;&quot; &quot;);cout&lt;&lt;endl;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> p,g=<span class="number">1</span>;g&lt;n;g&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// calc second arr</span></span><br><span class="line">		p=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n-g;i&lt;n;i++)</span><br><span class="line">			sec[p++]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="keyword">if</span>(fir[i]&gt;=g)</span><br><span class="line">				sec[p++]=fir[i]-g;</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;n;cout&lt;&lt;sec[i++]&lt;&lt;&quot; &quot;);cout&lt;&lt;endl;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// calc tmp arr but store in fir</span></span><br><span class="line">		<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			cnt[rak[sec[i]]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">			fir[--cnt[rak[sec[i]]]]=sec[i];</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;n;cout&lt;&lt;fir[i++]&lt;&lt;&quot; &quot;);cout&lt;&lt;endl;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// calc rank arr</span></span><br><span class="line">		<span class="built_in">swap</span>(tmp,rak);</span><br><span class="line">		p=<span class="number">1</span>;</span><br><span class="line">		rak[fir[<span class="number">0</span>]]=p;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(tmp[fir[i]]==tmp[fir[i<span class="number">-1</span>]]&amp;&amp;tmp[fir[i]+g]==tmp[fir[i<span class="number">-1</span>]+g])</span><br><span class="line">				rak[fir[i]]=p;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				rak[fir[i]]=++p;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;n;cout&lt;&lt;rak[i++]&lt;&lt;&quot; &quot;);cout&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(n&lt;=(g&lt;&lt;<span class="number">1</span>)+k)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">				<span class="keyword">if</span>(fir[i]+n-k<span class="number">-1</span>&lt;n)</span><br><span class="line">					<span class="keyword">return</span> fir[i];</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">	<span class="type">int</span> l,r,<span class="built_in">sum</span>(<span class="number">0</span>);</span><br><span class="line">	l=<span class="built_in">suf</span>();</span><br><span class="line">	r=l+n-k<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">		sum+=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;r;i--)</span><br><span class="line">		sum+=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span>(sum)</span><br><span class="line">	&#123;</span><br><span class="line">		b+=(sum%<span class="number">10</span>)+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		sum/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	b+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	a=s.<span class="built_in">substr</span>(l,n-k);</span><br><span class="line"><span class="comment">//	cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; </span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">add</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>码蹄集</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>高精度</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>BD202302-蛋糕划分</title>
    <url>/post/c69a46c0/</url>
    <content><![CDATA[<h1 id="码题集OJ-蛋糕划分-matiji-net"><a href="#码题集OJ-蛋糕划分-matiji-net" class="headerlink" title="码题集OJ-蛋糕划分 (matiji.net)"></a><a href="https://www.matiji.net/exam/brushquestion/2/4347/179CE77A7B772D15A8C00DD8198AAC74">码题集OJ-蛋糕划分 (matiji.net)</a></h1><h2 id="O-2-nn-3"><a href="#O-2-nn-3" class="headerlink" title="$O(2^nn^3)$"></a>$O(2^nn^3)$</h2><p><strong>前缀和 + 状态压缩 + 动态规划</strong></p>
<p>切的每一刀可以分为横切、竖且，枚举横切的所有可能，在<strong>每一种横切可能情况中</strong>用动态规划得到<strong>该情况下继续竖切的最优答案</strong></p>
<p>首先预处理得到蛋糕重量二维矩阵的二维前缀和</p>
<p>在枚举横切情况时用整形，其二进制位的第 $i$ 位（从1开始数）表示<strong>在第 $i$ 行后横切了一刀</strong>，从 0 枚举到 $2^{n-1}$，我们就可以得到所有横切的情况</p>
<p>对于每一种横切的情况，我们令 $dp[i][k]$ 为<strong>竖切 $k$ 次且最后一次在第 $i$ 行前竖切后的最优解</strong>（即所有蛋糕的重量最大值的最小值）</p>
<p>记<strong>竖切后第 $i$ 列到第 $j$ 列的最优解</strong>为 $res[i][j]$（实际要自己求，只是标注一下方便理解）、剩余的竖切次数为 $rst$</p>
<p>有如下状态转移方程：<br>$$<br>dp[1][0]&#x3D;0\<br>dp[i][k]&#x3D;min{max(dp[j][k-1],res[j][i-1]),(i&gt;j\ge k)},(i&gt;1,min(i-1,rst)\ge k&gt;0)<br>$$<br>$min{dp[i][rst],(rst&lt;i\le n)}$ 即为最终答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">17</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,k,<span class="built_in">ans</span>(INF);</span><br><span class="line"><span class="type">int</span> c[N][N],pr[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> si,<span class="type">int</span> sj,<span class="type">int</span> ei,<span class="type">int</span> ej)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	si--,sj--;</span><br><span class="line">	<span class="keyword">return</span> pr[ei][ej]-pr[ei][sj]-pr[si][ej]+pr[si][sj];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;c[i][j];</span><br><span class="line">			pr[i][j]+=pr[i<span class="number">-1</span>][j]+pr[i][j<span class="number">-1</span>]-pr[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>),x=<span class="number">0</span>;x&lt;d;x++)</span><br><span class="line">	&#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; row;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=x,i=<span class="number">1</span>;t;t&gt;&gt;=<span class="number">1</span>,i++)</span><br><span class="line">			<span class="keyword">if</span>(t&amp;<span class="number">1</span>)</span><br><span class="line">				row.<span class="built_in">push_back</span>(i);</span><br><span class="line">		row.<span class="built_in">push_back</span>(n);</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">rst</span><span class="params">(k-row.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">if</span>(rst&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(rst+<span class="number">1</span>,INF));</span><br><span class="line">		dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> ed=<span class="built_in">min</span>(rst,i<span class="number">-1</span>),t=<span class="number">1</span>;t&lt;=ed;t++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> li,res,j=t;j&lt;i;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(dp[j][t<span class="number">-1</span>]==INF)</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					li=<span class="number">0</span>;</span><br><span class="line">					res=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> r:row)</span><br><span class="line">					&#123;</span><br><span class="line">						res=<span class="built_in">max</span>(res,<span class="built_in">get</span>(li+<span class="number">1</span>,j,r,i<span class="number">-1</span>));</span><br><span class="line">						li=r;</span><br><span class="line">					&#125;</span><br><span class="line">					dp[i][t]=<span class="built_in">min</span>(dp[i][t],<span class="built_in">max</span>(res,dp[j][t<span class="number">-1</span>]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> li,i=rst+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[i][rst]==INF)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			li=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> r:row)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][rst]=<span class="built_in">max</span>(<span class="built_in">get</span>(li+<span class="number">1</span>,i,r,n),dp[i][rst]);</span><br><span class="line">				li=r;</span><br><span class="line">			&#125;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,dp[i][rst]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>码蹄集</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
        <tag>前缀和</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>BD202301-公园</title>
    <url>/post/98052ab/</url>
    <content><![CDATA[<h1 id="码题集OJ-公园-matiji-net"><a href="#码题集OJ-公园-matiji-net" class="headerlink" title="码题集OJ-公园 (matiji.net)"></a><a href="https://www.matiji.net/exam/brushquestion/1/4347/179CE77A7B772D15A8C00DD8198AAC74">码题集OJ-公园 (matiji.net)</a></h1><h2 id="O-nm"><a href="#O-nm" class="headerlink" title="$O(nm)$"></a>$O(nm)$</h2><p><strong>Dijkstra</strong></p>
<p>令 $rt[i],rf[i],rn[i]$ 分别代表 $i$ 点距离 $T,F,N$ 点的跳数</p>
<p>用 $Dijkstra$ 算法分别以 $T,F,N$ 为起点更新其到达其他点的最短跳数</p>
<p>遍历所有节点，并判断 $i$ 点是否能到达 $T,F,N$ 点；若能，则说明该节点可能为最优解中二人相遇时的节点，用<strong>其距离 $T,F,N$ 三点的跳数分别乘以其对应的移动消耗的和</strong>作为在二人在当前节点相遇后共同前往终点的总消耗，取最小值即可</p>
<blockquote>
<p>先更新以 $N$ 为起点，则可以先判断从 $N$ 点是否能到达 $T,F$ 两点。<strong>若不能则直接返回 -1</strong>，可以对无解的特殊情况进行特判</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; e;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">40001</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s,vector&lt;<span class="type">int</span>&gt; &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    r[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b:e[a])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[b]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r[b]=r[a]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r[b]=<span class="built_in">min</span>(r[a]+<span class="number">1</span>,r[b]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> te,fe,s,t,f,n,m,<span class="built_in">ans</span>(<span class="number">0x7fffffff</span>);</span><br><span class="line">    cin&gt;&gt;te&gt;&gt;fe&gt;&gt;s&gt;&gt;t&gt;&gt;f&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rt</span><span class="params">(N,<span class="number">-1</span>)</span>,<span class="title">rf</span><span class="params">(N,<span class="number">-1</span>)</span>,<span class="title">rn</span><span class="params">(N,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    e.<span class="built_in">resize</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a,b,i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(n,rn);</span><br><span class="line">    <span class="keyword">if</span>(rn[t]==<span class="number">-1</span>||rn[f]==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(t,rt);</span><br><span class="line">    <span class="built_in">bfs</span>(f,rf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=te+fe-s,i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rt[i]==<span class="number">-1</span>||rf[i]==<span class="number">-1</span>||rn[i]==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,rt[i]*te+rf[i]*fe+rn[i]*x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>码蹄集</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Shadowsocks</title>
    <url>/post/e428ee47/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先把pip下载好</span></span><br><span class="line">apt-get install python-pip	# Ubuntu</span><br><span class="line">yum install python-setuptools &amp;&amp; easy_install pip # CentOS</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装shadowsocks</span></span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL - 日志</title>
    <url>/post/386465fc/</url>
    <content><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p><strong>重做日志</strong>，是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要用于<strong>掉电等故障恢复</strong></p>
<p>记录的是事务提交时数据页的<strong>物理修改</strong>（先记录到内存缓冲区redo log buffer中，再刷盘到文件中）</p>
<p>redo log 可以保证事务在提交过程中，如果发生故障导致数据在缓冲区中<strong>还没刷盘到文件里</strong>时，数据库可以<strong>恢复数据页</strong></p>
<blockquote>
<p>每次事务提交先记录 redo log，而不是先将事务提交的数据刷盘到文件的原因是，事务提交的数据一般在不同数据页（Page）中，数据页写入磁盘时是<strong>随机IO</strong>，而记录的 redo log 写入磁盘则是<strong>顺序IO</strong>。顺序IO速度比随机IO快</p>
</blockquote>
<p>这种先写日志，再写磁盘的技术称为 WAL（<strong>W</strong>rite-<strong>A</strong>head <strong>L</strong>ogging）技术</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p><strong>回滚日志</strong>，是 InnoDB 存储引擎层生成的日志，实现了事务的<strong>原子性</strong>，主要用于<strong>事务回滚和 MVCC</strong></p>
<p>记录的是数据被修改前的信息，是<strong>逻辑日志</strong></p>
<p>每执行一条指令undo log就会存储<strong>相反的指令</strong>，当<strong>事务回滚</strong>时就可以根据这些信息回滚到<strong>事务提交前</strong>的数据状态</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p><strong>二进制日志（binary log）</strong>，用于记录数据库的所有更改操作，包括DDL和DML语句的执行</p>
<blockquote>
<p>redo log 是 <strong>InnoDB 存储引擎</strong>特有的日志文件；而 binlog 是 MySQL 中<strong>所有存储引擎</strong>都有的日志文件</p>
</blockquote>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://xiaolincoding.com/mysql/log/how_update.html">MySQL 日志：undo log、redo log、binlog 有什么用？ | 小林coding (xiaolincoding.com)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/post/a1ede006/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring - Bean</title>
    <url>/post/46ee2461/</url>
    <content><![CDATA[<h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><p>简单来说，Bean 代指<strong>被 IoC 容器所管理的对象</strong></p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>可以通过配置 XML 配置文件、注解或 Java 配置类来声明一个 Bean</p>
<h3 id="类声明注解"><a href="#类声明注解" class="headerlink" title="类声明注解"></a>类声明注解</h3><ul>
<li><strong><code>@Component</code>：</strong>通用注解，可标注任意类为 Spring 组件（如果不知道 Bean 对应哪一层可以用）</li>
<li><strong><code>@Repository</code>：</strong>对应持久层即 DAO 层</li>
<li><strong><code>@Service</code>：</strong>对应服务层</li>
<li><strong><code>@Controller</code>：</strong>对应 Spring MVC 控制层</li>
</ul>
<h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>Spring 内置的<code>@Autowired</code>，以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol>
<li><p><strong>创建 Bean 实例：</strong>Bean 容器首先找到配置文件中 Bean 的定义，然后使用 Java 反射 API 来创建 Bean 的实例</p>
</li>
<li><p><strong>Bean 依赖注入：</strong>为 Bean 设置属性和依赖</p>
</li>
<li><p><strong>处理 Aware 接口：</strong></p>
<ul>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例</li>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例</li>
</ul>
</li>
<li><p><strong>初始化：</strong></p>
<ul>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法</li>
<li>如果 Bean 在配置文件中的定义包含 <code>init-method</code> 属性，执行指定的方法</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
</ul>
</li>
<li><p><strong>销毁</strong>：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源</p>
<ul>
<li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法</li>
<li>如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法</li>
</ul>
</li>
<li><p>通过<strong>BeanDefinition</strong>获取Bean的定义信息</p>
</li>
<li><p>调用<strong>构造方法</strong>实例化Bean</p>
</li>
<li><p>Bean的<strong>依赖注入</strong></p>
</li>
<li><p>处理<strong>Aware接口</strong></p>
<ul>
<li><code>BeanNameAware</code></li>
<li><code>BeanFactoryAware</code></li>
<li><code>ApplicationContextAware</code></li>
</ul>
</li>
<li><p>Bean的后置处理器-<strong>BeanPostProcessor#Before</strong></p>
</li>
<li><p>初始化方法</p>
<ul>
<li>initialization</li>
<li>自定义init方法</li>
</ul>
</li>
<li><p>Bean的后置处理器-<strong>BeanPostProcessor#After</strong>（可以使用代理增强Bean）</p>
<ol>
<li>AOP</li>
<li>动态代理<ul>
<li>JDK动态代理</li>
<li>CGLIB动态代理</li>
</ul>
</li>
</ol>
</li>
<li><p>Bean销毁</p>
</li>
</ol>
<h2 id="循环依赖注入问题"><a href="#循环依赖注入问题" class="headerlink" title="循环依赖注入问题"></a>循环依赖注入问题</h2><blockquote>
<p><strong>循环依赖：</strong>两个或两个以上的对象互相持有对方，最终形成环路</p>
</blockquote>
<p>Spring 中是允许存在<strong>循环依赖注入</strong>的，其使用<strong>三级缓存</strong>来解决<strong>大部分</strong>的循环依赖</p>
<p><strong>三级缓存源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUPPRESSED_EXCEPTIONS_LIMIT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 一级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">// 三级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 二级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>缓存名称</th>
<th>源码名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td>singletonObjects</td>
<td>缓存已经经历了完整的生命周期，已经初始化完成的 Bean 对象</td>
</tr>
<tr>
<td>二级缓存</td>
<td>earlySingletonObjects</td>
<td>缓存早期的 Bean 对象（生命周期还未走完）</td>
</tr>
<tr>
<td>三级缓存</td>
<td>singletonFactories</td>
<td>缓存 ObjectFactory，表示对象工厂，用来创建某个对象</td>
</tr>
</tbody></table>
<p><strong>场景1：</strong>A对象需要依赖注入B，B对象中需要依赖注入A</p>
<ol>
<li>实例化A</li>
<li>原始对象A生成一个用于<strong>创建A的ObjectFactory对象</strong>（工厂对象），并存入<strong>singletonFactories</strong>（三级缓存）</li>
<li>发现A中需要注入B</li>
<li>实例化B</li>
<li>原始对象B生成一个<strong>工厂对象</strong>并存入<strong>三级缓存</strong></li>
<li>发现B中需要注入A</li>
<li>使用三级缓存中A的工厂对象创建A的代理对象，并存入到<strong>earlySingletonObjects</strong>（二级缓存中）</li>
<li>将A的代理对象注入给B</li>
<li>B创建成功，并存入到<strong>singletonObjects</strong>（一级缓存）中</li>
<li>将B注入给A</li>
<li>A创建成功，并存入到<strong>一级缓存</strong>中</li>
</ol>
<p><strong>场景2：</strong>A使用构造方法注入B，B对象使用构造方法注入A</p>
<blockquote>
<p>由于 Bean 的生命周期中构造函数是<strong>第一个执行</strong>的，所以 Spring 无法解决构造函数的依赖注入</p>
</blockquote>
<p>在构造方法中添加<code>@Lazy</code>注解懒加载</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-spring-ioc-%E7%9A%84%E4%BA%86%E8%A7%A3">Spring常见面试题总结 | JavaGuide</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring - 事务</title>
    <url>/post/f1c346df/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h2><ul>
<li><strong>编程式事务：</strong>在代码中硬编码，通过**<code>TransactionTemplate</code>或<code>TransactionManager</code>**手动管理事务。事务范围过大会出现事务未提交导致超时、因此事务要比锁的力度更小<ul>
<li>在分布式系统中推荐使用</li>
</ul>
</li>
<li><strong>声明式事务：</strong>配置 XML 配置文件或直接使用注解 <code>@Transactional</code><ul>
<li>单体应用或简单业务系统推荐使用</li>
</ul>
</li>
</ul>
<h2 id="事务失效场景"><a href="#事务失效场景" class="headerlink" title="事务失效场景"></a>事务失效场景</h2><h3 id="异常捕获未抛出"><a href="#异常捕获未抛出" class="headerlink" title="异常捕获未抛出"></a>异常捕获未抛出</h3><p>在方法中使用了<strong>try-catch块</strong>捕获异常但没有再抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 操作A</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 操作B</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        e.printStackTrace(); <span class="comment">// 在后面 throw 异常即可触发回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抛出受检异常（Checked-Exceptions）"><a href="#抛出受检异常（Checked-Exceptions）" class="headerlink" title="抛出受检异常（Checked Exceptions）"></a>抛出受检异常（<code>Checked Exceptions</code>）</h3><p><strong>原因：</strong>Spring 只会回滚非受检异常（<code>Unchecked Exceptions</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 改为 @Transactional(rollbackFor = Exception.class) 即可触发回滚</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throw</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 操作A</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="comment">// 操作B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非public方法"><a href="#非public方法" class="headerlink" title="非public方法"></a>非public方法</h3><p><strong>原因：</strong>Spring为方法创建代理、添加事务通知、前提条件都是该方法是public的</p>
<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p><strong>事务传播行为</strong>是为了解决<strong>业务层方法之间相互调用</strong>时可能出现的事务问题</p>
<p>所有的事务传播行为如下：</p>
<ul>
<li><strong><code>REQUIRED</code>：</strong>如果当前存在事务，则加入该事务；否则创建新事务</li>
<li><strong><code>REQUIRES_NEW</code>：</strong>创建一个新事务；如果当前存在事务，则将当前事务挂起</li>
<li><strong><code>NESTED</code>：</strong>创建一个新事务；如果当前存在事务，则将创建的事务作为当前事务的嵌套事务运行</li>
<li><strong><code>MANDATORY</code>：</strong>如果当前存在事务，则加入该事务；否则抛出异常</li>
<li><strong><code>SUPPORTS</code>：</strong>如果当前存在事务，则加入该事务；否则以非事务方式运行</li>
<li><strong><code>NOT_SUPPORTED</code>：</strong>以非事务方式运行，如果当前存在事务，则将当前事务挂起</li>
<li><strong><code>NEVER</code>：</strong>以非事务方式运行，如果当前存在事务，则抛出异常</li>
</ul>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>Spring 定义了一个枚举类 <code>Isolation</code> 来保存隔离级别，隔离级别的概念与数据库系统的隔离级别定义基本一致</p>
<ul>
<li><strong><code>DEFAULT</code>：</strong>使用后端数据库默认的隔离级别（MySQL 默认采用<code>REAPEATABLE_READ</code>，Oracle 默认采用 <code>READ_COMMITTED</code>）</li>
<li><strong><code>READ_UNCOMMITTED</code>：</strong>读未提交</li>
<li><strong><code>READ_COMMITTED</code>：</strong>读已提交</li>
<li><strong><code>REPEATABLE_READ</code>：</strong>可重复读</li>
<li><strong><code>SERIALIZABLE</code>：</strong>串行化</li>
</ul>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#springboot-%E5%85%81%E8%AE%B8%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%91%E7%94%9F%E4%B9%88">Spring常见面试题总结 | JavaGuide</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/post/364ea8cc/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><strong>设计模式</strong>是软件设计中<strong>常见问题的典型解决方案</strong>，他们就像能根据需求进行调整的预制蓝图，可用于解决代码中重复出现的设计问题</p>
<blockquote>
<p><strong>设计模式和算法有什么区别？</strong></p>
</blockquote>
<p>这两者虽然都是已知特定问题的典型解决方案，但算法更强调<strong>解决问题的一系列步骤</strong>；而设计模式更强调<strong>对解决方法的抽象的描述</strong>、</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>总体来说设计模式分为三大类：</p>
<ul>
<li><p><strong>创建型模式：</strong></p>
<ul>
<li><p>工厂方法模式</p>
</li>
<li><p>抽象工厂模式</p>
</li>
<li><p>单例模式</p>
</li>
<li><p>建造者模式</p>
</li>
<li><p>原型模式</p>
</li>
</ul>
</li>
<li><p><strong>结构性模式：</strong></p>
<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
</li>
<li><p><strong>行为性模式：</strong></p>
<ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代器模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介器模式</li>
<li>解释器模式</li>
</ul>
</li>
</ul>
<h2 id="总原则"><a href="#总原则" class="headerlink" title="总原则"></a>总原则</h2><h3 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h3><p><strong>对扩展开放、对修改关闭</strong></p>
<p>在程序需要进行拓展时，不能去修改原有的代码，而是要扩展原有代码，这样可以使得程序<strong>易于维护和升级</strong></p>
<h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>每个类应该实现单一的职责，如果其拥有多个职责，则应该将类拆分</p>
<h3 id="里氏替换原则（Liskov-Substitution-Principle）"><a href="#里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h3><p>任何可以使用基类的地方，都可以使用其子类，并且程序的行为保持不变</p>
<p>即：子类可以扩展父类的功能，但不应该改变父类的原有功能</p>
<h3 id="依赖倒置原则（Dependence-Inversion-Principle）"><a href="#依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（Dependence Inversion Principle）</h3><p>高层模块不应该依赖于底层模块，它们都应该依赖于抽象</p>
<h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h3><p>建立单一的接口，而不要建立庞大臃肿的接口</p>
<h3 id="迪米特法则（Demeter-Principle）"><a href="#迪米特法则（Demeter-Principle）" class="headerlink" title="迪米特法则（Demeter Principle）"></a>迪米特法则（Demeter Principle）</h3><p>一个类对自己依赖的类知道的越少越好</p>
<h3 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（Composite Reuse Principle）</h3><p>尽量使用对象组合，而不是继承来达到复用的目的</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns#intro-patterns">常用设计模式有哪些？ (refactoringguru.cn)</a></li>
<li><a href="https://www.cnblogs.com/geek6/p/3951677.html">23种设计模式全解析 - codeTao - 博客园 (cnblogs.com)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 工厂方法模式</title>
    <url>/post/cac4322c/</url>
    <content><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>是一种<strong>创建型设计模式</strong>，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型</p>
<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/factory-method">工厂方法设计模式 (refactoringguru.cn)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 抽象工厂模式</title>
    <url>/post/19e0d8d7/</url>
    <content><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/abstract-factory">抽象工厂设计模式 (refactoringguru.cn)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>CRC</title>
    <url>/post/eac5c577/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">calc</span><span class="params">(string F,string G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">res</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(G.length())</span>,<span class="title">m</span><span class="params">(F.length())</span>,<span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="type">bool</span> f[m],g[n],r[(n&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>],e;</span><br><span class="line">	<span class="comment">// init G(x)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;g[i]=G[i]-<span class="string">&#x27;0&#x27;</span>,i++);</span><br><span class="line">	<span class="comment">// init F(x)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;f[i]=F[i]-<span class="string">&#x27;0&#x27;</span>,i++);</span><br><span class="line">	<span class="comment">// init R(x) </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;r[i]=f[i],i++);</span><br><span class="line">	<span class="comment">// calculate R(x) </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+n&lt;=m;i+=a)</span><br><span class="line">	&#123;</span><br><span class="line">		e=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=a,j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			r[j]=r[j+t]^g[j];</span><br><span class="line">			<span class="keyword">if</span>(r[j])</span><br><span class="line">				e=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(e)</span><br><span class="line">				a=j+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=i+n,j=<span class="number">0</span>;j&lt;a&amp;&amp;t&lt;m;j++,t++)</span><br><span class="line">			r[n+j]=f[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;a+n;i++)</span><br><span class="line">		r[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>,i=a;t&lt;n;t++,i++)</span><br><span class="line">		res+=(r[i]+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">crc</span><span class="params">(string f,string g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">string <span class="title">o</span><span class="params">(f)</span></span>;</span><br><span class="line">	f.<span class="built_in">append</span>(g.<span class="built_in">length</span>()<span class="number">-1</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> o+<span class="built_in">calc</span>(f,g);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	string f,g,r;</span><br><span class="line">	cin&gt;&gt;f&gt;&gt;g;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;crc(f,g); </span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">calc</span>(<span class="built_in">crc</span>(f,g),g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码记录</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层模型 - 应用层</title>
    <url>/post/475f2ef/</url>
    <content><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用进程通信方式"><a href="#应用进程通信方式" class="headerlink" title="应用进程通信方式"></a>应用进程通信方式</h2><p><strong>每个应用层协议都是为了解决某一应用问题</strong>，通过位于不同主机中的多个应用进程之间的通信和协同工作来完成</p>
<ul>
<li>两个主机通信实际是<strong>其中对应的两个应用进程在通信</strong></li>
<li><strong>应用进程：</strong>为解决具体应用问题而彼此通信的进程</li>
</ul>
<h3 id="C-S"><a href="#C-S" class="headerlink" title="C&#x2F;S"></a>C&#x2F;S</h3><p><strong>客户 &#x2F; 服务器</strong>（<strong>C</strong>lient &#x2F; <strong>S</strong>erver）</p>
<h3 id="B-S"><a href="#B-S" class="headerlink" title="B&#x2F;S"></a>B&#x2F;S</h3><p><strong>浏览器 &#x2F; 服务器</strong>（<strong>B</strong>rowser &#x2F; <strong>S</strong>erver）</p>
<h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p><strong>对等</strong>（<strong>P</strong>eer <strong>to P</strong>eer）</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL - 锁</title>
    <url>/post/9a918c8a/</url>
    <content><![CDATA[<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p><strong>获取全局锁后，以下操作都会被阻塞：</strong></p>
<ul>
<li><strong>对数据的增删改操作：</strong>如<code>insert,delete,update,truncate</code>等语句</li>
<li><strong>对表结构的增删改操作：</strong>如<code>alter table,drop table/database</code>等语句</li>
</ul>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库时，不会因为数据或表结构发生更新导致<strong>备份的数据不是最新的数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush tables with read lock; # 获取全局锁 锁住所有表</span><br><span class="line">unlock tables;	# 释放全局锁</span><br></pre></td></tr></table></figure>

<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>MySQL 中表级别的锁有这几种：</p>
<ul>
<li><strong>表锁</strong></li>
<li><strong>元数据锁（MDL）</strong></li>
<li><strong>意向锁</strong></li>
<li><strong>AUTO-INC 锁</strong></li>
</ul>
<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>对特定表进行加锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock tables xxx read;	# 表级别的共享锁（读锁）</span><br><span class="line">locl tables xxx write;	# 表级别的独占锁（写锁）</span><br><span class="line">unlock tables;	# 释放所有表锁</span><br></pre></td></tr></table></figure>

<h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>元数据锁 MDL（<strong>M</strong>eta <strong>D</strong>ata <strong>L</strong>ock），在我们对数据库表进行操作时，<strong>会自动给表加上 MDL（读锁或写锁）</strong></p>
<p><strong>MDL 是在事务提交后才会释放</strong>，这意味着，<strong>事务执行期间 MDL 是一直持有的</strong></p>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>使用 InnoDB 引擎的表中对记录加<strong>共享锁或独占锁</strong>，都会先在表级别加<strong>意向共享&#x2F;独占锁</strong></p>
<p>意向共享&#x2F;独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，<strong>只会和共享&#x2F;独占表锁（<code>lock tables xxx read | write</code>）发生冲突</strong></p>
<blockquote>
<p><strong>有行级读写锁不就行了，为什么还要表级的意向锁？</strong></p>
</blockquote>
<p>如果没有意向锁，那么在加表级的独占锁时，就需要遍历表中所有记录，查看是否有记录存在独占表锁，效率会很低</p>
<p>有意向锁后，在加表级独占锁前，就会<strong>先获取意向独占锁</strong>，如果</p>
<h2 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h2><p>给主键添加 <code>AUTO_INCREMENT</code> 属性后，在表中插入一条记录数据库会<strong>自动给主键赋递增值</strong>，其主要是通过 <strong>AUTO-INC 锁</strong>来实现的</p>
<p>AUTO-INC 锁不是在事务提交时释放锁，而是在<strong>插入语句执行完成就会释放</strong></p>
<h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><h2 id="记录锁（record-lock）"><a href="#记录锁（record-lock）" class="headerlink" title="记录锁（record lock）"></a>记录锁（record lock）</h2><p>锁住一条记录，有 <strong>S 锁和 X 锁</strong>；锁住后无法对该记录进行修改</p>
<blockquote>
<p><strong>记录锁是对索引记录加锁</strong>，因为 InnoDB 一定存在聚簇索引，所以最终都会落在聚簇索引上</p>
</blockquote>
<h2 id="间隙锁（gap-lock）"><a href="#间隙锁（gap-lock）" class="headerlink" title="间隙锁（gap lock）"></a>间隙锁（gap lock）</h2><p><strong>只存在于可重复读隔离级别</strong>，目的是为了解决可重复读级别下的幻读问题</p>
<p>间隙锁会锁住一个<strong>主键的开区间</strong>，如果向插入一条主键介于该区间内的记录，会被阻塞住</p>
<p>间隙锁也有 S 锁和 X 锁，但是没有什么区别，都是兼容的。因为其目的是为了<strong>防止在区间内插入幻影记录</strong>，所以多个事务持有含有共同范围的间隙锁也是没有冲突的</p>
<h2 id="临键锁（next-key-lock）"><a href="#临键锁（next-key-lock）" class="headerlink" title="临键锁（next-key lock）"></a>临键锁（next-key lock）</h2><p>是<strong>记录锁和间隙锁的组合</strong>，能够锁定主键的一个范围，并锁住记录本身。所以其可以锁住一个<strong>半开半闭或闭区间</strong></p>
<p>由于临键锁是包含了间隙锁和记录锁的，所以如果创建了一个临键 X 锁，会<strong>与其他事务的临键 S 锁或 X 锁冲突而阻塞</strong></p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://xiaolincoding.com/mysql/lock/mysql_lock.html">MySQL 有哪些锁？ | 小林coding (xiaolincoding.com)</a></li>
<li><a href="https://www.cnblogs.com/caibaotimes/p/17958671">MySQL记录锁、间隙锁、临键锁（Next-Key Locks）加锁过程 - caibaotimes - 博客园 (cnblogs.com)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>2385. 感染二叉树需要的总时间</title>
    <url>/post/d6cc9ea/</url>
    <content><![CDATA[<h1 id="2385-感染二叉树需要的总时间"><a href="#2385-感染二叉树需要的总时间" class="headerlink" title="2385. 感染二叉树需要的总时间"></a><a href="https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/">2385. 感染二叉树需要的总时间</a></h1><p>以下为树节点的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="O-n-O-n"><a href="#O-n-O-n" class="headerlink" title="$O(n)+O(n)$"></a>$O(n)+O(n)$</h2><p><strong>DFS 构建邻接矩阵 + BFS 求以感染节点为根的树的最深深度</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; graph;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(graph.get(root.val) == <span class="literal">null</span>) &#123;</span><br><span class="line">            graph.put(root.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            graph.get(root.val).add(root.left.val);</span><br><span class="line">            <span class="keyword">if</span>(graph.get(root.left.val) == <span class="literal">null</span>) &#123;</span><br><span class="line">                graph.put(root.left.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            graph.get(root.left.val).add(root.val);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            graph.get(root.val).add(root.right.val);</span><br><span class="line">            <span class="keyword">if</span>(graph.get(root.right.val) == <span class="literal">null</span>) &#123;</span><br><span class="line">                graph.put(root.right.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            graph.get(root.right.val).add(root.val);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">amountOfTime</span><span class="params">(TreeNode root, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="type">int</span> cur, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断节点是否被访问过</span></span><br><span class="line">        Map&lt;Integer, Boolean&gt; visit = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        level.add(<span class="number">0</span>);</span><br><span class="line">        queue.add(start);</span><br><span class="line">        visit.put(start, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            cur = queue.poll();</span><br><span class="line">            ans = level.poll();</span><br><span class="line">            <span class="keyword">for</span>(Integer e : graph.get(cur)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(visit.get(e) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(e);</span><br><span class="line">                    level.add(ans + <span class="number">1</span>);</span><br><span class="line">                    visit.put(e, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="O-n-O-1"><a href="#O-n-O-1" class="headerlink" title="$O(n)+O(1)$"></a>$O(n)+O(1)$</h2><p><strong>DFS 求子树最深深度 + 优化</strong></p>
<p>调用 DFS 函数**获取递归左右子树得到的返回值 $x$**，对其优化：</p>
<ul>
<li><strong>如果子树中存在感染节点</strong>，则返回值 $x$ 表示<strong>从当前节点走 $-x$ 步可以到达感染节点</strong></li>
<li><strong>如果子树中不存在感染节点</strong>，则返回值 $x$ 就表示<strong>子树的最深深度</strong></li>
</ul>
<p>由此我们可以在每次递归到一个节点时，就算出**树中到达感染节点的距离的最大值 $ans$<strong>，设</strong>递归左右子树的函数返回值分别为 $left,right$**，则 $ans$ 可表示为：<br>$$<br>max(ans,left-right),(right&lt;0)\<br>max(ans,right-left),(left&lt;0)<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left, target),</span><br><span class="line">            right = dfs(root.right, target);</span><br><span class="line">        <span class="comment">// 当前节点是感染节点 对于其父节点来说 需要 1 步到达感染节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == target) &#123;</span><br><span class="line">            ans = Math.max(ans, Math.max(left, right));</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树都未被感染 正常返回树的最深深度</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 感染节点在右子树 且需要 -right 步到达感染节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ans = Math.max(ans, left - right);</span><br><span class="line">            <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 感染节点在左子树 且需要 -left 步到达感染节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = Math.max(ans, right - left);</span><br><span class="line">            <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">amountOfTime</span><span class="params">(TreeNode root, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root, start);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>287. 寻找重复数</title>
    <url>/post/25e6dcf4/</url>
    <content><![CDATA[<h1 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h1><h2 id="O-nlog-2n-O-1"><a href="#O-nlog-2n-O-1" class="headerlink" title="$O(nlog_2n)+O(1)$"></a>$O(nlog_2n)+O(1)$</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><strong>定义 $cnt[i]$ 表示数组中小于或等于 $i$ 的数有多少个</strong>，设数组中重复的数为 $target$，那么有<br>$$<br>cnt[i] \le i,(i \in [1,target-1])\<br>cnt[i]&gt;i,(i \in [target, n])<br>$$<br>又因为 $cnt$ 本身<strong>单调</strong>，所以我们可以<strong>结合这两点使用二分查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(nums.size())</span>,<span class="title">l</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">r</span><span class="params">(n)</span>,m,cnt</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;=m)</span><br><span class="line">                    cnt++;</span><br><span class="line">            <span class="comment">// 判断 target 在哪个区间</span></span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;m)</span><br><span class="line">                r=m<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>设计算数组中二进制位中第 $i$ 位为 1 的数有 $x$ 个，计算 $[1,n]$ 中第 $i$ 位为 1 的数有 $y$ 个，如果对于第 $i$ 位，有 $x&gt;y$，说明<strong>重复的数中第 $i$ 位为 1</strong></p>
<p>按照这个思路把所有位都算一遍，拼接起来得到的数就是数组中唯一重复的数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(nums.size())</span>,<span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x,y,b=<span class="number">1</span>;b&lt;=n;b&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x=y=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&amp;b)</span><br><span class="line">                    x++;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;b)</span><br><span class="line">                    y++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;y)</span><br><span class="line">                ans|=b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="O-n-O-1"><a href="#O-n-O-1" class="headerlink" title="$O(n)+O(1)$"></a>$O(n)+O(1)$</h2><p><strong>快慢指针，$Floyd$ 判圈算法</strong></p>
<p>设数组表示从下标 $i$ 到 $nums[i]$ 的一条边，对其建图。因为数组中必定有重复数 $target$，所以一定有两条或以上的边指向 $target$，又因为边的数量（数组长度）为 $n+1$、节点数量为 $n$，所以若有度大于 1 的节点，则<strong>必定存在环</strong>，且环入口即为 $target$</p>
<p>定义快慢指针 $f,s$，<strong>快指针 $f$ 每次走两步</strong>，<strong>慢指针 $s$ 每次走一步</strong>。则有以下条件：</p>
<ul>
<li><p><strong>环的长度为 $L$</strong></p>
</li>
<li><p><strong>从起点到环入口的距离为 $a$</strong></p>
</li>
<li><p><strong>从环入口走 $b$ 步到达相遇位置</strong></p>
</li>
<li><p><strong>又从相遇位置走 $c$ 步回到环入口</strong></p>
</li>
</ul>
<p>可得等式 $2(a+b)&#x3D;a+b+kL,(k\ge1)$，整理可得 $a&#x3D;(k-1)L+c$</p>
<p>由上等式可知，如果快慢指针相遇后，将慢指针放回起点，每次两个指针只走一步，则慢指针走 $a$ 步可以到达环入口，快指针在走了 $k-1$ 圈后也到了环的入口，<strong>两个指针相遇处即为环入口</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">f</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            s=nums[s],f=nums[nums[f]];</span><br><span class="line">        <span class="keyword">while</span>(s!=f);</span><br><span class="line">        s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s!=f)</span><br><span class="line">            s=nums[s],f=nums[f];</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>二分</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/post/24cb124c/</url>
    <content><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的<strong>传输层通信协议</strong></p>
<ul>
<li><strong>面向连接：</strong>一定是<strong>一对一</strong>才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是无法一对多</li>
<li><strong>可靠：</strong>无论网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文<strong>一定能够到达接收端</strong></li>
<li><strong>字节流：</strong>消息是没有便捷的，无论消息有多大都可以进行传输；并且<strong>消息是有序的</strong>，当前一个报文没有收到时，即使它先收到了后面的报文，也不会交由给应用层去处理，同时<strong>自动丢弃重复的 TCP 报文</strong></li>
</ul>
<h2 id="TCP-头部"><a href="#TCP-头部" class="headerlink" title="TCP 头部"></a>TCP 头部</h2><ul>
<li><strong>序列号：</strong>在建立连接时由计算机生成的随机数作为其初始值，通过<code>SYN</code>包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小。<strong>用来解决网络包乱序的问题</strong></li>
<li><strong>确认应答号：</strong>指<strong>下次期望收到的数据的序列号</strong>，发送端收到这个确认应答后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题</strong></li>
<li><strong>控制位：</strong><ul>
<li><strong><code>ACK</code>：</strong>Acknowledge，该位为 1 时，<strong>确认应答号</strong>的字段变为有效，TCP规定<strong>除了最初建立连接时的<code>SYN</code>包之外该位必须为 1</strong></li>
<li><strong><code>RST</code>：</strong>Restart</li>
<li><strong><code>SYN</code>：</strong>Synchronized</li>
<li><strong><code>FIN</code>：</strong>Finish</li>
</ul>
</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><strong>三次握手描述的是 TCP 建立连接的过程</strong>，服务端不可以主动连接客户端</p>
<ol>
<li>一开始，客户端和服务端都处于<code>CLOSE</code>状态，先是<strong>服务端主动监听某个端口</strong><ul>
<li>服务端进入<code>LISTEN</code>状态</li>
</ul>
</li>
<li>客户端会随机初始化序号<code>client_isn</code>，将其填入 TCP 头部的<strong>序号</strong>字段中，并将把<code>SYN</code>标志位置为 1；然后把该报文发给服务端<ul>
<li>客户端进入<code>SYN-SENT</code>状态</li>
</ul>
</li>
<li>服务端收到客户端的<code>SYN</code>报文后，首先服务端也随机初始化自己的序号<code>server_isn</code>，将<code>server_isn</code>和<code>clinet_isn+1</code>分别填入 TCP 头部的<strong>序号</strong>和<strong>确认应答号字段</strong>中，并将<code>ACK</code>标志位置为 1；然后将该报文发给客户端<ul>
<li>服务端进入<code>SYN-RCVD</code>状态</li>
</ul>
</li>
<li>客户端收到服务端报文后，将<code>server_isn+1</code>填入 TCP 头部的<strong>确认应答号</strong>字段，并将<code>ACK</code>标志位置为 1，然后将该报文发给服务端，<ul>
<li>客户端进入<code>ESTABLISHED</code>状态</li>
</ul>
</li>
<li>服务端收到客户端的应答报文<ul>
<li>服务端进入<code>ESTABLISHED</code>状态</li>
</ul>
</li>
</ol>
<h3 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h3><p>攻击者短时间内伪造不同 IP 地址的<code>SYN</code>报文，服务端每接收到一个<code>SYN</code>报文，就进入<code>SYN_RCVD</code>状态，但服务端发出的<code>ACK+SYN</code>报文无法得到未知 IP 主机的<code>ACK</code>应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务</p>
<p>在 TCP 三次握手时，<strong>Linux 内核会维护两个队列</strong>：</p>
<ul>
<li><strong>半连接队列</strong>，也称 SYN 队列</li>
<li><strong>全连接队列</strong>，也称 Accept 队列</li>
</ul>
<p><strong>正常的 TCP 连接流程：</strong></p>
<ul>
<li>服务端接收到客户端的<code>SYN</code>报文时，会创建一个半连接的对象，然后将其加入到内核的 <strong>SYN 队列</strong></li>
<li>接着发送 <code>SYN+ACK</code> 给客户端，等待客户端回应 <code>ACK</code> 报文</li>
<li>服务端接收到 <code>ACK</code> 报文后，<strong>从 SYN 队列中取出一个半连接对象</strong>，然后创建一个新的连接对象放入到 <strong>Accept 队列</strong></li>
<li>应用通过调用 <code>accept()</code> socket 接口，<strong>从 Accept 队列中取出连接对象</strong></li>
</ul>
<p>半连接和全连接队列都有<strong>最大长度限制</strong>，超出限制时，<strong>默认情况都会丢弃报文</strong>。所以 SYN 攻击本质上就是把 TCP 半连接队列打满，这样就会丢弃接下来收到的 SYN 报文，导致<strong>其他用户无法与服务端建立 TCP 连接</strong></p>
<h4 id="避免-SYN-攻击的方法"><a href="#避免-SYN-攻击的方法" class="headerlink" title="避免 SYN 攻击的方法"></a>避免 SYN 攻击的方法</h4><h5 id="调大-netdev-max-backlog"><a href="#调大-netdev-max-backlog" class="headerlink" title="调大 netdev_max_backlog"></a>调大 <code>netdev_max_backlog</code></h5><p>当<strong>网卡接收数据报的速度大于内核处理的速度</strong>时，会有一个队列保存这些数据包。控制该队列的最大值如下数，默认值是 1000，我们可以适当调大该参数值，比如设置为 10000：<code>net.core.netdev_max_backlog=10000</code></p>
<h5 id="增大-TCP-半连接队列"><a href="#增大-TCP-半连接队列" class="headerlink" title="增大 TCP 半连接队列"></a>增大 TCP 半连接队列</h5><p>增大 TCP 半连接队列，要同时增大下面这三个参数：</p>
<ul>
<li><strong>增大 <code>net.ipv4.tcp_max_syn_backlog</code></strong></li>
<li><strong>增大 <code>listen()</code> 函数中的 backlog</strong></li>
<li><strong>增大 <code>net.core.somaxconn</code></strong></li>
</ul>
<h5 id="开启-net-ipv4-tcp-syncookies"><a href="#开启-net-ipv4-tcp-syncookies" class="headerlink" title="开启 net.ipv4.tcp_syncookies"></a>开启 <code>net.ipv4.tcp_syncookies</code></h5><p>开启 <code>syncookies</code> 功能就可以<strong>在不使用 SYN 半连接队列的情况下成功建立连接</strong>，相当于绕过了 SYN 半连接来建立连接</p>
<p><strong>具体过程：</strong></p>
<ul>
<li><strong>当 SYN 队列满后</strong>，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个<code>cookie</code>值</li>
<li>将 cookie 值放到第二次握手报文头部的<strong>序列号</strong>字段中，然后服务端发给客户端</li>
<li>服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到 <strong>Accept 队列中</strong></li>
<li>最后应用程序通过调用 <code>accept()</code> 接口，从 <strong>Accept 队列</strong>取出的连接</li>
</ul>
<p><strong><code>net.ipv4.tcp_syncookies</code>参数主要有以下三个值：</strong></p>
<ul>
<li><strong>0：</strong>表示关闭该功能</li>
<li><strong>1：</strong>表示仅当半连接队列放满后，再启用它</li>
<li><strong>2：</strong>表示无条件开启功能</li>
</ul>
<p>所以在应对 SYN 攻击时，只需要将其设置为 1 即可：<code>echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</code></p>
<h5 id="减少-SYN-ACK-重传次数"><a href="#减少-SYN-ACK-重传次数" class="headerlink" title="减少 SYN+ACK 重传次数"></a>减少 <code>SYN+ACK</code> 重传次数</h5><p>当服务端受到 SYN 攻击时，就会有大量处于 <code>SYN-RCVD</code> 状态的 TCP 连接，处于这个状态的 TCP 会重传 <code>SYN+ACK</code>，当<strong>重传次数超过上限</strong>后，就会断开连接</p>
<p><code>SYN+ACK</code> 报文的最大重传次数<strong>由<code>tcp_synack_retries</code>内核参数决定</strong>（默认为 5 次），可以将其减少到 2 次：<code>echo 2 &gt; /proc/sys/net/ipv4/tcp_synack_retries</code></p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><strong>四次挥手描述的是 TCP 断开连接的过程</strong>，TCP 连接关闭不一定只能由客户端发起</p>
<ol>
<li>客户端打算关闭连接，会发送一个 TCP 头部<code>FIN</code>标志位被置为 1 的报<strong>文</strong><ul>
<li>客户端进入<code>FIN_WAIT_1</code>状态</li>
</ul>
</li>
<li>服务端收到<code>FIN</code>报文后，就向客户端发送<code>ACK</code>应答报文<ul>
<li>服务端进入<code>CLOSE_WAIT</code>状态</li>
</ul>
</li>
<li>客户端收到服务端的<code>ACK</code>应答报文<ul>
<li>客户端进入<code>FIN_WAIT_2</code>状态</li>
</ul>
</li>
<li>等待服务端处理完数据后，向客户端发送<code>FIN</code>报文<ul>
<li>服务端进入<code>LAST_ACK</code>状态</li>
</ul>
</li>
<li>客户端收到<code>FIN</code>报文后，向服务端发送<code>ACK</code>应答报文<ul>
<li>客户端进入<code>TIME_WAIT</code>状态</li>
</ul>
</li>
<li>服务端收到<code>ACK</code>应答报文，至此服务端完成连接的关闭<ul>
<li>服务端进入<code>CLOSE</code>状态</li>
</ul>
</li>
<li>客户端在经过 2MSL 后，<strong>自动进入<code>CLOSE</code>状态</strong>，至此客户端也完成连接的关闭</li>
</ol>
<h3 id="为什么需要-TIME-WAIT-状态"><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态"></a>为什么需要 <code>TIME_WAIT</code> 状态</h3><h4 id="确保可靠的连接关闭"><a href="#确保可靠的连接关闭" class="headerlink" title="确保可靠的连接关闭"></a>确保可靠的连接关闭</h4><p><code>TIME_WAIT</code> 状态确保了连接的彻底关闭。在次状态下，连接的以防等待一段时间，<strong>以确保对方已经收到了连接关闭的确认消息</strong></p>
<h4 id="防止新旧连接之间的混淆"><a href="#防止新旧连接之间的混淆" class="headerlink" title="防止新旧连接之间的混淆"></a>防止新旧连接之间的混淆</h4><p>在 <code>TIME_WAIT</code> 状态下，操作系统会保留连接端口一段时间，<strong>避免新的连接使用相同的端口号与之前的连接产生冲突</strong></p>
<h3 id="为什么-TIME-WAIT-要等待-2MSL"><a href="#为什么-TIME-WAIT-要等待-2MSL" class="headerlink" title="为什么 TIME_WAIT 要等待 2MSL"></a>为什么 <code>TIME_WAIT</code> 要等待 2MSL</h3><p>MSL（<strong>M</strong>aximum <strong>S</strong>egment <strong>L</strong>ifetime，<strong>报文最大生存时间</strong>），它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</p>
<p>设置等待 2MSL，是相当于<strong>允许报文丢失一次</strong>。当客户端发给服务端的<code>ACK</code>报文<strong>在 1 个 MSL 内丢失</strong>，那么服务端重发的<code>FIN</code>报文就会<strong>在第 2 个 MSL 内到达</strong>，此时客户端开始重新等待 2MSL</p>
<p>而为什么不是 4MSL 或更久，是因为连续两次丢包的概率很小，所以忽略它比解决它更具性价比</p>
<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>TCP 在出现<strong>数据包丢失</strong>或<strong>确认应答丢失</strong>时会发生超时重传</p>
<p>其主要原理就是在<strong>发送数据时设定一个定时器</strong>，当超过指定时间后，仍没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据</p>
<h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><p>超时时间主要和 <code>RTT</code>（<strong>R</strong>ound-<strong>T</strong>rip <strong>T</strong>ime，往返时延）有关，<code>RTT</code> 指的是<strong>数据发送时刻到接收到确认应答时刻的差值</strong>，即数据包的往返时间</p>
<p>超时重传时间用 <code>RTO</code>（Retransmission Timeout，超时重传时间）表示</p>
<ul>
<li>如果 <code>RTO</code> 过短，可能导致重发了因网络拥塞而超时，但没有丢包的数据，<strong>会进一步加重网络拥塞，导致更多数据超时</strong></li>
<li>如果 <code>RTO</code> 过长，虽然能很大程度上降低超时重传的误判率，但会<strong>降低网络传输的效率</strong></li>
</ul>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>不根据 <code>RTO</code> 来决定是否需要重传，而是通过<strong>对接收到的数据进行判断</strong>来决定是否重传</p>
<h3 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h3><p>SACK，即选择性重传，</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF-syn-%E6%94%BB%E5%87%BB-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-syn-%E6%94%BB%E5%87%BB">4.1 TCP 三次握手与四次挥手面试题 | 小林coding (xiaolincoding.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_44772566/article/details/136762707">一文彻底搞懂TIME_WAIT状态为什么等待2MSL的时长_time_wait为什么是2msl-CSDN博客</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 序列化</title>
    <url>/post/992db78a/</url>
    <content><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ul>
<li><strong>序列化：</strong>数据结构&#x2F;对象 &#x3D;&gt; 二进制字节流</li>
<li><strong>反序列化：</strong>二进制字节流 &#x3D;&gt; 数据结构&#x2F;对象</li>
</ul>
<p>序列化后的对象可以<strong>保存在磁盘上</strong>，或<strong>用于网络传输</strong></p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p><code>Serializable</code>接口是 Java 提供的<strong>标记接口</strong>，没有包含任何需要实现的方法。实现了这个接口的类表明其<strong>对象是可序列化的</strong>，可以被转换为字节流</p>
<h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><p><code>serialVersionUID</code>是用于版本控制的序列化版本号。它是一个<strong>长整型数值</strong>，用于标识类的版本。通过显式声明<code>serialVersionUID</code>，可以<strong>在类结构发生变化时仍然能够正确地进行反序列化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在类中没有明确声明<code>serialVersionUID</code>，Java 运行时系统会根据类的结构自动生成一个。这种自动生成的<code>serialVersionUID</code>是<strong>基于类的各个方面</strong>的，包括字段、方法、父类等</p>
<p>如果类的结构发生变化，可能导致<strong>自动生成的<code>serialVersionUID</code>发生变化</strong>，进而导致在反序列化时，类的版本不一致，<strong>引发<code>InvalidClassException</code>异常</strong></p>
<p>所以**显式声明<code>serialVersionUID</code>**是确保反序列化过程正确的关键</p>
<h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p><code>transient</code>关键字用于<strong>标记字段</strong>，表示在对象序列化时，<strong>这个字段应该被忽略</strong>；在反序列化时，<strong>这个字段会被恢复为其默认值</strong></p>
<p><code>transient</code>可以用在一些隐私信息字段上，如密码、访问令牌等，这些信息在对象序列化时需要被保护，以防泄露</p>
<blockquote>
<p><strong><code>ArrayList</code>的<code>elementData</code>为什么被<code>transient</code>修饰</strong></p>
<p>因为<code>elementData</code>是一个缓存数组，通常会预留一些容量。如果直接将其序列化会消耗更多时间和空间</p>
<p>所以**<code>ArrayList</code>中自己实现了<code>writeObject</code>和<code>readObject</code>这两个序列化方法<strong>，并且将<code>elementData</code>用<code>transient</code>修饰，</strong>保证序列化后的<code>ArrayList</code>中<code>elementData</code>中没有冗余空间**</p>
</blockquote>
<h4 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><ul>
<li><strong><code>transient</code>只能修饰变量</strong>，不能修饰方法和类</li>
<li><code>transient</code>标记的变量所在的类<strong>必须实现<code>Serailizable</code>接口</strong></li>
<li><code>static</code>变量因为不属于任何对象，所以无论有没有<code>transient</code>关键字修饰，<strong>都不会被序列化</strong></li>
</ul>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://juejin.cn/post/7313768894589009946?searchId=202404221459460B54A9EC02515D1DA7D1">Java 序列化机制详解 - 掘金 (juejin.cn)</a></li>
<li><a href="https://juejin.cn/post/7225941839290384442?searchId=20240422151452BCDD213ACAC5BB23F496">被遗忘的Java关键字：transient！ - 掘金 (juejin.cn)</a></li>
<li><a href="https://blog.csdn.net/zero__007/article/details/52166306">ArrayList中elementData为什么被transient修饰？_arraylist中的elementdata代表的是什么-CSDN博客</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 代理</title>
    <url>/post/50f7167e/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>代理模式中角色分为 3 种：</strong></p>
<ul>
<li><strong>Subject（抽象主题角色）：</strong>定义<strong>代理类和真实主题的公共对外方法</strong>，也是<strong>代理类代理真实主题的方法</strong></li>
<li><strong>RealSubject（真实主题角色）：</strong>真正实现业务逻辑的类</li>
<li><strong>Proxy（代理主题角色）：</strong>用来代理和封装真实主题</li>
</ul>
<p>代理模式按照<strong>职责</strong>来分类，至少可以分为以下几类：</p>
<ol>
<li><strong>远程代理</strong></li>
<li><strong>虚拟代理</strong></li>
<li><strong>Copy-on-Write代理</strong></li>
<li><strong>保护代理</strong></li>
<li><strong>Cache代理</strong></li>
<li><strong>防火墙代理</strong></li>
<li><strong>同步化代理</strong></li>
<li><strong>智能引用代理</strong></li>
</ol>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p><strong>代理对象和实际对象都继承同一个接口</strong>，在代理对象中指向的是实际对象的实例，这样<strong>对外暴露的是代理对象而真正调用的是实际对象</strong></p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>定义一个接口<code>UserService</code>，以及接口的一个实现类<code>UserServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Subject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RealSubject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将通过<strong>静态代理</strong>对<code>UserServiceImpl</code>进行功能增强，在调用<code>select</code>和<code>update</code>前后记录一些日志，写一个代理类<code>UserServiceProxy</code>，代理类需要实现<code>UserService</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Proxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select(); <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update(); <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行方法前的日志记录</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行方法后的日志记录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过静态代理，我们达到了功能增强的目的，并且没有侵入源代码，这是<strong>静态代理的一个优点</strong></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可以很好地保护实际对象的业务逻辑不对外暴露，从而提高安全性</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>当场景稍微复杂一些时，<strong>静态代理的缺点也会暴露出来</strong></p>
<ol>
<li>当需要代理读个类时，由于<strong>代理对象需要实现与目标对象一致的接口</strong>，由两种方式：<ul>
<li>只维护一个代理类，由这个代理类实现多个接口，这样会导致<strong>代理类过于庞大</strong></li>
<li>新建多个代理类，每个目标对象对应一个代理类，这样会导致<strong>产生过多的代理类</strong></li>
</ul>
</li>
<li>当接口需要增加、删除、修改方法的时候，目标对象和代理类都要同时修改，<strong>不易维护</strong></li>
</ol>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>为了改进静态代理的缺点，可以<strong>动态生成代理类</strong>，也就是动态代理</p>
<blockquote>
<p><strong>为什么类可以动态地生成？</strong></p>
</blockquote>
<p>JVM 中类加载过程主要分为五个阶段：<strong>加载、验证、准备、解析、初始化</strong>，其中加载阶段需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的<strong>二进制字节流</strong></li>
<li>通过字节流锁代表的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong></li>
<li>在内存中生成一个代理这个类的<code>java.lang.Class</code>对象，作为方法区这个类的<strong>各种数据的访问入口</strong></li>
</ol>
<p>常见的有以下两种实现动态代理的方式：</p>
<ul>
<li><strong>JDK动态代理：</strong>实现接口</li>
<li><strong>CGLIB动态代理：</strong>继承类</li>
</ul>
<h2 id="JDK-代理"><a href="#JDK-代理" class="headerlink" title="JDK 代理"></a>JDK 代理</h2><p>代理类通过实现<code>InvocationHandler</code>接口，并重写<code>invoke</code>方法便可以完成代理的实现。然后其利用反射生成代理类字节码，并生成对象</p>
<p>JDK 动态代理<strong>只能代理接口</strong>，因为<strong>代理类生成时<code>extends</code>了<code>Proxy</code><strong>，Java 中</strong>不允许多重继承</strong></p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>JDK 动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，我们仍然通过案例来学习</p>
<ul>
<li>编写一个调用逻辑处理器<code>LogHandler</code>类，提供日志增强功能，并<strong>实现<code>InvocationHandler</code>接口</strong></li>
<li>在<code>LogHandler</code>中维护一个目标对象，即被代理的 Real Subject</li>
<li>在<code>invoke</code>方法中编写方法调用的逻辑处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);  <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">// 日志记录</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">// 日志记录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写客户端，通过动态生成的代理类的对象须借助<code>Proxy</code>类的<code>newProxyInstance</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> proxy.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line">        <span class="comment">// System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span></span><br><span class="line">        <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">logHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogHandler</span>(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">        <span class="comment">// ProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-lang-reflect-InvocationHandler"><a href="#java-lang-reflect-InvocationHandler" class="headerlink" title="java.lang.reflect.InvocationHandler"></a>java.lang.reflect.InvocationHandler</h3><ul>
<li><strong><code>Object invoke(..)</code>：</strong>定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</li>
</ul>
<h3 id="java-lang-reflect-Proxy"><a href="#java-lang-reflect-Proxy" class="headerlink" title="java.lang.reflect.Proxy"></a>java.lang.reflect.Proxy</h3><ul>
<li><strong><code>static InvocationHandler getInvocationHandler(..)</code>：</strong>用于获取<strong>指定代理对象所关联的调用处理器</strong></li>
<li><strong><code>static Class&lt;?&gt; getProxyClass(..)</code>：</strong>返回指定接口的代理类</li>
<li><strong><code>static Object newProxyInstance(..)</code>：</strong>构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的<code>invoke</code>方法</li>
<li><strong><code>static boolean isProxyClass(Class&lt;?&gt; cl)</code>：</strong>返回 cl 是否为一个代理类</li>
</ul>
<h2 id="CGLIB-代理"><a href="#CGLIB-代理" class="headerlink" title="CGLIB 代理"></a>CGLIB 代理</h2><p><strong>CGLIB 采用了非常底层的字节码技术</strong>，其原理是通过字节码技术<strong>为一个类创建子类</strong>，并在子类中采用方法拦截的技术，<strong>拦截所有父类方法的调用</strong>。顺势织入横切逻辑，来完成动态代理的实现</p>
<p>CGLIB 创建动态代理类的模式是：</p>
<ol>
<li>查找目标类上的所有非 <code>final</code> 的 <code>public</code> 类型的方法定义</li>
<li>将这些方法的定义转换成字节码</li>
<li>将组成的字节码转换成相应的代理的 <code>Class</code> 对象</li>
<li>实现 <code>MethodInterceptor</code> 接口，用来处理对代理类上所有方法的请求</li>
</ol>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p>在 maven 中导入 CGLIB 包，然后编写一个 <code>UserDao</code> 类，只有两个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao 查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao 更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个 LogInterceptor ，继承了 <code>MethodInterceptor</code>，用于方法的拦截回调</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(object, objects);   <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DaoProxy</span> <span class="variable">daoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoProxy</span>(); </span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(Dao.class);  <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallback(daoProxy);</span><br><span class="line"></span><br><span class="line">        <span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> (Dao)enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        dao.update();</span><br><span class="line">        dao.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// log start time [Fri Dec 21 00:06:40 CST 2018] </span></span><br><span class="line"><span class="comment">// UserDao 查询 selectById</span></span><br><span class="line"><span class="comment">// log end time [Fri Dec 21 00:06:40 CST 2018] </span></span><br><span class="line"><span class="comment">// log start time [Fri Dec 21 00:06:40 CST 2018] </span></span><br><span class="line"><span class="comment">// UserDao 更新 update</span></span><br><span class="line"><span class="comment">// log end time [Fri Dec 21 00:06:40 CST 2018] </span></span><br></pre></td></tr></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>基于Java反射机制实现，只有<strong>实现了接口的业务类</strong>才能用这种办法生成代理对象</p>
<ul>
<li><strong>优点：</strong><ul>
<li><strong>最小化依赖关系</strong>，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 CGLIB 更加可靠</li>
<li><strong>平滑进行 JDK 版本升级</strong>，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用</li>
<li><strong>代码实现简单</strong></li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>基于接口设计实现的</strong>，如果没有接口会抛异常</li>
</ul>
</li>
</ul>
<h3 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h3><p>基于 <strong>ASM</strong> 机制实现，通过生成业务类的子类作为代理类</p>
<ul>
<li><strong>优点：</strong><ul>
<li><strong>无需实现接口</strong>，达到代理类无侵入</li>
<li>只操作我们关心的类，而不必为其他相关类增加工作量</li>
<li><strong>高性能</strong></li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>需要依赖 CGLIB 库，会增加项目复杂度</li>
<li><strong>技术实现相对难理解</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://juejin.cn/post/6844903744954433544?searchId=202404212203168E566927664DEAC79878">Java 动态代理详解 - 掘金 (juejin.cn)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 泛型</title>
    <url>/post/fb66a9a7/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>泛型可以用于<strong>类</strong>、<strong>接口</strong>和<strong>方法</strong></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型&lt;T&gt;尖括号内可以填任意非关键字的标识符 常见的如 T,E,K,V</span></span><br><span class="line"><span class="comment">// 实例化泛型类时 必须指定 T 的指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line">    T data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的指定类型必须为包装类型 即基本类型需要使用其包装类型作为泛型类型</span></span><br><span class="line">Test&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(); <span class="comment">// 类型指定后 后面的尖括号可以不写</span></span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现不指定类型泛型接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestImplM</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现指定类型泛型接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestImpl2</span> <span class="keyword">implements</span> <span class="title class_">Test</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">print(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h1 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h1><p>泛型在编译后会被抹去类型，如果用<strong>指定类型</strong>作为泛型的参数类型，会在编译后被抹去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">(List&lt;String&gt; list)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 无法重载 泛型擦除后两个 list 的类型是一样的</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 异常</title>
    <url>/post/aebdb6ff/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Java中的异常有一个顶级父类<code>Throwable</code>，其子类结构大致如下：</p>
<ul>
<li><strong><code>Exception</code>：</strong>程序自身可以处理的异常，可以通过<code>catch</code>捕获<ul>
<li><strong><code>Checked Exception</code>：</strong>受检查异常，必须处理</li>
<li><strong><code>Unchecked Exception</code>：</strong>不受检查异常，可以不处理</li>
</ul>
</li>
<li><strong><code>Error</code>：</strong>程序无法处理的错误，不建议通过<code>catch</code>捕获（可以捕获）。如 Java虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误（<code>OutOfMemoryError</code>）、类定义错误（<code>NoClassDefFoundError</code>）等。这些错误发生时，JVM一般会选择线程终止</li>
</ul>
<h2 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a><code>Throwable</code> 类常用方法</h2><ul>
<li><strong><code>String getMessage()</code>：</strong>返回异常发生时的<strong>简要描述</strong></li>
<li><strong><code>String toString()</code>：</strong>返回异常发生时的<strong>详细信息</strong></li>
<li><strong><code>String getLocalizedMessage()</code>：</strong>返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><strong><code>void printStackTrace()</code>：</strong>在控制台上打印 <code>Throwable</code> 对象封装的<strong>异常堆栈信息</strong></li>
</ul>
<h2 id="异常使用时要注意的地方"><a href="#异常使用时要注意的地方" class="headerlink" title="异常使用时要注意的地方"></a>异常使用时要注意的地方</h2><ul>
<li><strong>不要把异常定义为静态变量</strong>，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 <code>new</code> 一个异常对象抛出。</li>
</ul>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E5%BC%82%E5%B8%B8">Java基础常见面试题总结(下) | JavaGuide</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>928. 尽量减少恶意软件的传播 II</title>
    <url>/post/9d5e9698/</url>
    <content><![CDATA[<h1 id="928-尽量减少恶意软件的传播-II"><a href="#928-尽量减少恶意软件的传播-II" class="headerlink" title="928. 尽量减少恶意软件的传播 II"></a><a href="https://leetcode.cn/problems/minimize-malware-spread-ii/">928. 尽量减少恶意软件的传播 II</a></h1><h2 id="O-n-2-O-n-times-m"><a href="#O-n-2-O-n-times-m" class="headerlink" title="$O(n^2)+O(n\times{m})$"></a>$O(n^2)+O(n\times{m})$</h2><p>并查集</p>
<p>找出一个是桥的感染节点，并且<strong>拆除这座桥后</strong>，能增加的<strong>无感染节点的连通图</strong>的节点数最多的感染节点（若感染节点都不是桥，那就是924题的判断思路）</p>
<p>这题是看题解了，只能想到尽可能找出是桥的感染节点，对于如何计算拆桥后增加的无感染节点连通图的节点数毫无思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; par,nod;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==par[x])</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        par[x]=<span class="built_in">find</span>(par[x]);</span><br><span class="line">        <span class="keyword">return</span> par[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">pa</span><span class="params">(find(par[a]))</span>,<span class="title">pb</span><span class="params">(find(par[b]))</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(pa==pb)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        par[pb]=pa;</span><br><span class="line">        nod[pa]+=nod[pb];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMalwareSpread</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; gra, vector&lt;<span class="type">int</span>&gt;&amp; ini)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(gra.size())</span>,<span class="title">m</span><span class="params">(ini.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化连通节点数集和并查集</span></span><br><span class="line">        nod.<span class="built_in">resize</span>(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;par.<span class="built_in">push_back</span>(i++));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化感染节点集</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">afc</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;afc[ini[i++]]=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并查集合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(afc[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(afc[j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(gra[i][j])</span><br><span class="line">                    <span class="built_in">merge</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连通图所含感染节点数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 感染节点数是否存在于某连通集</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">ext</span>(m,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u,i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            u=ini[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p,v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(afc[v])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                p=<span class="built_in">find</span>(v);</span><br><span class="line">                <span class="keyword">if</span>(gra[u][v]&amp;&amp;!ext[i][p])</span><br><span class="line">                    ext[i][p]=<span class="number">1</span>,cnt[p]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选取感染节点</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">-1</span>)</span>,<span class="title">cur</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u,s,i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="number">0</span>;</span><br><span class="line">            u=ini[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;n;v++)</span><br><span class="line">                <span class="keyword">if</span>(ext[i][v]&amp;&amp;cnt[v]==<span class="number">1</span>)</span><br><span class="line">                    s+=nod[v];</span><br><span class="line">            <span class="keyword">if</span>(s&gt;cur||(s==cur&amp;&amp;u&lt;ans))</span><br><span class="line">                cur=s,ans=u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>924. 尽量减少恶意软件的传播</title>
    <url>/post/8772c4cb/</url>
    <content><![CDATA[<h1 id="924-尽量减少恶意软件的传播"><a href="#924-尽量减少恶意软件的传播" class="headerlink" title="924. 尽量减少恶意软件的传播"></a><a href="https://leetcode.cn/problems/minimize-malware-spread/">924. 尽量减少恶意软件的传播</a></h1><h2 id="O-n-2-O-n"><a href="#O-n-2-O-n" class="headerlink" title="$O(n^2)+O(n)$"></a>$O(n^2)+O(n)$</h2><p>并查集</p>
<p>在合并时把每个连通图的节点数也算出来，然后遍历感染节点，看<strong>哪个连通图只有一个感染节点并且节点数最多</strong>，那个唯一感染节点即为答案（若没有只含一个感染节点的连通图，则选取节点号最小的感染节点即可）</p>
<p>这题思路蛮简单的，就是在选感染节点的时候犯病了把<code>cnt</code>和<code>nod</code>看反了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; par,nod;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==par[x])</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        par[x]=<span class="built_in">find</span>(par[x]);</span><br><span class="line">        <span class="keyword">return</span> par[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">pa</span><span class="params">(find(par[a]))</span>,<span class="title">pb</span><span class="params">(find(par[b]))</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(pa==pb)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        par[pb]=pa;</span><br><span class="line">        nod[pa]+=nod[pb];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMalwareSpread</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; gra, vector&lt;<span class="type">int</span>&gt;&amp; ini)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(gra.size())</span>,<span class="title">m</span><span class="params">(ini.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化并查集和连通图节点数集</span></span><br><span class="line">        nod.<span class="built_in">resize</span>(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            par.<span class="built_in">push_back</span>(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 并查集合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">                <span class="keyword">if</span>(gra[i][j])</span><br><span class="line">                    <span class="built_in">merge</span>(i,j);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算每个连通图的感染节点数</span></span><br><span class="line">        <span class="built_in">sort</span>(ini.<span class="built_in">begin</span>(),ini.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            cnt[<span class="built_in">find</span>(ini[i])]++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选取感染节点</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p,i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p=<span class="built_in">find</span>(ini[i]);</span><br><span class="line">            <span class="keyword">if</span>(cnt[p]==<span class="number">1</span>&amp;&amp;(ans==<span class="number">-1</span>||nod[p]&gt;nod[<span class="built_in">find</span>(ans)]))</span><br><span class="line">                ans=ini[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ans==<span class="number">-1</span>?ini[<span class="number">0</span>]:ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL - 索引</title>
    <url>/post/2dade9db/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="主键索引（聚簇索引）"><a href="#主键索引（聚簇索引）" class="headerlink" title="主键索引（聚簇索引）"></a>主键索引（聚簇索引）</h2><p>存储的是表中一整行的数据</p>
<h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>存储的是该行的[聚簇索引](# 聚簇索引和非聚簇索引)，若需要返回整行数据需根据聚簇索引再<strong>回表</strong>检索一次</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>设置多个字段的索引，但命中索引需要满足<strong>最左匹配原则</strong>，如（a，b，c）联合索引，查询条件中包含 <strong>a</strong> 才会命中（命中索引的长度要看<strong>最左连续匹配了几个字段</strong>，如 ac 命中 a、abc 命中 abc）</p>
<p><strong>当查询时对联合索引字段有以下操作，也会出现索引失效</strong></p>
<ul>
<li><strong>隐式类型转换：</strong>如 <code>int =&gt; varchar</code>（<code>varchar =&gt; int</code> 是不会失效的）</li>
<li><strong>不分类型不等号匹配：</strong>如 <code>where a &lt;&gt; &#39;a&#39;</code>（<code>varchar,char,tinyint,</code>）</li>
<li><strong>非前缀的字符串模糊查询：</strong>如 <code>where a like &#39;%test%&#39;</code></li>
<li><strong>函数或表达式操作：</strong>如 <code>where a+1=2 | where floor(a)=1</code>（只有<strong>用在字段上的函数或表达式</strong>才会失效，<code>where a=1+2 | where a=floor(1.1)</code> 这种是会命中索引的）</li>
</ul>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>聚簇索引<strong>每张表只能有一个</strong>。聚簇索引是指数据存储和索引放在了一起，索引的叶子节点保存了<strong>整行数据</strong></p>
<p><strong>聚簇索引选取规则：</strong></p>
<ul>
<li>若存在主键，则<strong>主键索引</strong>就是聚簇索引</li>
<li>若不存在主键，则使用<strong>第一个唯一索引</strong>（UNIQUE）作为聚簇索引</li>
<li>若都不存在，则InnoDB会**自动生成一个<code>rowid</code>**作为隐藏的聚簇索引</li>
</ul>
<h2 id="覆盖索引和非覆盖索引"><a href="#覆盖索引和非覆盖索引" class="headerlink" title="覆盖索引和非覆盖索引"></a>覆盖索引和非覆盖索引</h2><ul>
<li><strong>覆盖索引：</strong>使用索引检索到的数据覆盖了<strong>查询所需字段</strong></li>
<li><strong>非覆盖索引：</strong>使用索引检索后还需要回表查询整行数据才能覆盖<strong>查询所需字段</strong></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL - 存储引擎</title>
    <url>/post/98eaaa29/</url>
    <content><![CDATA[<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>存储引擎位于<strong>MySQL体系架构的第三层</strong>，其主要负责的是对数据的创建、查询、更新和删除操作</p>
<p>不同的存储引擎可以提供不同的<strong>存储机制</strong>、<strong>索引技巧</strong>、<strong>锁定水平</strong>等功能，使用不同的存储引擎还可以获得特定的功能</p>
<p>在MySQL中，可以利用<code>show engines</code>显示<strong>可用的数据库引擎和默认引擎</strong></p>
<table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">MyISAM</th>
<th align="center">BDB</th>
<th align="center">Memory</th>
<th align="center">InnoDB</th>
<th align="center">Archive</th>
<th align="center">NDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内存限制</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">√</td>
<td align="center">64TB</td>
<td align="center">X</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">事务支持</td>
<td align="center">表锁</td>
<td align="center">页锁</td>
<td align="center">表锁</td>
<td align="center">行锁</td>
<td align="center">行锁</td>
<td align="center">行锁</td>
</tr>
<tr>
<td align="center">MVCC</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Geospatial 支持</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">B树索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Hash索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">集群索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">数据缓存</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">索引缓存</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">压缩数据</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">加密数据</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">存储成本</td>
<td align="center">low</td>
<td align="center">low</td>
<td align="center">N&#x2F;A</td>
<td align="center">high</td>
<td align="center">very low</td>
<td align="center">low</td>
</tr>
<tr>
<td align="center">内存成本</td>
<td align="center">low</td>
<td align="center">low</td>
<td align="center">Medium</td>
<td align="center">high</td>
<td align="center">low</td>
<td align="center">high</td>
</tr>
<tr>
<td align="center">大部分插入速度</td>
<td align="center">high</td>
<td align="center">high</td>
<td align="center">high</td>
<td align="center">low</td>
<td align="center">very high</td>
<td align="center">high</td>
</tr>
<tr>
<td align="center">集群数据库支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">复制支持</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">外键支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">备份恢复</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">查询缓存支持</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">更新数据字典的统计顺序</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://developer.aliyun.com/article/1287657">什么是存储引擎-阿里云开发者社区 (aliyun.com)</a></li>
<li><a href="https://blog.csdn.net/m0_46761060/article/details/124252411">MySQL各引擎之间的比较-CSDN博客</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层模型 - 数据链路层</title>
    <url>/post/ab9bc0f6/</url>
    <content><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="成帧（Framing）"><a href="#成帧（Framing）" class="headerlink" title="成帧（Framing）"></a>成帧（Framing）</h2><p>将比特流划分成”帧”的主要目的是为了<strong>检测和纠正物理层在比特传输中可能出现的错误</strong>，数据链路层功能需借助”帧”的各个域来实现</p>
<h3 id="字节计数法（Byte-count）"><a href="#字节计数法（Byte-count）" class="headerlink" title="字节计数法（Byte count）"></a>字节计数法（Byte count）</h3><p>每帧的第一个字节表示<strong>该帧的总字节数</strong></p>
<p>如：<strong>5</strong>1234<strong>5</strong>1234<strong>8</strong>1234567<strong>6</strong>12345</p>
<h3 id="带字节填充的定界符法（Flag-bytes-with-byte-stuffing）"><a href="#带字节填充的定界符法（Flag-bytes-with-byte-stuffing）" class="headerlink" title="带字节填充的定界符法（Flag bytes with byte stuffing）"></a>带字节填充的定界符法（Flag bytes with byte stuffing）</h3><p>每帧包含<strong>头标+有效载荷+尾标</strong>，帧与帧之间<strong>用定界符相隔</strong></p>
<p>使用两种特殊的字节分别作为<strong>定界符FLAG</strong>和<strong>转义符ESC</strong>，如 01111110（0x7E）</p>
<ul>
<li><strong>FLAG：</strong>用于区分前后两个不同的帧</li>
<li><strong>ESC：</strong>用于将后一个字节转义为有效数据（防止有效载荷中出现FLAG或ESC）<ul>
<li><strong>ESC+ESC和ESC+FLAG</strong>分别表示<strong>ESC和FLAG字节所代表的数据</strong></li>
</ul>
</li>
</ul>
<h3 id="带比特填充的定界符法（Flag-bits-with-bit-stuffing）"><a href="#带比特填充的定界符法（Flag-bits-with-bit-stuffing）" class="headerlink" title="带比特填充的定界符法（Flag bits with bit stuffing）"></a>带比特填充的定界符法（Flag bits with bit stuffing）</h3><p>和上面的方法类似，不过将 01111110 作为了固定的定界符，并且去除了转义符</p>
<p><strong>发送方检查有效载荷：</strong></p>
<ul>
<li>若出现<strong>连续5个1比特</strong>，则在其后面插入<strong>1个0比特</strong></li>
</ul>
<p><strong>接收方处理有效载荷：</strong></p>
<ul>
<li>若出现<strong>连续5个1比特</strong><ul>
<li>若<strong>下一比特为1</strong>，则<strong>连同下下一位比特的0构成定界符</strong>，结束一帧</li>
<li>若<strong>下一比特为0</strong>，则为有效载荷，<strong>丢弃下一比特</strong></li>
</ul>
</li>
</ul>
<h3 id="物理层编码违例（Physical-layer-coding-violations）"><a href="#物理层编码违例（Physical-layer-coding-violations）" class="headerlink" title="物理层编码违例（Physical layer coding violations）"></a>物理层编码违例（Physical layer coding violations）</h3><p>这种方法依然是使用</p>
<h2 id="差错控制（Error-Control）"><a href="#差错控制（Error-Control）" class="headerlink" title="差错控制（Error Control）"></a>差错控制（Error Control）</h2><p>处理传输中的出现的差错，如<strong>位错误</strong>、<strong>丢失</strong>等</p>
<p>利用检纠错码进行差错控制的常用方式有三种：</p>
<ul>
<li><strong>自动请求重发（ARQ）</strong><ul>
<li>发送端发送出<strong>可以发现错误的码字</strong></li>
<li>接收端解码，若检测到错误，则主动向发送端发出请求，要求重发以便纠错</li>
<li><strong>特点和应用场景：</strong>要求有反馈信道，且发送端和接收端都有缓存器</li>
</ul>
</li>
<li><strong>前向纠错（FEC）</strong><ul>
<li>发送端发送<strong>具有一定纠错能力的码字</strong></li>
<li>接收端解码后不仅可以发现错码，还可以<strong>判断错码所在位置并自动纠正</strong></li>
<li><strong>特点和应用场景：</strong>不需要反馈信道，实时性好，传输效率较高，但纠错编码方法和设备较复杂</li>
</ul>
</li>
<li><strong>混合纠错（HEC）</strong><ul>
<li>结合使用 ARQ 和 FEC 方法</li>
<li><strong>在传输错码较少且接收端能纠正时</strong>，自动纠正错误</li>
<li><strong>在错码较多、超出纠正能力但可以检测时</strong>，采用自动请求重发方式，请求发送端重传，直到正确接收为止</li>
</ul>
</li>
</ul>
<h3 id="检错"><a href="#检错" class="headerlink" title="检错"></a>检错</h3><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>通过<strong>增加冗余位使码字中 1 的个数保持奇数或偶数</strong>，在校验时使用<strong>水平或垂直奇偶校验</strong>来检测每行每列奇偶性是否一致</p>
<p>其细分可以分为以下几种方式：</p>
<ul>
<li><strong>垂直奇偶校验</strong></li>
<li><strong>水平奇偶校验</strong></li>
<li><strong>水平垂直奇偶校验</strong></li>
</ul>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li><strong>编码简单：</strong>只需要添加<strong>冗余位</strong>即可实现</li>
<li><strong>实现容易：</strong>只需判断 1 的数量即可，即使是需要再划分数据的<strong>水平奇偶校验</strong>，相对于其他校验方式也更容易</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li><strong>漏检率高：</strong>单独使用水平或垂直的漏检率约为 $\frac12$（偶数个变化就无法检测出来），使用<strong>水平垂直奇偶校验</strong>的话，漏检率可以大大降低</li>
<li><strong>无纠错能力：</strong>只能检测是否存在错误，并不能定位到错误的位置</li>
</ul>
<h4 id="循环冗余校验（CRC）"><a href="#循环冗余校验（CRC）" class="headerlink" title="循环冗余校验（CRC）"></a>循环冗余校验（CRC）</h4><p><strong>其校验码称为循环码（多项式码）</strong>，是一种线性分组码。它是<strong>在严格的代数学理论基础上建立起来的</strong>，检纠错能力非常强，且广泛应用在计算机网络和数据通信中</p>
<p>循环码除了具有线性分组码的一般性之外，还有一个显著的特点就是<strong>循环性</strong>，即循环码中<strong>任一码字循环左右移一位或多位</strong>形成的码字依旧是循环码中的码字</p>
<h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><blockquote>
<p>给定一个长度为 $n$ 的二进制串 $B_n&#x3D;b_{n-1}b_{n-2}…b_1b_0,(b&#x3D;0,1)$</p>
<p><strong>则可以将其表示为多项式 $B(x)&#x3D;b_{n-1}x^{n-1}+b_{n-2}x^{n-2}+…+b_1x+b_0$</strong></p>
</blockquote>
<p>我们给定一个<strong>生成 $k$ 阶多项式</strong> $G(x)$，<strong>二进制串数据</strong> $F(x)$，进行以下操作：</p>
<ul>
<li>将 $F(x)$ <strong>左移 $k-1$ 位</strong>，即 $F’(x)&#x3D;F(x)\times x^{k-1}$</li>
<li>用模 2 算法求得 $F’(x)&#x2F;G(x)$ 的余数 $R(x)$，并将余数 $R(x)$ 追加到 $F(x)$ 尾部，得到最终要发送的数据 $F’’(x)$</li>
</ul>
<p>然后由发送端将 $G(x),F’’(x)$ 发送给接收端</p>
<h5 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h5><p>接收端接收到数据后，只需用模 2 算法计算 $F’’(x)&#x2F;G(x)$，判断计算后的余数是否为 0（能否被整除），如果为 0，则说明<strong>传输过程中没有出错</strong></p>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>将发送的数据看成是二进制整数序列，并划分一段段规定的长度（如8、16、32位等）；然后<strong>计算它们的和</strong>，如计算时有进位，则<strong>将进位加到计算出的和中</strong>，计算完毕后，<strong>将计算的和取反</strong>作为校验和，与数据一并发送给接收端</p>
<p>在接收端，重新计算校验和，并于接收到的原校验和进行比较</p>
<h3 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h3><h4 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h4><p>在 $m$ 位数据之中添加 $r$ 个冗余位，此时数据传输的总位数为 $m+r$，且要求 $r$ 必须<strong>能够至少表示 $m+r+1$ 种状态</strong>（1 种状态表示无差错，$m+r$ 种状态分别表示数据第 $i,(0&lt; i\le m+r)$ 位出错）</p>
<p>因为 $r$ 位二进制数可以表示 $2^r$ 种不同的状态，所以有： $2^r\ge m+r+1$</p>
<h5 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h5><p>在 $m+r$ 位数据中，各冗余位处于第 $2^i,(0\le i&lt;r)$ 位，分别用 $r_1,r_2,…,r_r$ 表示；而后 $m$ 位数据<strong>从低位到高位按序填充到剩余位置</strong></p>
<p>因为冗余位 $r_rr_{r-1}…r_1$ 组成的二进制数就代表出错位的位置，所以对于第 $r_i$ 而言，它应该与<strong>位置序号代表的二进制串中第 $i-1$ 位为 1 的位置有关</strong></p>
<blockquote>
<p>很容易理解，当第 $k$ 位出错时，<strong>冗余位组成的二进制数</strong>应该等于 $k$</p>
<p>即 $2^0\times r_1+2^1\times r_2+…+2^{r-1}\times r_r&#x3D;k$，说明第 $k$ 位和其二进制串中为 1 的每一位都有关；相对地，$r_i$ 也就和每个第 $i-1$ 位为 1 的位置有关</p>
</blockquote>
<p>于是，就可以采用奇偶校验来求出所有与 $r_i$ 有关的数据位的校验位，将其作为 $r_i$</p>
<h5 id="解码-1"><a href="#解码-1" class="headerlink" title="解码"></a>解码</h5><p>解码时，对 $n$ 位数据中的第  $2^i,(0&lt;2^i\le n)$ 位进行奇偶校验，并将结果合并为二进制数 $x$，如果 $x$ 不为 0，则说明有数据位出错，第 $x$ 位即为出错位</p>
<h4 id="二进制卷积码"><a href="#二进制卷积码" class="headerlink" title="二进制卷积码"></a>二进制卷积码</h4><h4 id="里德所罗门码"><a href="#里德所罗门码" class="headerlink" title="里德所罗门码"></a>里德所罗门码</h4><h4 id="低密度奇偶校验吗"><a href="#低密度奇偶校验吗" class="headerlink" title="低密度奇偶校验吗"></a>低密度奇偶校验吗</h4><h2 id="流量控制（Flow-Control）"><a href="#流量控制（Flow-Control）" class="headerlink" title="流量控制（Flow Control）"></a>流量控制（Flow Control）</h2><p><strong>确保发送方的发送速率</strong>，不大于接收方的处理速率</p>
<ul>
<li>避免接收缓冲区溢出</li>
</ul>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="回退N帧"><a href="#回退N帧" class="headerlink" title="回退N帧"></a>回退N帧</h4><p>接收方没有接收到某一帧时，自动丢弃接下来接收到的所有帧，直到接收到需要的帧</p>
<h4 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h4><p>接收方没有接收到某一帧时，继续对接下来接收到的帧进行确认。由发送方对未确认的帧进行重传</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络模型</title>
    <url>/post/4f117b1f/</url>
    <content><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>应用层负责处理特定的应用程序之间的通信</strong>。它提供了各种网络服务，如电子邮件、文件传输、Web浏览等</p>
<p>应用层协议定义了应用程序之间通信的规范和格式，使得不同的应用程序能够相互通信和交换数据</p>
<p><strong>常见的应用层协议包括：</strong></p>
<ul>
<li><strong>HTTP（HyperText Transfer Protocol）</strong></li>
<li><strong>FTP（File Transfer Protocol）</strong></li>
<li><strong>SMTP（Simple Mail Transfer Protocol）</strong></li>
<li><strong>DNS（Domain Name System）</strong></li>
<li><strong>P2P（Peer to Peer）</strong></li>
</ul>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p><strong>表示层负责对数据进行加密、压缩和转换等操作</strong>。以确保数据能够在不同的系统和应用程序之间正确地进行交换</p>
<p>它还负责数据的编码和格式转换，以便在不同的网络环境中进行传输</p>
<p><strong>常见的表示层协议包括：</strong></p>
<ul>
<li><strong>MIME（Multipurpose Internet Mail Extensions）</strong></li>
<li><strong>TLS（Transfer Layer Security）</strong></li>
</ul>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p><strong>会话层负责建立、管理和终止会话</strong>。它协调不同应用程序之间的通信，确保他们能够同步地发送和接收数据</p>
<p>会话层还负责处理会话中的错误和异常情况，以确保通信的可靠性</p>
<p><strong>常见的会话层协议包括：</strong></p>
<ul>
<li><p><strong>RPC（Remote Procedure Call）</strong></p>
</li>
<li><p><strong>SQL（Structured Query Language）</strong></p>
</li>
</ul>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><strong>传输层负责提供端到端的可靠数据传输服务</strong>。它通过将数据分割成更小的段（称为段或数据包），并在接收端重新组合这些数据段，来确保<strong>数据的完整性和顺序性</strong></p>
<p>传输层还负责流量控制和拥塞控制，以防止网络拥塞和丢失数据包</p>
<p><strong>常见的传输层协议包括：</strong></p>
<ul>
<li><p><strong>TCP（Transmission Control Protocol）</strong></p>
</li>
<li><p><strong>UDP（User Datagram Protocol）</strong></p>
</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><strong>网络层负责将数据包从原地址路由到目的地址</strong>。它处理网络之间的通信，确保数据包能够正确地跨越多个网络段</p>
<p>网络层使用逻辑地址来表示设备，并通过路由算法选择最佳路径</p>
<p><strong>常见的网络层协议包括：</strong></p>
<ul>
<li><p><strong>IP（Internet Protocol）</strong></p>
</li>
<li><p><strong>ICMP（Internet Control Message Protocol）</strong></p>
</li>
<li><p><strong>IGMP（Internet Group Management Protocol）</strong></p>
</li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><strong>数据链路层负责将数据分成帧</strong>，并在帧的头部和尾部添加控制信息，以便在物理层上进行传输。它还负责处理错误检测和流量控制等问题</p>
<p>数据链路层的一个关键功能是提供介质访问控制（MAC）地址，用于在局域网中唯一标识设备</p>
<p><strong>常见的数据链路层协议包括</strong></p>
<ul>
<li><p><strong>以太网协议</strong></p>
</li>
<li><p><strong>PPP（Point to Point Protocol）</strong></p>
</li>
<li><p><strong>ARP（Address Resolution Protocol）</strong></p>
</li>
</ul>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p><strong>物理层负责传输原始的比特流</strong>。它定义了电气、机械和功能性规范，确保比特流在传输介质上能够准确无误地传输</p>
<p>物理层不涉及数据的编码或解码，只关注如何将数据转换为可以在传输介质上传输的信号</p>
<p><strong>常用的物理层协议包括</strong></p>
<ul>
<li><p><strong>Ethernet</strong></p>
</li>
<li><p><strong>RS-232</strong></p>
</li>
<li><p><strong>光纤通信</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/post/0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>RabbitMQ - 重复消费</title>
    <url>/post/7e5bb3c3/</url>
    <content><![CDATA[<h1 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h1><h2 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h2><p>给每条消息设置一个唯一的标识ID</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>消息队列</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/post/fec99276/</url>
    <content><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p><strong>消息队列（Message Queue）</strong>可以看作一个存放信息的容器，当我们需要使用信息时，直接从容器中取出信息供自己使用即可。由于队列是一个FIFO的数据结构，所以消息的消费也是按照顺序来的</p>
<p>参与消息传递的双方被称为<strong>生产者</strong>和<strong>消费者</strong>，生产者负责发送信息，消费者负责处理信息</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="异步提高系统性能"><a href="#异步提高系统性能" class="headerlink" title="异步提高系统性能"></a>异步提高系统性能</h3><p>将用户的<strong>请求数据存储到消息队列</strong>之后就<strong>立即返回结果</strong>，然后系统再对消息进行处理</p>
<p>由于业务的实际处理过程并没有执行完毕，所以在返回结果时并不能直接提示成功，需要<strong>适当修改业务流程来配合</strong></p>
<h3 id="削峰-限流"><a href="#削峰-限流" class="headerlink" title="削峰&#x2F;限流"></a>削峰&#x2F;限流</h3><p><strong>将短时间内高并发的事务消息存储在消息队列中</strong>，再由服务<strong>根据自己的处理能力来消费这些消息</strong>，避免流量过大将服务压垮（类似漏桶的思想）</p>
<h3 id="降低系统耦合性"><a href="#降低系统耦合性" class="headerlink" title="降低系统耦合性"></a>降低系统耦合性</h3><p>在系统中可能有模块与模块之间的复杂的调用关系，使用 MQ <strong>将调用方和被调用方分离开</strong>，调用方只需关注发送消息，被调用方只需关注处理消息，降低了整体系统的耦合性</p>
<h2 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h2><ul>
<li><strong>系统可用性降低：</strong>在引入MQ后，不仅需要考虑各<strong>服务的可用性</strong>还需要考虑<strong>MQ的可用性</strong></li>
<li><strong>系统复杂性提高：</strong>在加入MQ之后，需要保证消息重复消费、消息丢失等情况</li>
<li><strong>一致性问题：</strong>发送的消息是否有被消费者正确消费，可能会导致数据不一致的情况</li>
</ul>
<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>JMS（<strong>J</strong>ava <strong>M</strong>essage <strong>S</strong>ervice，Java消息服务），JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。<strong>JMSAPI 是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性</p>
<p>JMS 定义了五种不同的消息正文格式以及调用的消息类型，允许你发送并接收不同形式的数据：</p>
<ul>
<li><strong><code>StreamMessage</code>：</strong>Java原始值的数据流</li>
<li><strong><code>MapMessage</code>：</strong>一套键值对</li>
<li><strong><code>TextMessage</code>：</strong>一个字符串对象</li>
<li><strong><code>ObjectMessage</code>：</strong>一个序列化的 Java 对象</li>
<li><strong><code>BytesMessage</code>：</strong>一个字节的数据流</li>
</ul>
<p>ActiveMQ（已被淘汰）就是基于 JMS 规范实现的</p>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p><strong>AMQP</strong>（<strong>A</strong>dvanced <strong>M</strong>essage <strong>Q</strong>ueuing <strong>P</strong>rotocol，<strong>高级消息队列协议</strong>），在 2003 年时被提出，最早用于解决金融领域不同平台之间的信息传递交互问题</p>
<p>AMQP 是一个提供统一信息服务的<strong>应用层标准</strong>高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件传递信息，<strong>不受客户端&#x2F;中间件产品、不同开发语言等条件的限制</strong></p>
<h3 id="重要角色"><a href="#重要角色" class="headerlink" title="重要角色"></a>重要角色</h3><ul>
<li><strong>消息（Message）：</strong>即客户端与消息中间件传送的数据</li>
<li><strong>生产者（Producer）：</strong>消息的生产者</li>
<li><strong>消费者（Consumer）：</strong>消息的消费者</li>
<li><strong>连接（Connection）：</strong>一个网络连接，比如 TCP&#x2F;IP 连接<ul>
<li>AMQP 连接通常是长连接，当一个应用不再需要连接到 AMQP 代理时，需要释放掉 AMQP 连接，而不是直接将 TCP 连接关闭</li>
</ul>
</li>
<li><strong>信道（Channel）：</strong>网络信道，是简历在 Connection 连接之上的一种轻量级的连接，可以创建多个信道</li>
<li><strong>交换机（Exchange）：</strong>接收信息，并将消息路由转发给消息队列</li>
<li><strong>虚拟主机（Virtual Host）：</strong>进行逻辑隔离，一个虚拟主机可以创建若干个交换机和队列</li>
<li><strong>绑定（Binding）：</strong>交换机和队列之间的虚拟连接</li>
<li><strong>路由键（Routing Key）：</strong>路由规则，虚拟机可以用来确定如何路由一个特定的消息</li>
<li><strong>队列（Queue）：</strong>存储即将被消费者消费的消息</li>
<li><strong>中间件（Broker）：</strong>实现 AMQP 实体服务，比如常见的 RabbitMQ、Azure Service Bus 等</li>
</ul>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://javaguide.cn/high-performance/message-queue/message-queue.html#amqp-%E6%98%AF%E4%BB%80%E4%B9%88">消息队列基础知识总结 | JavaGuide</a></li>
<li><a href="https://www.zhihu.com/question/34114405/answer/2739551205">amqp 这个协议好像很少人提及，与mqtt的区别在哪？ - 知乎 (zhihu.com)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ - 消息丢失</title>
    <url>/post/a28d5268/</url>
    <content><![CDATA[<h1 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h1><ul>
<li><strong>生产者发送的消息未到达交换机</strong></li>
<li><strong>交换机中的消息未到达队列</strong></li>
<li><strong>队列中的消息丢失</strong></li>
</ul>
<h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><p>RabbitMQ提供了<strong>publisher confirm机制</strong>来避免消息发送到MQ过程中丢失。消息发送到MQ后，会返回一个结果给发送者，表示消息是否处理成功</p>
<p>如果消息发送失败，有以下集中处理方式：</p>
<ul>
<li>回调方法即时重发</li>
<li>记录日志</li>
<li>保存到数据库然后定时重发，发送成功后即刻删除表中的数据</li>
</ul>
<h2 id="消费者确认"><a href="#消费者确认" class="headerlink" title="消费者确认"></a>消费者确认</h2><p>RabbitMQ支持消费者确认机制，即消费者处理信息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该信息，SpringAMQP 允许配置三种确认模式：</p>
<ul>
<li><strong>manual：手动 ack</strong>，需要在业务代码结束后，调用API发送ack</li>
<li><strong>auto：自动 ack</strong>，由 Spring 检测 listener 代码是否出现异常，若没有异常则返回 ack；否则返回 nack</li>
<li><strong>none：关闭 ack</strong>，MQ假定消费者获取信息后一定会成功，所以在消息投递后立即删除</li>
</ul>
<p>可以利用 Spring 的 retry 机制，在消费者出现异常时利用本地重试，设置重试次数</p>
<p>当次数达到了以后，如果消息依然失败，<strong>将消息投递到异常交换机</strong>，交由人工处理</p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>MQ默认是内存存储消息，开启持久化功能可以确保<strong>缓存在MQ中的消息不丢失</strong></p>
<ul>
<li><strong>交换机持久化</strong></li>
<li><strong>队列持久化</strong></li>
<li><strong>消息持久化</strong>，SpringAMQP 中的消息默认是持久的，可以通过 <code>MessageProperties</code> 中的 <code>DeliveryMode</code> 来指定</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>消息队列</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>100279. 访问消失节点的最少时间</title>
    <url>/post/3740e621/</url>
    <content><![CDATA[<h1 id="100279-访问消失节点的最少时间"><a href="#100279-访问消失节点的最少时间" class="headerlink" title="100279. 访问消失节点的最少时间"></a><a href="https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/">100279. 访问消失节点的最少时间</a></h1><h2 id="O-n-m-log-2m-O-n-m"><a href="#O-n-m-log-2m-O-n-m" class="headerlink" title="$O(n+{m}log_2m)+O(n+m)$"></a>$O(n+{m}log_2m)+O(n+m)$</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que,tme;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; pat;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minimumTime</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edg, vector&lt;<span class="type">int</span>&gt;&amp; dis)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.<span class="built_in">resize</span>(n,<span class="number">-1</span>);</span><br><span class="line">        pat.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="comment">// 添加路径</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">m</span><span class="params">(edg.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edg[i][<span class="number">0</span>]==edg[i][<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            pat[edg[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(edg[i][<span class="number">1</span>]);</span><br><span class="line">            pat[edg[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(edg[i][<span class="number">2</span>]);</span><br><span class="line">            pat[edg[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(edg[i][<span class="number">0</span>]);</span><br><span class="line">            pat[edg[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(edg[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS遍历 Dijkstra算法</span></span><br><span class="line">        que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        tme.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p,x,l;!que.<span class="built_in">empty</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            p=que.<span class="built_in">front</span>();</span><br><span class="line">            x=tme.<span class="built_in">front</span>();</span><br><span class="line">            l=pat[p].<span class="built_in">size</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            tme.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(x&gt;ans[p])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t,i=<span class="number">0</span>;i&lt;l;i+=<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t=ans[p]+pat[p][i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(t&lt;dis[pat[p][i]]&amp;&amp;(ans[pat[p][i]]==<span class="number">-1</span>||t&lt;ans[pat[p][i]]))</span><br><span class="line">                &#123;</span><br><span class="line">                    ans[pat[p][i]]=t;</span><br><span class="line">                    que.<span class="built_in">push</span>(pat[p][i]);</span><br><span class="line">                    tme.<span class="built_in">push</span>(ans[p]+pat[p][i+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dijkstra</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统理论</title>
    <url>/post/85a207bf/</url>
    <content><![CDATA[<h1 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h1><p>在1998年，由加州大学的计算机科学家 Eric Brewer 提出，<strong>分布式系统允许有三个指标</strong>：</p>
<ul>
<li><strong>C</strong>onsistency（一致性）</li>
<li><strong>A</strong>vailability（可用性）</li>
<li><strong>P</strong>artition tolerance（分区容错性）</li>
</ul>
<p>Eric Brewer 说，分布式系统<strong>无法同时满足</strong>这三个指标。这个结论就叫做<strong>CAP定理</strong></p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>用户访问分布式系统的<strong>任意节点</strong>，得到的数据必须是<strong>一致的</strong></p>
<h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>用户访问分布式系统的<strong>任意健康节点</strong>，必须能得到响应，而不是<strong>超时或拒绝</strong></p>
<h2 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h2><ul>
<li><strong>分区：</strong>因为<strong>网络故障或其他原因</strong>导致分布式系统中的部分节点与其他节点<strong>失去连接</strong>，形成<strong>独立分区</strong></li>
<li><strong>容错：</strong>在集群出现分区时，整个系统也要<strong>持续对外提供服务</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>分布式系统节点之间肯定<strong>需要网络连接</strong>的，所以分区（P）是必然存在的</li>
<li>如果保证访问的高可用性（A），可以持续对外提供服务，但不能保证数据的强一致性 &#x3D;&gt; AP</li>
<li>如果保证访问的数据强一致性（C），那么就要放弃高可用性 &#x3D;&gt; CP</li>
</ul>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>BASE 理论是对 CAP 的一种解决思路，包含三个思想：</p>
<ul>
<li><strong><font color="red">B</font>asically <font color="red">A</font>vailable（基本可用）：</strong>分布式系统在出现故障时，允许损失部分可用性，即保证<strong>核心可用</strong></li>
<li><strong><font color="red">S</font>oft State（软状态）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态</li>
<li><strong><font color="red">E</font>ventually Consistent（最终一致性）：</strong>虽然无法实现强一致性，但是在软状态结束后，最终达到<strong>数据一致</strong></li>
</ul>
<p>解决分布式事务的思想和模型：</p>
<ul>
<li><strong>最终一致性思想：</strong>各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）</li>
<li><strong>强一致性思想：</strong>各分支事务分别执行完业务不要提交，等待彼此结果后，统一提交或回滚（CP）</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud - 网关</title>
    <url>/post/c5d14857/</url>
    <content><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><h3 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h3><blockquote>
<p>Nginx 限流就是使用漏桶算法</p>
</blockquote>
<p>桶中存储请求，以<strong>固定速率</strong>漏出请求，多余的请求则<strong>等待或抛弃</strong></p>
<h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><blockquote>
<p>Gateway 网关限流使用的是令牌桶算法</p>
</blockquote>
<p>桶中存储令牌，每个请求都需要申请令牌，<strong>申请到令牌</strong>的请求才能被处理，没有申请到的请求则<strong>等待或抛弃</strong></p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>漏桶<strong>速率恒定</strong>，而令牌桶的速率则根据当前流量而<strong>动态调节速率</strong></p>
<ul>
<li><p><strong>漏桶：</strong>如果突然来了大量请求，则会泡在桶里，然后仍然以固定速率处理请求</p>
</li>
<li><p><strong>令牌桶：</strong>如果桶中的令牌足够多，则在面对突发大流量情况时，令牌桶可以立即处理掉这些请求</p>
</li>
</ul>
<h2 id="限流配置"><a href="#限流配置" class="headerlink" title="限流配置"></a>限流配置</h2><p>在<code>yml</code>配置文件中的微服务路由设置，添加局部过滤器<code>RequestRateLimiter</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">filters:</span> </span><br><span class="line">  	<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span></span><br><span class="line">  	  <span class="attr">args:</span></span><br><span class="line">  	  	<span class="comment"># 使用 spel 从容器中获取对象</span></span><br><span class="line">  	  	<span class="attr">key-resolver:</span> <span class="string">&#x27;#&#123;@pathKeyResolver&#125;&#x27;</span></span><br><span class="line">  	  	<span class="comment"># 令牌桶每秒填装平均速率</span></span><br><span class="line">  	  	<span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">1</span></span><br><span class="line">  	  	<span class="comment"># 令牌桶的上限</span></span><br><span class="line">  	  	<span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>key-resolver</code>：定义限流对象（IP、路径、参数），需代码实现，使用<code>spel</code>表达式实现</li>
<li><code>replenishRate</code>：令牌桶每秒填充平均速率</li>
<li><code>burstCapacity</code>：令牌桶总容量</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud - 服务熔断</title>
    <url>/post/2cd4a446/</url>
    <content><![CDATA[<h1 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h1><h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><p>由于一个服务<strong>崩溃或异常</strong>导致调用这个服务的服务调用失败无法释放连接，从而引发的一系列连锁反应，可能导致整个服务链路都崩溃</p>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>服务降级是<strong>服务自我保护</strong>或<strong>保护下游服务</strong>的一种方式，用于确保服务不会受<strong>请求突增</strong>的影响而变得<strong>不可用</strong>，确保服务不会崩溃</p>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p>Hystrix 熔断机制，用于监控微服务调用的情况，默认是关闭的。如果需要开启需要再引导类上添加注解<code>@EnableCircultBreaker</code>，若检测到**10秒内请求的失败率超过50%**，就会触发熔断机制</p>
<p>熔断机制触发后，每隔5秒重新尝试请求微服务：</p>
<ul>
<li>若微服务不能响应，继续走熔断机制</li>
<li>若微服务能响应，则关闭熔断机制，恢复正常请求</li>
</ul>
<h3 id="熔断流程"><a href="#熔断流程" class="headerlink" title="熔断流程"></a>熔断流程</h3>]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud - 服务发现</title>
    <url>/post/bb0d09b9/</url>
    <content><![CDATA[<h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><h2 id="服务注册、发现和监控"><a href="#服务注册、发现和监控" class="headerlink" title="服务注册、发现和监控"></a>服务注册、发现和监控</h2><ul>
<li><strong>服务注册：</strong>服务提供者需要把自己的信息注册到<strong>注册中心</strong>，由其来保存这些信息，比如服务名称、IP、端口等等</li>
<li><strong>服务发现：</strong>消费者向<strong>注册中心</strong>拉取服务列表信息，若服务提供者有<strong>集群</strong>，则消费者会使用<strong>负载均衡</strong>算法选择其中一个调用<ul>
<li>Nacos在服务信息改变时会<strong>主动向消费者推送变更信息</strong></li>
</ul>
</li>
<li><strong>服务监控：注册中心</strong>使用心跳机制监控各服务的健康状态<ul>
<li><strong>在Eureka中</strong>，服务每隔<strong>30秒</strong>主动向Eureka发送心跳，若Eureka<strong>90秒</strong>没有收到某一服务的心跳，则将其在服务列表中剔除</li>
<li><strong>在Nacos中</strong>，临时实例才会主动向Nacos发送心跳，非临时实例则由Nacos主动询问其状态</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud - 组件</title>
    <url>/post/1d3b9f9f/</url>
    <content><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>SpringCloud主要包含<strong>五大组件</strong>：</p>
<ol>
<li><strong>服务发现：</strong>Eureka、Nacos、Zookeeper 等</li>
<li><strong>负载均衡：</strong>Ribbon</li>
<li><strong>远程调用：</strong>Feign</li>
<li><strong>服务熔断：</strong>Hystrix</li>
<li><strong>网关：</strong>Gateway</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud - 负载均衡</title>
    <url>/post/8fa33d6a/</url>
    <content><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡的主要目的是为了<strong>平衡多个服务器的压力</strong>，其大体流程就是通过一些策略来选择一台合适的服务器响应请求</p>
<p>以下的内容都是关于<strong>Ribbon</strong>的</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>服务消费者向Ribbon发起<strong>远程调用请求</strong></li>
<li>Ribbon向<strong>注册中心</strong>拉取<strong>目标服务</strong>的信息</li>
<li>Ribbon根据<strong>负载均衡策略</strong>选择目标服务的一台服务实例</li>
</ul>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><ul>
<li><strong><code>RoundRobinRule</code>：</strong>简单<strong>轮询</strong>服务列表来选择服务实例</li>
<li><strong><code>WeightedResponseTimeRule</code>：</strong>按照权重来选择服务实例，响应时间越短，权重越大</li>
<li><strong><code>RandomRule</code>：</strong>随机选择一个可用的服务器</li>
<li><strong><code>BestAvailableRule</code>：</strong>遍历服务列表，选择<strong>连接数最小</strong>的服务实例，若有多个相同最小连接数的服务实例，则调用<strong>轮询策略</strong>进行选取</li>
<li><strong><code>RetryRule</code>：</strong>按照轮询策略来获取服务，若服务</li>
<li><strong><code>AvailabilityFilteringRule</code>：</strong>先过滤掉非健康的服务实例，然后选择连接数较小的服务实例</li>
<li><strong><code>ZoneAvoidanceRule</code>：</strong>根据<strong>请求的IP地址</strong>来选择服务实例，同一IP地址的请求会被路由到同一个服务实例上，可以保证请求的一致性（<strong>Ribbon默认策略</strong>）</li>
</ul>
<h3 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h3><ol>
<li><p><strong>自定义注入Bean：</strong>全局生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置配置文件：</strong>局部生效</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xxx-service:</span></span><br><span class="line">	<span class="attr">ribbon:</span></span><br><span class="line">		<span class="attr">NFLoadBalanceRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 内存模型</title>
    <url>/post/6a9ca21b/</url>
    <content><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p><strong>Java的内存区域结构如下：</strong></p>
<ul>
<li><strong>运行时数据区域</strong><ul>
<li>线程共享区域<ul>
<li>堆<ul>
<li>字符串常量池</li>
</ul>
</li>
</ul>
</li>
<li>线程私有区域<ul>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>程序计数器</li>
</ul>
</li>
</ul>
</li>
<li><strong>本地内存</strong><ul>
<li>元空间<ul>
<li>运行时常量池</li>
</ul>
</li>
<li>直接内存</li>
</ul>
</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>是一块较小的内存空间，用来存储下一条执行的字节码的行号</p>
<blockquote>
<p>程序计数器是<strong>唯一一个不会出现<code>OutOfMemoryError</code>的内存区域</strong>，它的生命周期随着线程的创建而创建、死亡而死亡</p>
</blockquote>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><strong>生命周期与线程相同</strong></p>
<p>虚拟机栈由栈帧组成，方法调用时会压入对应栈帧；方法结束时会弹出对应栈帧</p>
<p><strong>栈帧由以下内容组成：</strong></p>
<ul>
<li><strong>局部变量表：</strong>主要存放了编译期可知的<strong>各种数据类型</strong>、<strong>对象引用</strong>（<code>reference</code>类型）</li>
<li><strong>操作数栈：</strong>主要作为<strong>方法调用的中转站</strong>使用，用于存放<strong>方法执行过程中产生的中间计算结果</strong>，<strong>计算过程中产生的临时变量</strong>也会放在操作数栈中</li>
<li><strong>动态链接：</strong>将<strong>符号引用</strong>转换为<strong>调用方法的直接引用</strong></li>
<li><strong>方法返回地址</strong></li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>和虚拟机栈的作用相似，区别是虚拟机栈<strong>面向Java方法</strong>，而本地方法栈<strong>面向虚拟机使用到的<code>native</code>方法</strong>（在 HotSpot 虚拟机中<strong>其与虚拟机栈合二为一</strong>）</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>堆内存的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存</strong>。是所有线程共享的一块内存区域，在虚拟机启动时创建</p>
<p>JDK1.7开始默认开启<strong>逃逸分析</strong>，即如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区是属于<strong>JVM 运行时数据区域</strong>的一块逻辑区域，是<strong>各个线程共享的内存区域</strong></p>
<p>当虚拟机要使用一个类时，它需要<strong>读取并解析<code>.class</code>文件获取相关信息</strong>，再将信息存入到方法区中。方法区会存储已被虚拟机加载的</p>
<ul>
<li><strong>类信息</strong></li>
<li><strong>字段信息</strong></li>
<li><strong>方法信息</strong></li>
<li><strong>常量</strong></li>
<li><strong>静态变量</strong></li>
<li><strong>即时编译器编译后的代码缓存</strong></li>
</ul>
<p>等数据</p>
<p><strong>永久代和元空间对于方法区的关系</strong>类似于<strong>接口与类的关系</strong>，即方法区是抽象的概念&#x2F;规范，而<strong>永久代和元空间则是对方法区的具体实现</strong></p>
<blockquote>
<p><strong>为什么要将永久代替换为元空间？</strong></p>
</blockquote>
<ol>
<li><strong>整个永久代有一个 JVM 本身设置的固定大小上限</strong>，无法进行调整（也就是<strong>受到 JVM 内存的限制</strong>），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li>
<li><strong>元空间里面存放的是类的元数据</strong>，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li>
<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li>
<li><strong>永久代会为 GC 带来不必要的复杂度</strong>，并且回收效率偏低。</li>
</ol>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p><code>.class</code>文件中包含的<strong>常量池表</strong>会在类加载后存放到方法区的运行时常量池中</p>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>是 JVM 为了提升性能和减少内存消耗<strong>针对字符串（String 类）专门开辟的一块区域</strong>，主要目的是为了避免字符串的重复创建</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>虚拟机遇到一条<code>new</code>指令时，首先将去检查这个指令的参数<strong>是否能在常量池中定位到这个类的符号引用</strong>，并且检查这个<strong>符号引用代表的类是否已经被加载、解析和初始化过</strong>（如果没有，那必须先执行相应的<strong>类加载过程</strong>）</p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>接下来虚拟机为新生对象分配内存，对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于<strong>把一块确定大小的内存从Java堆中划分出来</strong></p>
<h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><h5 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h5><ul>
<li><strong>适用场合：</strong>堆内存规整（没有内存碎片）</li>
<li><strong>原理：</strong>将用过的内存整合到一边，没用过的内存放到另一边，中间有个<strong>分界指针</strong>，将分界指针<strong>向没用过的内存方向移动对象内存大小的位置</strong>即可</li>
<li><strong>使用该分配方式的 GC 收集器：</strong><ul>
<li>Serial</li>
<li>ParNew</li>
</ul>
</li>
</ul>
<h5 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h5><ul>
<li><strong>适用场合：</strong>堆内存不规整</li>
<li><strong>原理：</strong>虚拟机会维护一个<strong>空闲列表</strong>，记录哪些内存块是可用的；分配时<strong>选择一块合适的内存块划分给对象实例</strong>，再更新列表即可</li>
<li><strong>使用该分配方式的 GC 收集器：</strong><ul>
<li>CMS</li>
</ul>
</li>
</ul>
<h4 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h4><p>通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS + 失败重试</strong></li>
<li><strong>TLAB：</strong>为每一个线程预先<strong>在 Eden 区分配一块内存</strong>，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>将<strong>分配到的除对象头外的内存空间</strong>初始化为零值，这一步保证了对象的实力字段在 Java 代码中可以<strong>不赋初始值就直接使用</strong>，程序能访问到这些字段的<strong>数据类型所对应的零值</strong></p>
<h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p><strong>虚拟机对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息</p>
<p><strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式</p>
<h3 id="执行-init-方法"><a href="#执行-init-方法" class="headerlink" title="执行 init 方法"></a>执行 init 方法</h3><p><strong>执行<code>&lt;init&gt;</code>方法</strong>，将对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://javaguide.cn/java/jvm/memory-area.html#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">Java内存区域详解（重点） | JavaGuide</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch - 倒排索引</title>
    <url>/post/5470a39c/</url>
    <content><![CDATA[<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p><strong>倒排索引</strong>主要针对于类似<strong>全文检索</strong>的业务场景，是一种使用<strong>词条</strong>来检索<strong>文档</strong>的索引结构，传统的正向索引一般是由<strong>不同的文档ID</strong>来检索<strong>文档</strong>，比如MySQL。而<strong>倒排索引</strong>使用<strong>每个词条对应一个列表</strong>（包含文档ID、词条出现频率等等）的结构</p>
<p>当需要检索<strong>包含某一关键词的文档</strong>时，使用这种结构可以快速地将所有包含该关键词的文档都罗列出来，还可以使用列表中的频率信息等来对文档进行<strong>相关性排序</strong>等等</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/post/0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>215. 数组中的第K个最大元素</title>
    <url>/post/18edd0aa/</url>
    <content><![CDATA[<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h1><h2 id="O-n-times-k"><a href="#O-n-times-k" class="headerlink" title="$O(n\times{k})$"></a>$O(n\times{k})$</h2><p>用一个长度为 $k$ 的<strong>单调队列</strong>来维护数组中的前 $k$ 个最大元素</p>
<p>每次向队列插入一个元素 $x$ 时，从队尾向队首遍历元素 $q$，如果 $x&gt;q$ 就把 $q$ 向后移动，直到遇到 $q&gt;x$ 的情况，这时就将 $x$ 插入到其后面</p>
<p>代码略，实现方式比较简单</p>
<h2 id="O-nlog-2n"><a href="#O-nlog-2n" class="headerlink" title="$O(nlog_2n)$"></a>$O(nlog_2n)$</h2><p>快排然后从队尾数第 $k$ 个数 <span class="github-emoji" alias="joy" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">&#x1f602;</span></p>
<h2 id="O-n"><a href="#O-n" class="headerlink" title="$O(n)$"></a>$O(n)$</h2><p><strong>快速选择</strong>，对于快排来说，我们每一次对当前区间排序完需要从<strong>左右指针交汇处</strong>分为两个子区间继续递归排序，但是因为我们只在乎后 $k$ 个数所在区间的排序，所以我们在递归时就可以<strong>只选择我们需要排序的区间</strong>来递归，这样可以减少排序次数，它的算法的时间代价期望是 $O(n)$，证明过程可以参考<em>《算法导论》9.2： 期望为线性的选择算法</em> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r)</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">piv</span><span class="params">(nums[(l+r)&gt;&gt;<span class="number">1</span>])</span>,<span class="title">i</span><span class="params">(l<span class="number">-1</span>)</span>,<span class="title">j</span><span class="params">(r+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[++i]&lt;piv);</span><br><span class="line">            <span class="keyword">while</span>(nums[--j]&gt;piv);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=j)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums,l,j,k);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums,j+<span class="number">1</span>,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>,n-k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>力扣</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - 数据结构</title>
    <url>/post/70dbe786/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="key-value键值对"><a href="#key-value键值对" class="headerlink" title="key-value键值对"></a>key-value键值对</h2><p>Redis使用<strong>哈希表</strong>来存储所有的键值对，哈希表则是一个<strong>桶数组</strong>，数组中的元素则称为<strong>哈希桶</strong></p>
<p>而哈希桶存放的是<strong>键值对数据的指针</strong><code>dictEntry*</code>，这样可以通过指针找到对应的<strong>键值对</strong>；而键值对中存储的也是<code>void *key</code>和<code>void *value</code>指针，指向<strong>键和值对应的对象</strong></p>
<h2 id="SDS（Simple-Dynamic-String）"><a href="#SDS（Simple-Dynamic-String）" class="headerlink" title="SDS（Simple Dynamic String）"></a>SDS（Simple Dynamic String）</h2><p>Redis使用C语言实现的，但其中的字符串类型并没有直接使用C语言中的**<code>char*</code>字符数组<strong>来实现，而是封装了一个</strong>名为 SDS 的结构体**来表示字符串</p>
<h3 id="SDS-结构设计"><a href="#SDS-结构设计" class="headerlink" title="SDS 结构设计"></a>SDS 结构设计</h3><p>SDS 的结构体中包含以下成员变量：</p>
<ul>
<li><strong><code>len</code>：记录了字符串长度</strong>，在获取字符串长度时直接返回这个变量即可，时间复杂度为 $O(1)$（C语言获取长度为$O(n)$）</li>
<li><strong><code>alloc</code>：分配给字符数组的空间大小</strong>，在修改字符串时，可以通过计算<code>alloc - len</code>来判断剩余空间大小是否能满足修改需求<ul>
<li>若<strong>不满足</strong>，则自动将 SDS 的空间扩展至满足需求的大小，再执行修改操作</li>
</ul>
</li>
<li><strong><code>flags</code>：用来表示不同类型的SDS</strong>，一共设计了 5 种类型：<code>sdshdr5</code>、<code>sdshdr8</code>、<code>sdshdr16</code>、<code>sdshdr32</code>和<code>sdshdr64</code></li>
<li><strong><code>buf[]</code>：保存实际数据的字符数组</strong>，不仅可以保存字符串，还可以保存二进制数据</li>
</ul>
<h3 id="SDS-扩容"><a href="#SDS-扩容" class="headerlink" title="SDS 扩容"></a>SDS 扩容</h3><ul>
<li>判断 SDS 扩容的<strong>所需长度</strong>是否小于 1 MB<ul>
<li>若<strong>小于</strong>，则扩容<strong>两倍所需长度</strong></li>
<li>若<strong>不小于</strong>，则扩容<strong>所需长度 + 1MB</strong></li>
</ul>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表节点结构设计"><a href="#链表节点结构设计" class="headerlink" title="链表节点结构设计"></a>链表节点结构设计</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<h3 id="链表结构设计"><a href="#链表结构设计" class="headerlink" title="链表结构设计"></a>链表结构设计</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表的最大特点是<strong>内存紧凑型</strong>的数据结构，占用一块连续的内存空间，不仅可以利用CPU缓存，而且会根据不同长度的数据，进行相应编码，可以节省内存开销</p>
<p><strong>压缩列表的缺陷：</strong></p>
<ul>
<li>不能保存过多元素，否则查询效率会降低</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，否则可能引发连锁更新问题</li>
</ul>
<h3 id="压缩列表结构设计"><a href="#压缩列表结构设计" class="headerlink" title="压缩列表结构设计"></a>压缩列表结构设计</h3><p><strong>列表头字段：</strong></p>
<ul>
<li><code>zlbytes</code>：记录整个压缩列表占用的内存字节数</li>
<li><code>zltail</code>：记录压缩列表<strong>尾部</strong>节点距离起始地址多少字节，即列表尾的偏移量</li>
<li><code>zllen</code>：记录压缩列表包含的节点数量</li>
</ul>
<p><strong>列表尾字段：</strong></p>
<ul>
<li><code>zlend</code>：列表尾的标记，固定值<code>0xff</code>，即255</li>
</ul>
<p><strong>列表节点字段：</strong></p>
<ul>
<li><code>prevlen</code>：记录了前一个节点的长度，目的是为了实现由后向前遍历</li>
<li><code>encoding</code>：记录了当前节点实际数据的<strong>类型和长度</strong>，类型主要有两种：字符串和整数</li>
<li><code>data</code>：记录当前节点的实际数据，类型和长度都由<code>encoding</code>决定</li>
</ul>
<p>当向压缩列表插入一个数据时，会根据数据类型、大小来分配不同大小的空间保存<code>prevlen</code>和<code>encoding</code>元素的信息</p>
<p><code>prevlen</code>&#x3D;上一个节点长度小于 254 字节 ? 1 字节 : 5 字节</p>
<table>
<thead>
<tr>
<th align="center">encoding编码</th>
<th align="center">encoding长度</th>
<th align="center">content类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>00 b(6)</code></td>
<td align="center">1 字节</td>
<td align="center">最大长度为 63 的字节数组</td>
</tr>
<tr>
<td align="center"><code>01 b(14)</code></td>
<td align="center">2 字节</td>
<td align="center">最大长度为 $2^{14}-1$ 的字节数组</td>
</tr>
<tr>
<td align="center"><code>10 — b(32)</code></td>
<td align="center">5 字节</td>
<td align="center">最大长度为 $2^{32}-1$ 的字节数组</td>
</tr>
<tr>
<td align="center"><code>11 00 0000</code></td>
<td align="center">1 字节</td>
<td align="center">$int16$ 整数</td>
</tr>
<tr>
<td align="center"><code>11 01 0000</code></td>
<td align="center">1 字节</td>
<td align="center">$int32$ 整数</td>
</tr>
<tr>
<td align="center"><code>11 10 0000</code></td>
<td align="center">1 字节</td>
<td align="center">$int64$ 整数</td>
</tr>
<tr>
<td align="center"><code>11 11 0000</code></td>
<td align="center">1 字节</td>
<td align="center">24 位整数</td>
</tr>
<tr>
<td align="center"><code>11 11 1110</code></td>
<td align="center">1 字节</td>
<td align="center">8 位整数</td>
</tr>
<tr>
<td align="center"><code>11 11 xxxx</code></td>
<td align="center">1 字节</td>
<td align="center">没有<code>content</code>字段<br /><code>xxxx</code>表示 0-12 的整数</td>
</tr>
</tbody></table>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>当列表<strong>新增</strong>或<strong>修改</strong>某个元素时，若空间不足，则列表占用的内存空间就需要<strong>重新分配</strong></p>
<p>当插入的元素较大时，可能导致后续元素的<code>prevlen</code>占用空间都发生变化，从而引起<strong>连锁更新</strong></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="哈希表结构设计"><a href="#哈希表结构设计" class="headerlink" title="哈希表结构设计"></a>哈希表结构设计</h3><p><strong>节点结构：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">//键值对中的键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//键值对中的值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p><strong>表结构：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;  </span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><blockquote>
<p>rehash 触发条件和 Java 的 HashMap 类似，都使用到了<strong>负载因子</strong></p>
<p>但 Redis 中时<strong>判断当前哈希表的负载因子</strong>来决定是否要进行 rehash 操作</p>
<ul>
<li><strong>负载因子 $\ge1$：</strong>并且 Redis 没有在执行<code>bgsave </code>命令或者<code>bgrewriteaof</code>命令，也就是<strong>没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作</strong></li>
<li><strong>负载因子 $\ge5$：</strong>此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会<strong>强制进行 rehash 操作</strong></li>
</ul>
</blockquote>
<p>当哈希表发生哈希冲突时，会将<strong>冲突节点连接到哈希桶的链表尾部</strong>。但当链表长度增加到一定程度就会触发 rehash 操作，<strong>对哈希表大小进行扩展</strong></p>
<p><strong>Redis 中存储了两个哈希表</strong>，在正常服务请求时，数据都会写入到<strong>哈希表 1</strong> 中，此时**哈希表 2 **未被分配空间</p>
<p><strong>rehash 操作的过程分为三步：</strong></p>
<ol>
<li>给「哈希表 2 」分配空间，<strong>一般是「哈希表 1 」大小的两倍</strong></li>
<li>将「哈希表 1 」的数据迁移到「哈希表 2 」中</li>
<li>迁移完成后，「哈希表 1 」的空间会被释放，并将「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备</li>
</ol>
<p>整个过程最耗时的步骤是第 2 步，其涉及到大量的数据拷贝，<strong>可能会对 Redis 造成阻塞</strong>，无法服务其他请求</p>
<h3 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h3><p>为了避免 rehash 在数据迁移过程中，因数据拷贝影响到 Redis 的性能，所以 Redis 采用了<strong>渐进式 rehash</strong>，将数据迁移工作分多次进行</p>
<p>渐进式 rehash 步骤如下：</p>
<ol>
<li>给「哈希表 2 」分配空间</li>
<li>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺便<strong>将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2 」上</strong></li>
<li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2 」，从而完成 rehash 操作</li>
</ol>
<p>在进行渐进式 rehash 过程中，哈希表元素的增删改查等操作，<strong>都会在这两个哈希表中进行</strong>（但<strong>哈希表 1</strong> 中不进行添加操作）</p>
<p>例如，查找一个 key 的值，会先在**哈希表 1 <strong>中查找，若没有找到，会继续到</strong>哈希表 2 **中查找</p>
<blockquote>
<p>新增一个 key-value 时，会被保存到<strong>哈希表 2 <strong>中，这样保证了</strong>哈希表 1</strong> 中的数据只会减少</p>
</blockquote>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p><strong>整数集合是 Set 对象的底层实现之一</strong>，当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集合数据结构作为底层实现</p>
<h3 id="整数集合结构设计"><a href="#整数集合结构设计" class="headerlink" title="整数集合结构设计"></a>整数集合结构设计</h3><p>整数集合本质上是一块<strong>连续内存空间</strong>，其结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>contents</code>数组虽然被声明为<code>int8_t</code>类型的数组，但是实际上<code>contents</code>数组并不保存任何<code>int8_t</code>类型的元素，<code>contents</code>数组的真正类型取决于<code>encoding</code>属性的值</p>
<h3 id="整数集合的升级操作"><a href="#整数集合的升级操作" class="headerlink" title="整数集合的升级操作"></a>整数集合的升级操作</h3><p>当添加一个新元素到整数集合中，如果<strong>新元素的类型比整数集合现有所有元素的类型都要长时</strong>，就要对整数集合进行升级</p>
<p>例：一整数集合中有 3 个类型为<code>int16_t</code>的元素，其数组长度为 48 位</p>
<p>当向这个集合内加入元素 65535，这个新元素需要用<code>int32_t</code>来保存，会将<code>contents</code>数组扩容至 $4\times 32&#x3D;128$ 位，所以就在原来基础上扩容 80 位</p>
<p>然后<strong>从数组尾部开始分配每一个元素的空间</strong>，将原有元素转换为<code>int32_t</code>类型并放到正确的位置上</p>
<blockquote>
<p><strong>整数集合支持降级操作吗？</strong></p>
</blockquote>
<p><strong>不支持降级操作</strong>，如果删除了上面例子中的 65535，即使剩余元素都是<code>int16_t</code>类型，但不会因此而降级</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>Redis 中<strong>只有 zset 对象的底层实现用到了跳表</strong>，跳表的优势是能支持平均 $O(log_2n)$ 时间复杂度的节点查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<h3 id="跳表结构设计"><a href="#跳表结构设计" class="headerlink" title="跳表结构设计"></a>跳表结构设计</h3><p><strong>跳表节点结构：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// Zset 对象的元素值</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">// 元素权重值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 节点的level数组，保存每层上的前向指针和跨度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 指向下一跳表节点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度 记录两个节点之间的距离</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>跳表节点中的 <code>ele</code> 存储的是元素值，其类型是前文中的[SDS类型](# SDS（Simple Dynamic String）)，<strong>当两个节点的权重相同时，<code>ele</code> 值小的排前面</strong></p>
<p><strong>跳表结构：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头尾节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 层数量</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>跳表的头节点指针指向的是<strong>一个不带任何数据信息的跳表节点</strong>，其存储了<strong>跳表所有层的第一个节点指针</strong></p>
<h3 id="跳表查询过程"><a href="#跳表查询过程" class="headerlink" title="跳表查询过程"></a>跳表查询过程</h3><p>查找一个跳表节点的过程时，跳表会<strong>从头节点的最高层开始</strong>，逐一遍历每一层</p>
<p>在遍历某一层的跳表节点时，会用跳表节点中的 <strong>SDS 类型的元素和元素的权重</strong>来进行判断，共有两个判断条件：</p>
<ul>
<li><strong>如果当前节点的权重「小于」要查询节点的权重</strong>，跳表就会访问该层上的下一个节点</li>
<li>**如果当前节点的权重「等于」要查询节点的权重，且当前节点的 <code>ele</code>「小于」查询节点的 <code>ele</code>**，跳表就会访问该层上的下一个节点</li>
</ul>
<p><strong>如果条件都不满足或下一节点为空</strong>，跳表就会使用当前遍历到的节点的 <code>level[]</code> 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找</p>
<h3 id="跳表插入过程"><a href="#跳表插入过程" class="headerlink" title="跳表插入过程"></a>跳表插入过程</h3><p>插入跳表节点时，传入跳表 $zsl$、权重 $score$ 和元素值 $ele$，进行以下步骤：</p>
<ul>
<li><p>定义<strong>跳表节点数组 $update[]$</strong> 和<strong>整数数组 $rank[]$</strong></p>
<ul>
<li>$update[]$：用于存储<strong>节点插入处中每一层的前一个节点</strong></li>
<li>$rank[]$：用于存储每层的<strong>头节点到节点插入处的前一个节点的距离</strong></li>
</ul>
</li>
<li><p>根据<strong>查询的遍历逻辑</strong>，从顶层开始，使用指针节点 $x$ 遍历到<strong>不能再前进的节点位置</strong>，再进行下一层的遍历</p>
<ul>
<li>在遍历时，对于第 $i$ 层来说，有 $update[i]&#x3D;x,\ rank[i]&#x3D;\sum{x.span}$</li>
</ul>
</li>
<li><p>至此，指针节点 $x$ 的下一节点即为<strong>待插入节点的插入处</strong>，使用随机算法生成**待插入节点的跨越的层数 $level$**，并判断 $level$ 是否大于跳表 $zsl$ 的最高层（$zsl.level$）</p>
<ul>
<li>若<strong>大于</strong>，则初始化 $level$ 到 $zsl.level$ 层的 $update[i]&#x3D;zsl.header,rank[i]&#x3D;0$，并将 $zsl.level$ 设为 $level$</li>
</ul>
</li>
<li><p>调用函数，根据 $level,score,ele$ 创建跳表节点</p>
</li>
<li><p>从最底层开始，用 $update[],rank[]$ 来初始化<strong>跳表节点每层的 $backward,span$ 属性</strong>、跳表节点的<strong>前节点的 $forward$ 指针</strong>和<strong>后节点的 $backward$ 指针</strong></p>
</li>
</ul>
<p>具体的流程就是</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://xiaolincoding.com/redis/data_struct/data_struct.html#rehash-%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6">Redis 数据结构 | 小林coding (xiaolincoding.com)</a></li>
<li><a href="https://www.cnblogs.com/MrLiuZF/p/14974764.html">redis 5.0.2 源码阅读——跳跃表skiplist - Mr-xxx - 博客园 (cnblogs.com)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 垃圾回收</title>
    <url>/post/fe21ea5a/</url>
    <content><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h2><h3 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h3><p>在每个对象中设置一个计数器，每当一个对象被引用一次就将计数器+1,</p>
<p>无法解决循环引用的问题</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>选取一些对象作为<strong>GC Roots</strong>，并对其引用的对象进行遍历标记（包括其自身），没有被标记的对象就是可以被回收的对象</p>
<p>可以被作为<strong>GC Roots</strong>的对象：</p>
<ul>
<li>本地方法栈（Native方法）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中被常量引用的对象</li>
<li>所有被同步锁引用的对象</li>
<li>虚拟机站（栈帧的局部变量表）中引用的对象</li>
<li>JNI（<strong>J</strong>ava <strong>N</strong>ative <strong>I</strong>nterface）引用的对象</li>
</ul>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h3><p>将待回收的对象进行标记，然后对标记的对象的内存进行回收</p>
<h3 id="分区复制法"><a href="#分区复制法" class="headerlink" title="分区复制法"></a>分区复制法</h3><p>将内存分为几个区，当一个区的内存不够用时，对该区进行一次垃圾回收，该区中所有存活对象放到另一个区中</p>
<h3 id="标记-整理法"><a href="#标记-整理法" class="headerlink" title="标记-整理法"></a>标记-整理法</h3><p>与<strong>标记-清除法</strong>类似，不同点是在清除对象后对存活对象进行一次整理</p>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>使用分区复制法进行回收，新生代的内存空间占堆内存空间的 $\frac{1}{3}$ ，其中新生代空间又分为Eden区和幸存区（From和To区）。</p>
<ul>
<li><p>当有对象需要分配内存时，将其放入Eden区</p>
</li>
<li><p>当Eden区内存不足时，将<strong>Eden区和From区</strong>的存活对象复制到<strong>To区</strong>，并对Eden区和From区进行GC</p>
</li>
<li><p>当Eden区内存又不足时，将<strong>Eden区和To区</strong>的存活对象复制到<strong>From区</strong>，并对Eden区和To区进行GC</p>
</li>
<li><p>如此往复对From区和To区进行交替使用，当幸存区中对象活过了几轮回收（最多15轮），其会晋升到老年代（幸存区内存不足时，大对象会直接晋升）</p>
</li>
</ul>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h3><p><strong>Serial和Serial Old</strong>是串行垃圾回收器，是指使用单线程进行垃圾回收，堆内存较小</p>
<ul>
<li><strong>Serial：</strong>作用于新生代，采用<strong>分区复制法</strong></li>
<li><strong>Serial Old：</strong>作用于老年代，采用<strong>标记-整理法</strong></li>
</ul>
<p>在垃圾回收时，只有一个线程在工作，并且Java程序中的所有线程都会<strong>停止工作</strong>（STW），等待垃圾回收的完成</p>
<h3 id="并行垃圾回收器"><a href="#并行垃圾回收器" class="headerlink" title="并行垃圾回收器"></a>并行垃圾回收器</h3><p><strong>Parallel New和Parallel Old</strong>是并行垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p>
<ul>
<li><strong>Parallel New：</strong>作用于新生代，采用<strong>分区复制法</strong></li>
<li><strong>Parallel Old：</strong>作用于老年代，采用<strong>标记-整理法</strong></li>
</ul>
<p>在垃圾回收时，多个线程在工作，Java程序中的所有线程也会<strong>停止工作</strong></p>
<h3 id="CMS并发垃圾回收器"><a href="#CMS并发垃圾回收器" class="headerlink" title="CMS并发垃圾回收器"></a>CMS并发垃圾回收器</h3><p>主要针对老年代进行垃圾回收，该回收器在垃圾回收时其他线程<strong>仍可以正常运行</strong></p>
<ul>
<li>首先对所有<strong>GC Roots</strong>进行标记，非常快</li>
<li>同时开启GC和用户线程，用一个闭包结构区记录可达对象。但该过程不能保证记录到所有可达对象（因为用户线程还在进行）</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium</title>
    <url>/post/4d23fd8d/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>一个 Python 的开源库，用来<strong>模拟用户</strong>操作 Web 界面。如鼠标点击、键盘输入等，因为是使用浏览器模拟，所以可以加载一些用 <strong>js 动态渲染</strong>的页面信息，一般用来做<strong>爬虫</strong>或 <strong>Web 的自动化测试工具</strong></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pip install selenium</code> 即可</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="创建浏览器实例"><a href="#创建浏览器实例" class="headerlink" title="创建浏览器实例"></a>创建浏览器实例</h3><p>目前我接触到的就chrome和edge浏览器，可能还有其他的，没有了解太多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;D:\xx\xx&#x27;</span> <span class="comment"># 浏览器 exe 文件路径</span></span><br><span class="line">chrome_driver = webdriver.chrome(path) <span class="comment"># chrome浏览器</span></span><br><span class="line">edge_driver = webdriver.edge(path) <span class="comment"># edge浏览器</span></span><br></pre></td></tr></table></figure>

<h3 id="访问页面和等待加载"><a href="#访问页面和等待加载" class="headerlink" title="访问页面和等待加载"></a>访问页面和等待加载</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">edge_driver.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>) <span class="comment"># 访问页面</span></span><br><span class="line"><span class="comment"># 每0.5秒检测指定元素是否已经渲染出来，5秒内都没检测到就抛出异常</span></span><br><span class="line">WebDriverWait(edge_driver, <span class="number">5</span>, <span class="number">0.5</span>)</span><br><span class="line">.until(expected_conditions.presence_of_element_located((By.ID, <span class="string">&#x27;xxx&#x27;</span>)), message=<span class="string">&#x27;元素未找到&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="获取页面内元素"><a href="#获取页面内元素" class="headerlink" title="获取页面内元素"></a>获取页面内元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">element = driver.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>) <span class="comment"># 通过id属性获取元素</span></span><br><span class="line">element = driver.find_element_by_name(<span class="string">&#x27;wd&#x27;</span>) <span class="comment"># 通过name属性获取元素</span></span><br><span class="line">element = driver.find_element_by_class_name(<span class="string">&#x27;input&#x27;</span>) <span class="comment"># 通过class属性获取元素</span></span><br><span class="line">element = driver.find_element_by_tag_name(<span class="string">&#x27;input&#x27;</span>) <span class="comment"># 通过标签名获取元素</span></span><br><span class="line">element = driver.find_element_by_link_text(<span class="string">&#x27;视频&#x27;</span>) <span class="comment"># 通过链接文本值获取元素</span></span><br><span class="line">element = driver.find_element_by_partial_link_text(<span class="string">&#x27;视&#x27;</span>)<span class="comment"># 通过部分链接文本值获取元素</span></span><br><span class="line">element = driver.find_element_by_xpath(<span class="string">&quot;//*[@id=&#x27;kw&#x27;]&quot;</span>) <span class="comment"># 通过Xpath获取元素</span></span><br><span class="line">element = driver.find_element_by_css_selector(<span class="string">&#x27;#kw&#x27;</span>) <span class="comment"># 通过CSS选择器获取元素</span></span><br></pre></td></tr></table></figure>

<h3 id="设置网页-Cookie"><a href="#设置网页-Cookie" class="headerlink" title="设置网页 Cookie"></a>设置网页 Cookie</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要先访问网页再配置cookie</span></span><br><span class="line">driver.get(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"><span class="comment"># 清空原有cookie</span></span><br><span class="line">driver.delete_all_cookies()</span><br><span class="line"><span class="comment"># cookie是字典类型的 浏览器装个Cookie Editor插件就可以导出json格式的cookies</span></span><br><span class="line">cookies = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;domain&quot;</span>: <span class="string">&quot;.taobao.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;expirationDate&quot;</span>: <span class="number">1725995896.097156</span>,</span><br><span class="line">        <span class="string">&quot;httpOnly&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;3PcFlag&quot;</span>,</span><br><span class="line">        <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="comment"># 要注意在selenium中sameSite字段只能有None. Lax, Strict三种情况，从Cookie Editor导出来不是这个格式需要自己替换一下</span></span><br><span class="line">        <span class="string">&quot;sameSite&quot;</span>: <span class="string">&#x27;None&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;secure&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;storeId&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;1725103097024&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.taobao.com/&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 添加cookie</span></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">	driver.add_cookie(cookie)</span><br><span class="line"><span class="comment"># 配置完要刷新才能生效</span></span><br><span class="line">driver.refresh()</span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="元素存在，但-click-失败"><a href="#元素存在，但-click-失败" class="headerlink" title="元素存在，但 click() 失败"></a>元素存在，但 click() 失败</h2><p>很大可能是因为<strong>元素被遮挡</strong>，导致直接调用 selenium 提供的 click 方法会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = driver.find_element_by_xpath(<span class="string">&#x27;//div[@class=&quot;abc&quot;]&#x27;</span>)</span><br><span class="line">driver.execute_script(<span class="string">&quot;arguments[0].click()&quot;</span>, e)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://www.cnblogs.com/liho/p/17822430.html">selenium定位元素被页面遮挡问题 - 萧兮易 - 博客园 (cnblogs.com)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>爬虫</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统 - 范式</title>
    <url>/post/93db69bb/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库系统</category>
      </categories>
      <tags>
        <tag>数据库系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 类加载</title>
    <url>/post/c398fcc2/</url>
    <content><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>一个类从被加载到 JVM 内存中开始，到被卸载出内存为止，它的整个生命周期可以简单概括为七个阶段：</p>
<ol>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li><strong>使用（Using）</strong></li>
<li><strong>卸载（Unloading）</strong></li>
</ol>
<p>其中，<strong>验证、准备和解析</strong>这三个阶段可以统称为<strong>链接（Linking）</strong></p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类的加载即为类的生命周期的前五步：加载、链接（验证、准备、解析）、初始化</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载的第一步，主要完成以下三件事：</p>
<ol>
<li>通过类加载器在<code>classpath</code>中读取<code>xx.class</code>字节码文件，并将其转换为字节流形式读入内存</li>
<li>将字节流所代表的<strong>静态存储结构</strong>转换为<strong>方法区</strong>的<strong>运行数据结构</strong></li>
<li>在内存中生成一个该类的<code>java.lang.Class</code>对象，</li>
</ol>
<p>其中<code>.class</code>字节码文件有多种加载途径：</p>
<ul>
<li>在本地系统中直接加载</li>
<li>从<code>zip</code>或<code>jar</code>等归档文件中加载<code>.class</code>文件</li>
<li>从数据库中提取<code>.class</code>文件</li>
<li>将<code>.java</code>文件动态编译为<code>.class</code>文件（<code>javac xx.java</code>）</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>类被加载后，系统生成了一个<code>Class</code>对象用于反射，紧接着会进入<strong>链接</strong>阶段</p>
<ul>
<li><strong>验证：</strong>检验被加载类是否有正确的内部结构，并和其他类协调一致</li>
<li><strong>准备：</strong>负责为类的<strong>静态属性</strong>分配内存，并设置默认初始值<ul>
<li><strong>解析：</strong>将类的二进制数据中的<strong>符号引用</strong>替换为<strong>直接引用</strong>（<strong>符号引用</strong>是用一组符号描述所引用的目标，<strong>直接引用</strong>是指向目标的指针）</li>
</ul>
</li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><strong>验证阶段的目的是确保<code>class</code>文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全</strong></p>
<p>验证阶段<strong>不是必须执行的阶段</strong>，若你能保证程序运行的所有代码都已经被验证过了，那你可以考虑使用<code>-Xverify:none</code>参数来关闭<strong>大部分的类验证操作</strong>，以缩短虚拟机类加载的时间</p>
<p>验证阶段主要由<strong>四个检验阶段</strong>组成：</p>
<ol>
<li><strong>文件格式验证：</strong>验证字节流是否符合<code>class</code>文件格式的规范<ul>
<li>如：是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池的常量是否有不被支持的类型</li>
</ul>
</li>
<li><strong>元数据验证：</strong>对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求<ul>
<li>如：这个类<strong>是否有父类</strong>（除<code>java.lang.Object</code>之外的所有类都有父类）、这个类<strong>是否被继承了不允许继承的类</strong>（被<code>final</code>修饰的类）等</li>
</ul>
</li>
<li><strong>字节码验证：</strong>通过数据流分析和控制流分析，确定程序语义是合法、符合逻辑的<ul>
<li>如：函数的<strong>参数类型是否正确</strong>、对象的<strong>类型转换是否合理</strong>（像父类对象赋值给子类对象类型就是非法的）</li>
</ul>
</li>
<li><strong>符号引用验证：</strong>验证该类的正确性<ul>
<li>如：该类要使用的<strong>其他类、方法、字段是否存在</strong>，是否有<strong>正确的访问权限</strong></li>
</ul>
</li>
</ol>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><strong>准备阶段是正式为类变量分配内存空间并设置类变量初始化值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段<strong>有以下几点需要注意</strong>：</p>
<ul>
<li>这时候进行内存分配的仅包括<strong>类变量</strong>（<code>Class Variables</code>，即静态变量，被<code>static</code>关键字修饰的变量，只与类相关，因此被称为类变量），而不包括<strong>实例变量</strong>。实例变量会在对象实例化时随着对象一块分配在Java堆内存中</li>
<li>从概念上讲，类变量所使用的内存都应当在<strong>方法区</strong>中进行分配。不过在JDK7之前，HotSpot使用永久代来实现方法区时，是完全符合这种逻辑概念的。而在JDK7及之后，HotSpot已经把原来<strong>放在永久代的字符串常量池、静态变量等移动到堆内存中</strong>，这个时候类变量就会随着<code>Class</code>对象一起存放进<strong>堆内存</strong>中</li>
<li>这里所设置的初始值<strong>通常情况</strong>下是数据类型的默认值（<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等），比如我们定义了<code>public static int value = 111;</code>，那么<code>value</code>变量在<strong>准备阶段的初始值</strong>就是0而不是111（初始化阶段才会赋值）；<ul>
<li><strong>特殊情况：</strong>用<code>final</code>关键字修饰<code>value</code>变量，那在准备阶段<code>value</code>的值就会被赋值为111</li>
</ul>
</li>
</ul>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><strong>解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程</strong>，解析动作主要针对<strong>类或接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>、<strong>方法类型</strong>、<strong>方法句柄和调用限定符</strong> 7 类符号引用进行</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 反射</title>
    <url>/post/f7e99270/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>使用反射，你可以<strong>在运行时动态地获取类的各项信息</strong>（成员变量、函数方法等等），提高了程序的灵活性和可扩展性</p>
<p>Java 中与反射相关的几个类：</p>
<ul>
<li><code>java.lang.Class</code>：反射最<strong>核心</strong>的类，可以通过该类获取反射类的各种信息，包括但不限于以下几个类</li>
<li><code>java.lang.reflect.Method</code>：代表类的方法，能用该类来<strong>调用反射类的方法</strong></li>
<li><code>java.lang.reflect.Field</code>：代表类的字段，能用该类来<strong>访问或修改反射类的字段</strong></li>
<li><code>java.lang.reflect.Constructor</code>：代表类的构造函数，能用该类来<strong>创建反射类的实例</strong></li>
</ul>
<p>还有其他像 <code>Proxy</code>、<code>InvocationHandler</code> 等等的类</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>反射的应用场景很广，但在业务开发的时候很少有用到反射机制。Java的各种框架如 <strong>Struts、Spring、MyBatis</strong> 等都大量使用到了反射机制</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>可以在运行时动态创建对象，使用 <code>Class</code> 类的 <code>newInstance()</code> 或者调用 <code>Constructor</code> 类来创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在 JDK 动态代理时用到了 <code>Proxy</code> 和 <code>InvocationHandler</code> 来实现代理</p>
<h2 id="Spring-中-Bean-的属性注入"><a href="#Spring-中-Bean-的属性注入" class="headerlink" title="Spring 中 Bean 的属性注入"></a>Spring 中 Bean 的属性注入</h2><p>Spring 通过反射机制获取 Bean 的属性字段信息，并且调用其 <code>Setter</code> 方法来注入值</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><ul>
<li><strong>优点：</strong>可以让代码变得更灵活，为各种框架的功能开发提供了便利</li>
<li><strong>缺点：</strong>让我们在运行时有了分析和操作类的能力，带来了<strong>安全问题</strong></li>
</ul>
<h1 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h1><p>在程序中，JVM每加载完一个类，就会在<strong>堆内存</strong>中产生一个该类的<code>Class</code>对象，一个类在堆内存中最多只会有一个<code>Class</code>对象</p>
<p>这个<code>Class</code>对象包含了该类的<strong>完整结构信息</strong>，如类的成员变量、成员方法、构造方法、使用的注解等信息</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux - 命令</title>
    <url>/post/8ab0fdf6/</url>
    <content><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="输出文件内容"><a href="#输出文件内容" class="headerlink" title="输出文件内容"></a>输出文件内容</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>cat [OPTION]... [FILE]...</code></p>
<h4 id="选项及含义"><a href="#选项及含义" class="headerlink" title="选项及含义"></a>选项及含义</h4><table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">全称</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-A</code></td>
<td align="center"><code>--show-all</code></td>
<td align="center">相当于<code>-vET</code></td>
</tr>
<tr>
<td align="center"><code>-b</code></td>
<td align="center"><code>--number-noblank</code></td>
<td align="center">为非空白行标上<strong>数字序号</strong></td>
</tr>
<tr>
<td align="center"><code>-e</code></td>
<td align="center"></td>
<td align="center">相当于<code>-vE</code></td>
</tr>
<tr>
<td align="center"><code>-E</code></td>
<td align="center"><code>--show-ends</code></td>
<td align="center">在每一行末尾显示<code>$</code></td>
</tr>
<tr>
<td align="center"><code>-n</code></td>
<td align="center"><code>--number</code></td>
<td align="center">为每一行标上<strong>数字序号</strong></td>
</tr>
<tr>
<td align="center"><code>-s</code></td>
<td align="center"><code>--squeeze-blank</code></td>
<td align="center">压缩<strong>超过一行</strong>的空白行为一行</td>
</tr>
<tr>
<td align="center"><code>-t</code></td>
<td align="center"></td>
<td align="center">相当于<code>-vT</code></td>
</tr>
<tr>
<td align="center"><code>-T</code></td>
<td align="center"><code>--show-tabs</code></td>
<td align="center">将<code>\t</code>符号显示为<code>^I</code></td>
</tr>
<tr>
<td align="center"><code>-v</code></td>
<td align="center"><code>--show-nonprinting</code></td>
<td align="center">用<code>^</code>或<code>M-</code>显示一些不能打印的字符</td>
</tr>
</tbody></table>
<h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><p>一般用于打印<strong>二进制目标文件、库或可执行文件</strong>中的<strong>可打印字符</strong>，字符串默认至少是4个或更多可打印字符的任意序列</p>
<h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>strings [option(s)] [file(s)]</code></p>
<h4 id="选项及含义-1"><a href="#选项及含义-1" class="headerlink" title="选项及含义"></a>选项及含义</h4><table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">全称</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>-a</code></td>
<td align="center"><code>--all</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-d</code></td>
<td align="center"><code>--data</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-f</code></td>
<td align="center"><code>--print-file-name</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-n</code></td>
<td align="center"><code>--bytes=[number]</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-t</code></td>
<td align="center"><code>--radix=&#123;o,d,x&#125;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-w</code></td>
<td align="center"><code>--include-all-whitespace</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-o</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-T</code></td>
<td align="center"><code>--target=&lt;BFDNAME&gt;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-e</code></td>
<td align="center"><code>--encoding=&#123;s,S,b,l,B,L&#125;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>-s</code></td>
<td align="center"><code>--output-separator=&lt;string&gt;@&lt;file&gt;</code></td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/post/53d0684b/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>市面上主流的基于 Linux 的操作系统主要有 Ubuntu，CentOS 等等。租个云服务器或者自己在电脑装个虚拟机就可以用</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道可以用来将<strong>前一个命令的输出作为后一个命令的输入</strong>，就像拼接一个管道一样将他们串联起来实现一些复杂的功能</p>
<p>其基本用法是在要串联的两个命令之间加 <code>|</code>，例如：<code>ls | grep &quot;a.txt&quot;</code></p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>重定向可以改变命令的输入和输出目标，允许用户指定特殊的数据输入来源（例如文件），而不是使用控制台来输入或输出</p>
<ul>
<li><strong>标准输入（stdin）：</strong>用 <code>&lt;</code> 或 <code>&lt;&lt;</code> 来指定输入目标，<ul>
<li><code>grep test &lt; a.txt</code></li>
</ul>
</li>
<li><strong>标准输出（stdout）：</strong>用 <code>&gt;</code> 或 <code>&gt;&gt;</code> 来指定输出目标，前者表示<strong>覆盖输出</strong>，后者表示<strong>追加输出</strong>（也可以 <code>1&gt;</code> 或 <code>1&gt;&gt;</code>，1 是可以省略的）<ul>
<li><code>echo &quot;hello world&quot; &gt; a.txt</code></li>
<li><code>echo &quot;.&quot; &gt;&gt; a.txt</code></li>
</ul>
</li>
<li><strong>标准错误（stderr）：</strong>用 <code>2&gt;</code> 或 <code>2&gt;&gt;</code> 指定错误信息输出目标，前后者区别与上相同<ul>
<li><code>ls a.txt 2&gt; a.txt</code></li>
</ul>
</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>输出<strong>文本文件的内容</strong></p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>cat [OPTION]... [FILE]...</code></p>
<h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><p>一般用于打印<strong>二进制目标文件、库或可执行文件</strong>中的<strong>可打印字符</strong>，字符串默认至少是4个或更多可打印字符的任意序列</p>
<h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>strings [option(s)] [file(s)]</code></p>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p><strong>持续输出</strong>文本文件的内容</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL - 事务</title>
    <url>/post/619ba060/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是<strong>逻辑上</strong>的一组操作，<strong>要么都执行，要么都不执行</strong></p>
<p>关系型数据库（如MySQL、SQL Server、Oracle等）事务都有<strong>ACID特性</strong>：</p>
<ul>
<li><strong>原子性（Atomicity）：</strong>事务是<strong>最小的执行单位</strong>，不能再分割；事务的原子性确保了一个事务的操作<strong>要么都执行，要么都不执行</strong></li>
<li><strong>一致性（Consistency）：</strong>执行事务前后，数据保持一致；如转账业务，<strong>无论事务是否成功</strong>，转账人和收款人的金额之和是不变的</li>
<li><strong>隔离性（Isolation）：</strong>指多个事务在同时执行时，事务与事务之间<strong>互不影响</strong></li>
<li><strong>持久性（Durability）：</strong>一个事务在被提交后，其对数据的修改是<strong>持久的</strong>，即使系统关闭也不会对其有影响</li>
</ul>
<p>ACID 四个特性中，<strong>A、I、D</strong>是为C服务的。也就是说只有保证了<strong>原子性、隔离性、持久性</strong>才能保证<strong>一致性</strong></p>
<h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><h3 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="脏读（Dirty read）"></a>脏读（Dirty read）</h3><p>事务A读取了事务B<strong>修改完但未提交</strong>的数据，而事务B因为某些原因发生了<strong>回滚</strong>，导致事务B修改的数据<strong>没有被持久化</strong></p>
<p>此时事务A读取到的就是<strong>脏数据</strong>，这个过程就被称为<strong>脏读</strong></p>
<h3 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="丢失修改（Lost to modify）"></a>丢失修改（Lost to modify）</h3><p>事务A和事务B同时读取了某数据，但事务A<strong>先提交</strong>了其修改后的数据，事务B后提交<strong>覆盖</strong>了事务A修改的数据</p>
<p>此时事务A的修改结果就发生了丢失，这个过程就被称为<strong>丢失修改</strong></p>
<h3 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="不可重复读（Unrepeatable read）"></a>不可重复读（Unrepeatable read）</h3><p>事务A需要多次读取某数据，事务B在事务A<strong>下一次读取数据前</strong>提交了其对该数据的修改，导致事务A再次读取数据时与前一次读取的<strong>结果不同</strong></p>
<p>此时事务A两次读取的数据结果不相同，这个过程就被称为<strong>不可重复读</strong></p>
<h3 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="幻读（Phantom read）"></a>幻读（Phantom read）</h3><blockquote>
<p>幻读是不可重复读的一种<strong>特殊情况</strong>，将其区分开的原因是解决这两种问题的方案不同</p>
</blockquote>
<p>事务A需要多次读取某个范围的数据，事务B在事务A<strong>下一次读取数据前</strong>在其范围内插入了一条数据，导致事务A再次读取数据时发现了一条原先不存在的数据，好像发生了幻觉</p>
<p>此时事务A读取到了事务B插入的新数据，这个过程就被称为<strong>幻读</strong></p>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>隔离级别由低到高，越高的隔离级别<strong>越能保证数据的一致性</strong>，但代价是<strong>性能也越差</strong></p>
<h2 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ-UNCOMMITTED）"></a>读未提交（READ-UNCOMMITTED）</h2><p>事务修改后<strong>即使没有提交</strong>，<strong>其他的事务也能读取到修改后的数据</strong></p>
<p><em>可能会出现[脏读](# 脏读（Dirty read）)、[不可重复读](# 不可重复读（Unrepeatable read）)、[幻读](# 幻读（Phantom read）)情况</em></p>
<h2 id="读已提交（READ-COMMITTED）"><a href="#读已提交（READ-COMMITTED）" class="headerlink" title="读已提交（READ-COMMITTED）"></a>读已提交（READ-COMMITTED）</h2><blockquote>
<p><strong>大多数数据库的默认隔离级别</strong></p>
</blockquote>
<p><strong>事务在执行期间对数据的修改</strong>，只有在<strong>事务提交后</strong>才能被其他事务看到</p>
<p><em>可能会出现[不可重复读](# 不可重复读（Unrepeatable read）)、[幻读](# 幻读（Phantom read）)情况</em></p>
<h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE-READ）"></a>可重复读（REPEATABLE-READ）</h2><blockquote>
<p><strong>MySQL的默认隔离级别</strong></p>
</blockquote>
<p>一个事务<strong>执行过程中任何时刻看到的数据</strong>，一直和<strong>这个事务启动时看到的数据</strong>是一致的</p>
<p><em>可能会出现[幻读](# 幻读（Phantom read）)的情况</em></p>
<h2 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h2><p>会对记录加上<strong>读写锁</strong>，在多个事务对这条记录进行读写操作时，如果<strong>不能获取到读写锁（读写冲突）</strong>，就<strong>必须等待持有读写锁的事务执行完毕</strong>，才能继续执行</p>
<p><em>不会出现任何[并发事务可能出现的问题](# 并发事务带来的问题)</em></p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>MVCC（<strong>M</strong>ulti-<strong>V</strong>ersion <strong>C</strong>oncurrency <strong>C</strong>ontrol）：多版本并发控制，指维护一个数据的多个版本，使得读写操作不冲突</p>
<p>MVCC 主要针对的是<strong>快照读</strong>（普通的 select 语句）</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>记录中的隐藏字段：</p>
<ul>
<li><code>trx_id</code>：最近修改<strong>事务ID</strong>，记录插入这条记录或最后一次修改该记录的事务ID</li>
<li><code>row_id</code>：隐藏主键，如果表中<strong>没有主键</strong>，则会生成该字段作为<strong>聚簇索引</strong></li>
<li><code>roll_ptr</code>：回滚指针，指向这条记录的<strong>上一个版本</strong>，用于配合undo log</li>
</ul>
<h3 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h3><p>不同事务或相同事务对<strong>同一条记录</strong>进行修改，会导致该记录的undo log生成一条<strong>记录版本链表</strong>，链表的头部是<strong>最新的旧记录</strong>，链表尾部是<strong>最早的旧记录</strong></p>
<h3 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h3><p>Read View 中包含四个<strong>核心字段</strong>：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>trx_ids</td>
<td>创建 Read View 时未提交的活跃<strong>事务ID集合</strong></td>
</tr>
<tr>
<td>up_limit_id</td>
<td>活跃事务中<strong>最小ID</strong></td>
</tr>
<tr>
<td>low_limit_id</td>
<td>预分配事务ID，即活跃事务中<strong>最大ID+1</strong>（事务ID是自增的）</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>Read View <strong>创建者的事务ID</strong></td>
</tr>
</tbody></table>
<p><strong>版本链数据访问规则：</strong></p>
<ul>
<li><strong>trx_id &#x3D;&#x3D; creator_trx_id：允许访问</strong>；当前事务在访问自己修改过的记录</li>
<li><strong>trx_id &lt; up_limit_id：允许访问</strong>；当前事务在该 ReadView 创建之前已经提交</li>
<li><strong>trx_id &gt;&#x3D; low_limit_id：不允许访问</strong>；当前事务在该 ReadView 创建之后才开启</li>
<li><strong>trx_id $\in$ [up_limit_id, low_limit_id)：</strong>判断 trx_id 是否在 trx_ids 中<ul>
<li><strong>存在：不允许访问</strong>；说明创建 ReadView 时该事务还在活跃没提交</li>
<li><strong>不存在：允许访问</strong>；说明创建 ReadView 前该事务已经提交</li>
</ul>
</li>
</ul>
<p>当创建好一个 Read View 后，在读取表中记录时，就会对<strong>每一条记录的隐藏字段 <code>trx_id</code> 进行上述规则判断</strong></p>
<ul>
<li>如果<strong>允许访问</strong>，则读取这条记录</li>
<li>如果<strong>不允许</strong>，则根据隐藏字段 <code> roll_ptr</code> 沿着 undo log 版本链对每一版本的 <code>trx_id</code> 进行判断，寻找该记录的<strong>第一个允许访问的版本</strong></li>
</ul>
<h2 id="MVCC-实现读提交"><a href="#MVCC-实现读提交" class="headerlink" title="MVCC 实现读提交"></a>MVCC 实现读提交</h2><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong></p>
<blockquote>
<p><strong>以下解释讨论的是小林 coding 中举的例子</strong></p>
</blockquote>
<p>当<strong>事务 B 的修改提交后</strong>，因为事务 A 读取时<strong>会创建新的 Read View</strong>，所以 <strong>trx_ids 中就不会存在事务 B 的事务 ID 了</strong>。然后在读取记录时就能够读取到事务 B 修改过的记录（因为记录的 <code>trx_id</code> 不在 trx_ids 中）</p>
<p>由此就保证了<strong>只有提交的修改才能被读取到</strong></p>
<h2 id="MVCC-实现可重复读"><a href="#MVCC-实现可重复读" class="headerlink" title="MVCC 实现可重复读"></a>MVCC 实现可重复读</h2><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong></p>
<blockquote>
<p><strong>以下解释讨论的是小林 coding 中举的例子</strong></p>
</blockquote>
<p>当<strong>事务 B 的修改提交后</strong>，因为事务 A 读取时使用的<strong>仍是事务第一次读取时的  Read View</strong>，所以<strong>即使事务 B 提交也不会改变 trx_ids 中的元素</strong>。然后在读取时<strong>读取到的仍然是一个版本的记录</strong></p>
<p>由此就保证了<strong>一个事务执行期间重复读取到的数据时一致的</strong></p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html#innodb-%E5%AF%B9-mvcc-%E7%9A%84%E5%AE%9E%E7%8E%B0">InnoDB存储引擎对MVCC的实现 | JavaGuide</a></li>
<li><a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">事务隔离级别是怎么实现的？ | 小林coding (xiaolincoding.com)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - 分布式锁</title>
    <url>/post/39feb941/</url>
    <content><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h2><p>Redis 自带的分布式锁</p>
<p><strong>获取锁：</strong><code>set lock value NX EX 10</code>（设置过期时间是为了在业务超时时自动释放锁防止忙等）</p>
<p><strong>释放锁：</strong><code>del lock</code></p>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p>使用Redis自带的<code>setnx</code>命令，使用到了<strong>看门狗机制</strong>，当线程获取锁后，创建一个看门狗线程定时<strong>给锁续期</strong>（当<strong>线程释放锁</strong>时通知看门狗线程停止续期）</p>
<p>同时其他线程若获取锁失败则再尝试<strong>一定次数</strong>，若都失败则获取锁失败</p>
<p>看门狗线程定时续期的间隔一般是获取锁的 <code>过期时间 / 3</code></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - 过期、淘汰策略</title>
    <url>/post/e2993eee/</url>
    <content><![CDATA[<h1 id="数据过期、淘汰策略"><a href="#数据过期、淘汰策略" class="headerlink" title="数据过期、淘汰策略"></a>数据过期、淘汰策略</h1><h2 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h2><p>当 Redis 中 key 过期，需要对这些 key 进行删除，Redis中采用<strong>惰性删除</strong>+<strong>定期删除</strong>组合的方式清理过期 key</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>当请求到过期 key 时才将其删除</p>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>每隔一段时间对 key 进行检查，删除其中过期的key</p>
<ul>
<li><strong>SLOW模式：</strong>执行频率默认为10hz，每次执行耗时不超过25ms（执行频率可以在<strong>redis.conf</strong>中配置）</li>
<li><strong>FAST模式：</strong>执行频率不固定，但每两次间隔不超过2ms，每次执行耗时不超过1ms</li>
</ul>
<h2 id="数据淘汰"><a href="#数据淘汰" class="headerlink" title="数据淘汰"></a>数据淘汰</h2><p>当Redis中<strong>内存不足</strong>时，需要淘汰掉一些key（不一定是过期key），Redis中默认采用<code>noeviction</code></p>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>Redis默认的淘汰策略为<code>noeviction</code>，可以在Redis-cli中使用<code>config get maxmemory-policy</code>指令查看当前内存淘汰策略，以及<code>config set maxmemory-policy xxx</code>指令用来<strong>临时</strong>设置淘汰策略（永久修改需要在<code>redis.conf</code>文件中修改）</p>
<ul>
<li><code>noeviction</code>：不淘汰key，内存不足直接报错</li>
<li><code>alkeys-random</code>：随机删除任意key</li>
<li><code>alkeys-lru</code>：采用LRU（<strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed：最近最少使用）算法淘汰任意key</li>
<li><code>alkeys-lfu</code>：采用LFU（<strong>L</strong>east <strong>F</strong>requently <strong>U</strong>sed：最近最不频繁使用）算法淘汰任意key</li>
<li><code>volatile-ttl</code>：在设置了过期时间的key（限时key）中，删除<strong>TTL时间小</strong>的key</li>
<li><code>volatile-random</code>：随机删除限时key</li>
<li><code>volatile-lru</code>：采用LRU算法淘汰限时key</li>
<li><code>volatile-lfu</code>：采用LFU算法淘汰限时key</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - 集群</title>
    <url>/post/6e71851d/</url>
    <content><![CDATA[<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>集群的 Master 节点（主节点）负责写入数据，slave节点（从节点）负责读取数据，由主节点定期将数据同步到从节点中</p>
<h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><ul>
<li><p><strong>全量同步：</strong></p>
<ul>
<li>从节点向主节点发起同步请求，携带 replid 和 offset 参数（数据集ID和偏移量）</li>
<li>主节点判断 replid 是否一致，<strong>若否</strong>则返回主节点的数据版本信息（ replid 和 offset）</li>
<li>主节点执行<code>bgsave</code>指令生成 RDB 快照，并发送 RDB 文件给从节点</li>
<li>记录生成RDB快照期间AOF中的所有命令到<code>repl_baklog</code>中，并将其发送给从节点</li>
</ul>
</li>
<li><p><strong>增量同步：</strong>（从节点重启或后期数据变化）</p>
<ul>
<li>从节点向主节点发起同步请求，携带 replid 和 offset 参数</li>
<li>主节点判断 replid 是否一致，<strong>若是</strong>则回复从节点 continue</li>
<li>在<code>repl_baklog</code>中获取 offset 之后的命令数据，并返回给从节点</li>
</ul>
</li>
</ul>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>设置一些 Redis 节点为 sentinel 节点（哨兵节点），哨兵节点会<strong>监控</strong>集群中主从节点的状态，若主节点被认为是<strong>下线</strong>，则会选取新的主节点并通知客户端和其从节点</p>
<h3 id="主节点下线判断"><a href="#主节点下线判断" class="headerlink" title="主节点下线判断"></a>主节点下线判断</h3><p>哨兵节点通过<strong>心跳机制</strong>判断主节点是否存活</p>
<ul>
<li>若主节点未回应，则哨兵节点认为此主节点下线（称为<strong>主观下线</strong>）</li>
<li>当超过指定数量的哨兵认为其下线（称为<strong>客观下线</strong>），则在该集群中选取新的主节点</li>
</ul>
<h3 id="哨兵选主规则"><a href="#哨兵选主规则" class="headerlink" title="哨兵选主规则"></a>哨兵选主规则</h3><ul>
<li>若<strong>从节点与主节点断开时间</strong>超出指定值，则排除该从节点</li>
<li>选取<code>slave-priority</code>值小（优先级高）的从节点<ul>
<li>若优先级相同，则选取 offset 值大的从节点</li>
</ul>
</li>
<li>选取<code>slaveid</code>小的从节点</li>
</ul>
<h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><p>每个集群负责<strong>不同的数据</strong>，由每个集群的主节点来<strong>监控</strong>各个集群的主节点（主节点充当哨兵）</p>
<p>每个集群中的主节点存储<strong>路由表和哈希槽</strong>，当客户端请求不存在于集群中的数据时将请求路由到数据存在的集群中</p>
<p>在存储数据时，对数据的 <strong>key</strong> 进行哈希，并将哈希后的值与总哈希槽数量取模，存储到对应分区的集群中</p>
<h2 id="集群脑裂"><a href="#集群脑裂" class="headerlink" title="集群脑裂"></a>集群脑裂</h2><p>由于<strong>网络原因</strong>，正常的主节点被认为下线而选取了新的主节点，导致一个集群中存在了多个主节点</p>
<p>设置 Redis 中的配置参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">min-replicas-to-write x	# 允许主节点写入时，最少的从节点数量为 x</span><br><span class="line">min-replicas-max-lag x	# 从节点复制与同步延迟不能超过 x 秒</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis - 持久化</title>
    <url>/post/eb60980e/</url>
    <content><![CDATA[<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><p><strong>Redis两种持久化方式的对比：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>文件大小</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>实时性</td>
<td>弱</td>
<td>强</td>
</tr>
</tbody></table>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>通过创建<strong>快照</strong>来对<strong>某个时间点</strong>Redis中的数据进行备份</p>
<p>RDB快照文件存储的是经过压缩的<strong>二进制数据</strong>，所以在使用RDB文件恢复数据时速度快</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>redis.conf</code>文件中可以修改RDB备份的频率：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">save x y #在x秒内，若至少有y个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br></pre></td></tr></table></figure>

<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li><code>save</code>：直接生成RDB文件，阻塞Redis主线程</li>
<li><code>bgsave</code>：fork一个子进程，由子进程来生成，不会阻塞Redis主线程</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Redis将每一条<strong>更改Redis数据</strong>的命令写入到AOF缓冲区中，再根据配置中的<code>fsync</code>策略来将缓冲区数据写入磁盘文件中完成持久化</p>
<p>由于AOF存储的不是二进制数据而是<strong>命令数据</strong>，所以为了防止AOF文件过大会定期对AOF进行重写操作压缩文件大小</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendonly yes					# 是否开启AOF</span><br><span class="line">appendfilename appendonly.aof	# AOF文件名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷盘策略</span></span><br><span class="line">appendfsync always				# 写入缓冲区后立即刷盘</span><br><span class="line">appendfsync everysec			# 每秒刷盘</span><br><span class="line">appendfsync no					# 不刷盘</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/post/ae0f95e0/</url>
    <content><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><h3 id="视图阶段（JSP）"><a href="#视图阶段（JSP）" class="headerlink" title="视图阶段（JSP）"></a>视图阶段（JSP）</h3><p>早期的<strong>前后端不分离</strong>时期的MVC执行流程</p>
<ol>
<li>客户端将请求发送到<strong>DispatcherServlet</strong>（前端控制器）</li>
<li><strong>前端控制器</strong>接收到请求，调用<strong>HandlerMapping</strong>（处理器控制器）</li>
<li><strong>处理器控制器</strong>根据请求找到具体的处理器，生成<strong>处理器对象</strong>和<strong>处理器拦截器</strong>（如果有），并一齐返回给<strong>前端控制器</strong></li>
<li><strong>前端控制器</strong>调用<strong>HandlerAdapter</strong>（处理器适配器）</li>
<li><strong>处理器适配器</strong>经过适配调用具体的<strong>处理器</strong>（Handler&#x2F;Controller）</li>
<li><strong>处理器</strong>执行完成后，返回<strong>ModelAndView对象</strong>给<strong>处理器适配器</strong></li>
<li><strong>处理器适配器</strong>将<strong>ModelAndView对象</strong>返回给<strong>前端控制器</strong></li>
<li><strong>前端控制器</strong>将<strong>ModelAndView对象</strong>传给<strong>ViewResolver</strong>（视图解析器）</li>
<li><strong>视图解析器</strong>解析后返回具体<strong>View</strong>（视图）</li>
<li><strong>前端控制器</strong>将<strong>Model</strong>（模型数据）填充到<strong>视图</strong>中</li>
<li><strong>前端控制器</strong>响应客户端</li>
</ol>
<h3 id="前后端分离阶段"><a href="#前后端分离阶段" class="headerlink" title="前后端分离阶段"></a>前后端分离阶段</h3><p>前后端分离时期，具体的执行流程中<strong>前5步与视图阶段相同</strong></p>
<ol start="6">
<li><strong>处理器</strong>的方法上添加了**@ResponseBody**</li>
<li>通过<strong>HttpMessageConverter</strong>将方法返回值转换为<strong>JSON</strong>并响应客户端</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/post/6c92115f/</url>
    <content><![CDATA[<h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p><strong>IoC（Inversion of Control）</strong>即控制反转，它不是一种实现方式而是一种思想。大体含义主要为将类与类之间的<strong>依赖</strong>关系<strong>反转</strong>过来</p>
<p>当然反转不是指<strong>被依赖类</strong>来控制自己的依赖关系，而是指把控制权交由给<strong>外部容器</strong>（IoC 容器），由 IoC 容器来为需要依赖的类提供依赖</p>
<p>IoC最常见以及最合理的实现方式为<strong>依赖注入（Dependency Injection，简称DI）</strong></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><strong>AOP（Aspect Oriented Programming）</strong>即面向切面编程，AOP是OOP（面向对象编程）的一种延续，二者互补</p>
<p>AOP的目的是将<strong>横切关注点</strong>（记录日志等）从业务逻辑中分离出来，通过<strong>动态代理</strong>、<strong>字节码操作</strong>等技术来实现对代码的<strong>复用</strong>和<strong>解耦</strong>，提高代码的可维护性和可拓展性</p>
<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><h2 id="加载配置文件"><a href="#加载配置文件" class="headerlink" title="加载配置文件"></a>加载配置文件</h2><p>在启动阶段，SpringBoot 会首先加载配置文件。默认情况下，SpringBoot 会加载位于 <code>src/main/resources</code> 目录下的 <code>application.properties</code> 或 <code>application.yml</code> 文件</p>
<h2 id="创建-Spring-容器"><a href="#创建-Spring-容器" class="headerlink" title="创建 Spring 容器"></a>创建 Spring 容器</h2><p>Spring 容器是 <code>ApplicationContext</code> 的实现类。常用的实现类有 <code>AnnotationConfigApplicationContext</code>、<code>ClassPathXmlApplicationContext</code> 和 <code>GenericWebApplicationContext</code>。在 Spring Boot 中，通常使用 <code>SpringApplication</code> 类来创建容器</p>
<h2 id="实例化-Bean"><a href="#实例化-Bean" class="headerlink" title="实例化 Bean"></a>实例化 Bean</h2><p>根据 XML 中 Bean 的定义创建 Bean 对象，涉及到 Bean 的生命周期</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">Spring常见面试题总结 | JavaGuide</a></li>
<li><a href="https://blog.csdn.net/YeJingLiangZuo/article/details/139624021">Spring 启动顺序_spring启动流程-CSDN博客</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 集合</title>
    <url>/post/5e788cc1/</url>
    <content><![CDATA[<p>Java 集合，也叫作容器，主要是由两大接口派生而来：</p>
<ul>
<li><code>Collection</code>：存放单一元素<ul>
<li><code>List</code>：列表，存储<strong>有序、可重复</strong>的元素</li>
<li><code>Set</code>：集合，存储<strong>不可重复</strong>的元素</li>
<li><code>Queue</code>：队列，按<strong>特定规则</strong>来确定元素顺序</li>
</ul>
</li>
<li><code>Map</code>：存储<code>Entry</code>键值对</li>
</ul>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>使用 <code>Object[]</code> 数组来存储元素</p>
<h3 id="grow-流程"><a href="#grow-流程" class="headerlink" title="grow 流程"></a><code>grow</code> 流程</h3><ol>
<li>判断当前 <code>elemenetData</code> 是否为默认空数组（未初始化）<ul>
<li>若<strong>是</strong>，则将其初始化为<strong>长度为 <code>minCapacity</code> 和 16（默认长度）的数组</strong></li>
<li>若<strong>否</strong>，则将长度扩容为<strong>原有长度的1.5倍和<code>minCapacity</code>的最大值</strong></li>
</ul>
</li>
</ol>
<h3 id="add-流程"><a href="#add-流程" class="headerlink" title="add 流程"></a><code>add</code> 流程</h3><p><strong>时间复杂度：$O(n)$</strong></p>
<ol>
<li>判断<strong>当前元素数量是否等于数组长度</strong><ul>
<li>若<strong>等于</strong>，则扩容（默认<code>minCapacity</code> 为原数组长度+1）</li>
</ul>
</li>
<li>将元素添加到数组尾部</li>
</ol>
<h3 id="remove-流程"><a href="#remove-流程" class="headerlink" title="remove 流程"></a><code>remove</code> 流程</h3><p><strong>时间复杂度：$O(n)$</strong></p>
<ol>
<li>判断要<code>remove</code>的元素是否为最后一个<ul>
<li>若<strong>否</strong>，则用<code>System.arraycopy</code>将<strong>待删除元素后的所有元素</strong>复制到<strong>待删除元素前面</strong></li>
</ul>
</li>
<li>将<strong>数组最后一位</strong>置为<code>null</code></li>
</ol>
<h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList"></a><code>Arrays.asList</code></h2><p>**使用该方法创建的 <code>List</code> 并不是 <code>ArrayList</code>**，而是 <code>Arrays</code> 的一个内部类 <code>ArrayList</code>，其不包含<code>add</code>和<code>remove</code>方法，只能调用<code>get</code>方法</p>
<p>同时其创建的<code>List</code>是<strong>对原数组的引用</strong>，如果修改原数组，其也会受到影响</p>
<p>若想将数组转为 <code>ArrayList</code>，可以使用 <code>new ArrayList&lt;&gt;(List.of(xxx))</code> 创建</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>双向链表</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><code>Vector</code>在很多方法上都加入了**<code>synchronized</code>关键字**，来保证线程的安全，如：<code>get,set,add,remove,equals,hashcode,toString,toArray...</code>等</p>
<p>也正是因为这一点，导致<code>Vector</code>效率低，不能和<code>ArrayList</code>相比</p>
<h3 id="底层数据结构-2"><a href="#底层数据结构-2" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>与<code>ArrayList</code>相同，都是使用<code>Object[]</code>来存储数据的，但是**<code>Vector</code>的默认容量是 10<strong>，且</strong><code>Vector</code>扩容到原来的 2 倍**</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="底层数据结构-3"><a href="#底层数据结构-3" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><strong>JDK1.7：</strong> 数组 + 链表</p>
<p><strong>JDK1.8及以后：</strong> 数组 + 链表 &#x2F; 红黑树</p>
<blockquote>
<p><strong>链表 &#x3D;&gt; 红黑树：数组长度大于 64</strong> 且链表长度大于 <strong>8</strong></p>
<p><strong>红黑树 &#x3D;&gt; 链表：红黑树节点数量小于 6</strong> </p>
</blockquote>
<h3 id="resize-流程"><a href="#resize-流程" class="headerlink" title="resize 流程"></a><code>resize</code> 流程</h3><p>简单来说，扩容就是将数组容量变为原来的 2 倍，并且对旧数组中元素重新进行一次哈希计算，比较耗时</p>
<p>所以在使用 <code>HashMap</code> 时应<strong>尽可能避免扩容</strong></p>
<ol>
<li><p>判断<strong>原来的数组容量</strong>是否大于 0 </p>
<ul>
<li><p>若<strong>否</strong>，则初始化数组容量为 <strong>16</strong>、扩容阈值为 <strong>12</strong>，并创建新数组，结束流程</p>
</li>
<li><p>若<strong>是</strong>，判断<strong>原来的数组容量</strong>是否大于等于<strong>最大容量</strong>（$2^{30}$）</p>
<ul>
<li>若<strong>是</strong>，则将<strong>扩容阈值</strong>设为 $2^{31}-1$</li>
<li>若<strong>否</strong>，则判断当前长度 * 2 是否超出<strong>最大容量</strong><ul>
<li>若<strong>否</strong>，设定<strong>新数组容量</strong>为当前长度 * 2</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>根据<strong>新数组容量</strong>创建一个新数组</p>
</li>
<li><p>遍历旧数组中的每一个元素</p>
<ul>
<li>若元素为<strong>红黑树</strong>：进行红黑树添加</li>
<li>若元素为<strong>链表</strong><ul>
<li>遍历链表，判断元素的 $hash$ 值是否满足 $hash\ &amp;\ oldCap&#x3D;&#x3D;0$（$oldCap$ 为旧数组容量）<ul>
<li>若<strong>是</strong>，则将其移动到新数组中下标为 $i+oldCap$ （$i$ 为元素在旧数组中的下标）的位置上</li>
<li>若<strong>否</strong>，则将元素移动到新数组中下标为 $i$ 的位置上</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="put-流程"><a href="#put-流程" class="headerlink" title="put 流程"></a><code>put</code> 流程</h3><p><strong>时间复杂度：$O(1)$</strong></p>
<p><strong>调用 <code>put(key, value)</code> 的具体流程：</strong></p>
<ol>
<li>对传入的 $key$ 值进行哈希处理得到哈希值 $hash$</li>
<li>判断存储节点的 $table$ 是否为空<ul>
<li>若<strong>为空</strong>，则调用 <code>resize()</code> 方法初始化一个长度为 <strong>16</strong> 的数组</li>
</ul>
</li>
<li>根据 $hash$ 取模计算出 $key$ 存放的下标 $i$</li>
<li>判断 $table[i]$ 是否为空<ul>
<li>若<strong>不为空</strong>，则判断 $table[i]$ 与传入值是否相同（$hash,key$）<ul>
<li>若<strong>相同</strong>，则覆盖 $table[i]$ 的 $value$</li>
<li>若<strong>不相同</strong>，则判断当前节点是否为红黑树<ul>
<li>若<strong>是红黑树</strong>，则调用红黑树插入方法插入新节点</li>
<li>若<strong>不是红黑树</strong>，则遍历链表判断 $key$ 是否存在<ul>
<li>若<strong>存在</strong>，则覆盖其 $value$</li>
<li>若<strong>不存在</strong>，则在链表尾部插入新节点，同时判断链表长度是否大于 <strong>8</strong><ul>
<li>若<strong>大于</strong>，则调用 <code>treeifyBin</code> 将链表转换为红黑树（若 $table$ 长度不足 <strong>64</strong> 则扩容而不是转换）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>若<strong>为空</strong>，直接插入到 $table[i]$</li>
</ul>
</li>
<li>判断插入后 $table$ 中键值对数量（包括冲突的）是否大于扩容阈值（数组容量 $\times$ 加载因子）<ul>
<li>若<strong>是</strong>，则调用 <code>resize()</code> 方法扩容数组</li>
</ul>
</li>
</ol>
<h3 id="get-流程"><a href="#get-流程" class="headerlink" title="get 流程"></a><code>get</code> 流程</h3><p><strong>时间复杂度：$O(1)$</strong></p>
<p><strong>调用 <code>get(key)</code> 的具体流程：</strong></p>
<ol>
<li>对 <code>key</code> 哈希运算并取模当前 <code>table</code> 长度得到下标 <code>first</code></li>
<li>判断 <code>table[first]</code> 是否为空<ul>
<li>若<strong>不为空</strong>则判断当前节点哈希值和 <code>key</code> 是否相同<ul>
<li>若<strong>相同</strong>则返回该节点 <code>value</code></li>
<li>若<strong>不相同</strong>则根据该节点类型（链表或红黑树）查询到满足<strong>哈希值和<code>key</code>都相同的节点</strong>，并返回其<code>value</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>顾名思义，并发安全的 <code>HashMap</code>。使用 <strong>CAS</strong> + <strong>synchronized</strong> 来保证 <code>HashMap</code> 的并发安全</p>
<ul>
<li><strong>CAS</strong> 控制数组节点的添加</li>
<li><strong>synchronized</strong> 只锁定当前链表&#x2F;红黑树的首节点，只要插入的 key 的哈希值不冲突，就不会存在并发的问题，提高了效率</li>
</ul>
<blockquote>
<p><strong>为什么只有 HashMap 的键或值可以为空，而 Hashtable、ConcurrentHashMap不能</strong></p>
<ul>
<li><p><strong>代码层面：</strong>Hashtable 和 ConcurrentHashMap 在<code>put</code>时需要<strong>调用<code>key</code>对象的<code>hashcode()</code>方法</strong>，所以在此之前对键进行了空值判断（值也进行了判断，不清楚原因）</p>
</li>
<li><p><strong>设计层面：</strong>Hashtable 和 ConcurrentHashMap 都是<strong>线程安全</strong>的，其需要在<code>put</code>时判断键是否存在，如果允许键为 <code>null</code> 的话就<strong>无法判断对应键是 <code>null</code> 还是不存在</strong></p>
</li>
</ul>
</blockquote>
<h2 id="Collections-SynchronizedMap"><a href="#Collections-SynchronizedMap" class="headerlink" title="Collections.SynchronizedMap"></a>Collections.SynchronizedMap</h2><p>其内部维护了一个<strong>普通对象<code>Map m</code></strong> 和 <strong>互斥锁对象<code>Object mutex</code><strong>，<code>SynchronizedMap</code>提供了<code>get,put,remove</code>等基本方法，其原理是</strong>使用<code>synchronized</code>对原<code>Map</code>对象进行了一层封装</strong>以达到线程安全的目的</p>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>Hashtable 是线程安全的，因为其对每个方法都加了锁</p>
<p>Hashtable 不允许<strong>键或值为 <code>null</code></strong></p>
<p>默认的初始容量为 11，负载因子也是 0.75</p>
<h2 id="错误检测机制"><a href="#错误检测机制" class="headerlink" title="错误检测机制"></a>错误检测机制</h2><h3 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h3><p>在遍历集合时，不直接在集合内容上访问，而是先复制原有的集合内容，在拷贝的集合上进行遍历。这样就避免了<strong>其他线程修改集合结构对其造成的影响</strong>，但也<strong>无法读取到其他线程修改后的最新数据</strong></p>
<h3 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h3><p>即<strong>快速失败机制</strong>，当多个线程在遍历集合时，如果该集合的结构发生改变，则有可能触发 fail-fast，抛出<code>ConcurrentModificationException</code>异常</p>
<p>fail-fast 机制并不保证不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测 bug</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://www.cnblogs.com/jalja365/p/15592694.html">java 集合中的错误检测机制 - 徐知语的笔记 - 博客园 (cnblogs.com)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>1483. 树节点的第 K 个祖先</title>
    <url>/post/61d7fd40/</url>
    <content><![CDATA[<h1 id="1483-树节点的第-K-个祖先"><a href="#1483-树节点的第-K-个祖先" class="headerlink" title="1483. 树节点的第 K 个祖先"></a><a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/">1483. 树节点的第 K 个祖先</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="O-nlog-2n-O-log-2n-O-nlog-2n-O-1"><a href="#O-nlog-2n-O-log-2n-O-nlog-2n-O-1" class="headerlink" title="$O(nlog_2n)&#x2F;O(log_2n)+O(nlog_2n)&#x2F;O(1)$"></a>$O(nlog_2n)&#x2F;O(log_2n)+O(nlog_2n)&#x2F;O(1)$</h3><p>动态规划</p>
<p>设 $dp[i][j]$ 代表 $i$ 号节点的第 $2^j$ 个祖先。那么，$i$ 号节点的第 $2^j$ 个祖先就是 <strong>$i$ 号节点的第 $2^{j-1}$ 个祖先</strong>的第 $2^{j-1}$ 个祖先，所以有以下状态转移方程：</p>
<p>$$<br>dp[i][0]&#x3D;parent[i]\<br>dp[i][j]&#x3D;dp[dp[i][j-1]][j-1],(i\in[1,log_2n),j\in[0,n))<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeAncestor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> anc[<span class="number">50001</span>][<span class="number">16</span>];</span><br><span class="line">    <span class="comment">// nlogn</span></span><br><span class="line">    <span class="built_in">TreeAncestor</span>(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; par) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">16</span>;j++)</span><br><span class="line">                anc[i][j]=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            anc[i][<span class="number">0</span>]=par[i];</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                <span class="keyword">if</span>(anc[j][i<span class="number">-1</span>]!=<span class="number">-1</span>)</span><br><span class="line">                    anc[j][i]=anc[anc[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// logn</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthAncestor</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;k;k&gt;&gt;=<span class="number">1</span>,i++)</span><br><span class="line">            <span class="keyword">if</span>(k&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node=anc[node][i];</span><br><span class="line">                <span class="keyword">if</span>(node==<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TreeAncestor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TreeAncestor* obj = new TreeAncestor(n, parent);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getKthAncestor(node,k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>239. 滑动窗口最大值</title>
    <url>/post/58d1758d/</url>
    <content><![CDATA[<h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="O-n-O-k"><a href="#O-n-O-k" class="headerlink" title="$O(n)+O(k)$"></a>$O(n)+O(k)$</h3><p>滑动窗口 + 单调队列</p>
<p>固定一个长度为 $k$ 的滑动窗口，在滑动的过程中维护一个最大长度为 $k$ 的单调不增队列，队列中存储数组的下标</p>
<ul>
<li>把队列中比<strong>窗口左端</strong>小的下标删除</li>
<li>把队列中比<strong>窗口进入的数</strong>小的数都删除，然后将其推入队尾（能保证队首是<strong>最大值</strong>的下标）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">((<span class="type">int</span>)<span class="number">1e4</span>+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">len</span><span class="params">(nums.size())</span>,<span class="title">cnt</span><span class="params">(len-k+<span class="number">1</span>)</span></span>;</span><br><span class="line">	    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(cnt)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>-k,r=<span class="number">0</span>;r&lt;len;l++,r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()&amp;&amp;que.<span class="built_in">front</span>()&lt;l)</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()&amp;&amp;nums[que.<span class="built_in">back</span>()]&lt;nums[r])</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            que.<span class="built_in">push_back</span>(r);</span><br><span class="line">            <span class="keyword">if</span>(l&gt;=<span class="number">0</span>)</span><br><span class="line">                ans[l]=nums[que.<span class="built_in">front</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>力扣</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>滑动窗口</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/post/df2849ec/</url>
    <content><![CDATA[<h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="List-remove-函数重载调用错误"><a href="#List-remove-函数重载调用错误" class="headerlink" title="List.remove() 函数重载调用错误"></a><code>List.remove()</code> 函数重载调用错误</h2><p>如果声明了一个  <code>List&lt;Integer&gt;</code>  的列表的话，调用  <code>remove()</code> 会分不清你是要调用 <code>remove(Object obj)</code> 还是 <code>remove(int index)</code></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 并发编程</title>
    <url>/post/a73fb3d7/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><ul>
<li>通过新建一个<strong>Thread对象</strong>，并<strong>重载其run方法</strong>来创建一个进程</li>
<li>自定义Thread的子类，在其内部<strong>重载run方法</strong>，然后在外部通过创建自定义类来创建线程</li>
</ul>
<p>这两种方法都太”重”，<strong>不太适合</strong>在实际开发或其他应用场景中广泛使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.pringln(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>自定义一个<strong>实现Runnable接口</strong>的类，在其内部<strong>实现run方法</strong>。配合Thread使用</p>
<p>这种方法相较于Thread更”轻”，比较推荐使用这种方法来创建线程任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br></pre></td></tr></table></figure>

<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>和 Runnable 相似，也是自定义一个实现接口的类，区别是 Callable 可以<strong>返回数据</strong>，并且其需要配合<strong>FutureTask</strong>来使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Integer处填返回的数据类型（基元类的包装类）</span></span><br><span class="line">MyCallable <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以理解为FutureTask是带返回值的Thread</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br></pre></td></tr></table></figure>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>将需要使用多线程执行的任务封装为自定义的Runnable类，然后使用 <strong><code>Executors</code>静态方法</strong>或**<code>ThreadPoolExecutor</code>构造函数** 创建一个线程池。推荐使用<strong>构造函数</strong>来创建线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">2</span>,                          			<span class="comment">// corePoolSize: 核心线程数</span></span><br><span class="line">    <span class="number">7</span>,                                      <span class="comment">// maximumPoolSize: 最大线程数</span></span><br><span class="line">    <span class="number">10L</span>,                                    <span class="comment">// keepAliveTime: 超时时间</span></span><br><span class="line">    TimeUnit.NANOSECONDS,                   <span class="comment">// TimeUnit: 超时时间的单位</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>),   		<span class="comment">// BlockingQueue: 任务队列</span></span><br><span class="line">    Executors.defaultThreadFactory(),       <span class="comment">// ThreadFactory: 线程工厂</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()    <span class="comment">// RejectedExecutionHandler: 饱和/拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="Executors-自带线程池"><a href="#Executors-自带线程池" class="headerlink" title="Executors 自带线程池"></a>Executors 自带线程池</h2><p>用于创建线程池的**<code>Executors</code>静态方法**包括：</p>
<ul>
<li><code>newFixedThreadPool</code>：创建一个<strong>定长</strong>的线程池，可以控制线程的最大并发数，超出的线程会存在队列中等待<ul>
<li><strong>核心线程数</strong>与<strong>最大线程数</strong>相同，没有临时线程</li>
<li>阻塞队列是<code>LinkedBlockingQueue</code>，最大容量为<code>Integer.MAX_VALUE</code>，可能导致<strong>Out Of Memory</strong>（OOM）</li>
<li>适用于<strong>任务量已知、相对耗时</strong>的任务</li>
</ul>
</li>
<li><code>newSingleThreadExecutor</code>：创建一个<strong>单线程化</strong>的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照制定顺序执行<ul>
<li><strong>核心线程数</strong>与<strong>最大线程数</strong>都为 1</li>
<li>阻塞队列是<code>LinkedBlockingQueue</code>，最大容量为<code>Integer.MAX_VALUE</code>，可能导致OOM</li>
<li>适用于<strong>按序执行的任务</strong></li>
</ul>
</li>
<li><code>newCachedThreadPool</code>：创建一个<strong>可缓存</strong>线程池，若线程池长度超出处理需要，可以灵活地<strong>回收临时线程</strong>；若无法回收，则<strong>创建新临时线程</strong>执行任务<ul>
<li><strong>核心线程数</strong>为 0，<strong>最大线程数</strong>为<code>Integer.MAX_VALUE</code>，可能导致OOM</li>
<li>阻塞队列是<code>SynchronousQueue</code></li>
<li>适用于<strong>任务数比较密集</strong>，但<strong>每个任务执行时间较短</strong>的情况</li>
</ul>
</li>
<li><code>newScheduledThreadPool</code>：可以执行<strong>延迟任务</strong>的线程池，支持<strong>定时</strong>和<strong>周期性</strong>任务的执行<ul>
<li><strong>核心线程数</strong>自定义，<strong>最大线程数</strong>为<code>Integer.MAX_VALUE</code>，可能导致OOM</li>
<li>阻塞队列是<code>DelayedWorkQueue</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>此建议出自<strong>阿里开发手册《Java开发手册-嵩山版》</strong></p>
</blockquote>
<p>不推荐使用<code>Executors</code>来创建线程池，是因为每一种方法创建的线程池都有<strong>积压大量线程</strong>从而导致OOM的风险。使用<code>ThreadPoolExecutor</code>构造方法来创建线程池可以<strong>明确线程池的运行规则</strong>，避免<strong>资源耗尽</strong>的风险</p>
<h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><h3 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h3><p>一个线程池中主要工作的核心线程的数量</p>
<p>对于不同类型的任务，线程池的核心线程数（<code>corePoolSize</code>）的设置也不同，一般都和 CPU 的核心数 $N$ 有关</p>
<ul>
<li><strong>IO密集型任务：</strong>文件读写、DB读写、网络请求等，核心线程数设为 $2N+1$</li>
<li><strong>CPU密集型任务：</strong>数据计算、Bitmap转换等，核心线程数设为 $N+1$</li>
</ul>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul>
<li><code>ArrayBlockingQueue</code>：基于数组结构的<strong>有界阻塞队列</strong></li>
<li><code>LinkedBlockingQueue</code>：基于链表结构的<strong>有界阻塞队列</strong></li>
<li><code>DelayedWordQueue</code>：优先级队列，它可以保证每次出队的任务都是<strong>当前队列中执行时间最靠前</strong>的</li>
<li><code>SynchronousQueue</code>：不存储元素的阻塞队列，每个插入操作必须对应一个移出操作</li>
</ul>
<p><strong><code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>的区别：</strong></p>
<table>
<thead>
<tr>
<th align="center">ArrayBlockingQueue</th>
<th align="center">LinkedBlockingQueue</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>强制有界</strong></td>
<td align="center"><strong>默认无界</strong>，支持有界</td>
</tr>
<tr>
<td align="center">底层为<strong>数组</strong></td>
<td align="center">底层为<strong>链表</strong></td>
</tr>
<tr>
<td align="center"><strong>提前初始化</strong>Node数组</td>
<td align="center">是懒惰的，在<strong>创建节点时</strong>添加数据</td>
</tr>
<tr>
<td align="center">Node 是提前创建好的</td>
<td align="center">入队会生成新 Node</td>
</tr>
<tr>
<td align="center">一把锁</td>
<td align="center">两把锁（头尾）</td>
</tr>
</tbody></table>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>当线程池已经<strong>关闭</strong>或达到<strong>饱和</strong>（最大线程和阻塞队列都已满）状态时，新提交的任务会被拒绝，具体策略如下：</p>
<ol>
<li><code>AbortPolicy</code>：<strong>默认拒绝策略</strong>。需要拒绝任务时抛出 <code>RejectedExecutionException</code> 异常</li>
<li><code>CallerRunsPolicy</code>：直接在 <strong><code>execute</code> 方法的调用线程</strong> 中执行被拒绝的任务；如果线程池已经关闭，任务将被<strong>丢弃</strong></li>
<li><code>DiscardPolicy</code>：<strong>直接丢弃任务</strong></li>
<li><code>DiscardOldestPolicy</code>：丢弃队列中<strong>等待时间最长</strong>的任务，并执行当前提交的任务；如果线程池已经关闭，任务将被<strong>丢弃</strong></li>
</ol>
<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><ol>
<li><code>RUNNING</code>：<ul>
<li>线程池刚被创建时的状态，能够接受处理新任务</li>
</ul>
</li>
<li><code>SHUTDOWN</code>：<ul>
<li>线程池被关闭，不再接受新的任务；但会将原有的任务处理完</li>
<li>调用线程池的 <code>shutdown()</code> 方法后，线程池状态会立即变为 <code>SHUTDOWN</code></li>
</ul>
</li>
<li><code>STOP</code>：<ul>
<li>不再接受新任务；会中断所有正在处理的任务</li>
<li>调用线程池的 <code>shutdownNow()</code> 方法后，状态会变为 <code>STOP</code></li>
</ul>
</li>
<li><code>TIDYING</code>：<ul>
<li>线程池中线程都没了后，会变为 <code>TIDYING</code>，并调用 <code>terminated()</code> 方法</li>
</ul>
</li>
<li><code>TERMINATED</code>：<ul>
<li>线程池调用完成 <code>terminated()</code> 方法，彻底终止</li>
</ul>
</li>
</ol>
<h2 id="任务调度过程"><a href="#任务调度过程" class="headerlink" title="任务调度过程"></a>任务调度过程</h2><p>当向线程池提交一个任务时，会根据线程池不同的状态来调度提交的任务</p>
<ul>
<li><strong>核心线程未满：</strong>用核心线程执行任务</li>
<li><strong>核心线程已满：</strong><ul>
<li><strong>阻塞队列未满：</strong>放入阻塞队列中等待</li>
<li><strong>阻塞队列已满：</strong><ul>
<li><strong>核心线程数 &lt;&#x3D; 最大线程数：</strong>创建线程执行任务</li>
<li><strong>核心线程数 &gt; 最大线程数：</strong>触发拒绝策略，拒绝该任务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>总是假设<strong>最好的情况</strong>，即共享资源在访问时<strong>不会出问题</strong>，因此无需给共享资源加锁或等待</p>
<p>乐观锁的实现方式一般为使用<strong>版本号</strong>确定数据的状态，若读取数据时与线程中数据版本不一致，则获取最新版本的数据</p>
<p><strong>常见的乐观锁的实现有：</strong>CAS、MySQL 的 MVCC（多版本并发控制）等</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>总是假设<strong>最坏的情况</strong>，即共享资源在访问时<strong>会出问题</strong>，因此在获取共享资源时会加锁或等待</p>
<p><strong>常见的悲观锁的实现有：</strong>synchronized、ReentrantLock等</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS（<strong>C</strong>ompare <strong>A</strong>nd <strong>S</strong>wap），即对比交换。基于<strong>乐观锁</strong>的思想，在每一次获取线程的<strong>共享资源</strong>时，先比对线程的工作内存中<strong>共享资源副本</strong>是否与<strong>共享资源</strong>相同</p>
<ul>
<li>若相同，则将新的数据与共享资源的数据交换</li>
<li>若不相同，则读取共享资源的数据，并再次比对是否相同，直到相同为止（<strong>自旋锁</strong>）</li>
</ul>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>synchronized 用于<strong>修饰一个方法</strong>或<strong>用做特定代码块</strong></p>
<ul>
<li><strong>修饰方法：</strong>表示将方法所在的对象作为<strong>对象锁</strong>，对该方法进行加锁保护</li>
<li><strong>代码块：</strong>将代码块中的对象作为<strong>对象锁</strong>，对该代码块进行加锁保护</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronized关键字需要锁定一个对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(LOCK) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread1 running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(LOCK) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread2 running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>底层由 <strong>Monitor</strong> 实现，Monitor 是 <strong>JVM 级别</strong>的对象（用C++实现），线程获取锁需要使用对象（锁）关联 Monitor</p>
<p><strong>在 Monitor 中有三个属性：</strong></p>
<ul>
<li><strong>owner：</strong>关联获取到锁的线程，并且只能关联一个线程</li>
<li><strong>entrylist：</strong>关联的是处于<strong>阻塞状态</strong>（BLOCKED）的线程</li>
<li><strong>waitset：</strong>关联的是出于<strong>等待状态</strong>（WAITING）的线程</li>
</ul>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>Monitor 实现的锁属于<strong>重量级锁</strong>，其中涉及到<strong>用户态和内核态的切换</strong>、<strong>进程的上下文切换</strong>，成本较高，性能较低</p>
<p>在<strong>JDK1.6</strong>引入了<strong>偏向锁</strong>和<strong>轻量级锁</strong>，他们的引入是为了解决在<strong>没有多线程竞争</strong>或<strong>基本没有竞争</strong>的场景中因使用传统锁带来的<strong>性能开销问题</strong></p>
<p><strong>HotSpot虚拟机中，对象头中的Mark Word：</strong></p>
<table style="text-align: center">
    <tr>
        <th colspan="5">Mark Word（32bit）</th>
        <th>状态</th>
    </tr>
    <tr>
        <td colspan="2">hashcode : 25</td>
        <td>age : 4</td>
        <td>biased_lock : 0</td>
        <td>01</td>
        <td>无锁</td>
    </tr>
    <tr>
        <td>thread : 23</td>
        <td>epoch : 2</td>
        <td>age : 4</td>
        <td>biased_lock : 1</td>
        <td>01</td>
        <td>偏向锁</td>
    </tr>
    <tr>
        <td colspan="4">ptr_to_lock_record : 30</td>
        <td>00</td>
        <td>轻量级锁</td>
    </tr>
    <tr>
        <td colspan="4">ptr_to_heavyweight_monitor : 30</td>
        <td>10</td>
        <td>重量级锁</td>
    </tr>
    <tr>
        <td colspan="4"></td>
        <td>11</td>
        <td>标记为GC</td>
    </tr>
</table>

<ul>
<li><strong>hashcode：</strong>对象标识的Hash码，<strong>占25位</strong></li>
<li><strong>age：</strong>对象分代年龄，<strong>占4位</strong></li>
<li><strong>biased lock：</strong>偏向锁标识，<strong>占1位</strong>，0表示没有开启偏向锁，1表示开启了偏向锁</li>
<li><strong>thread：</strong>持有偏向锁的线程ID，<strong>占23位</strong></li>
<li><strong>epoch：</strong>偏向时间戳，<strong>占2位</strong></li>
<li><strong>ptr_to_lock_record：</strong>轻量级锁状态下，指向栈中锁记录的指针，<strong>占30位</strong></li>
<li><strong>ptr_to_heavyweight_monitor：</strong>重量级锁状态下，指向对象监视器Monitor的指针，<strong>占30位</strong></li>
</ul>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>加锁时<strong>对象锁</strong>的<strong>对象头中Mark Word的ptr_to_heavyweight_monitor指针</strong>指向<strong>Monitor对象</strong></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>加锁流程：</strong></p>
<ol>
<li>在线程栈中创建一个 Lock Record（包含地址和对象引用Object Reference），将其对象引用<strong>指向对象锁</strong></li>
<li>使用CAS指令，将<strong>Lock Record的地址</strong>存储在<strong>对象锁</strong>的Mark Word中（ptr_to_lock_record），若<strong>对象锁</strong>处于无锁状态则修改成功，该线程获得了轻量级锁</li>
<li>若当前线程已经持有了该锁，则此次加锁是一次<strong>锁重入</strong>。设置Lock Record的地址为 null（对象引用仍然指向<strong>对象锁</strong>），起到对重入次数计数的作用</li>
<li>如果<strong>CAS修改失败</strong>，说明有其他线程在<strong>竞争锁</strong>，需要膨胀为<strong>重量级锁</strong></li>
</ol>
<p><strong>解锁流程：</strong></p>
<ol>
<li>遍历线程栈，找到所有<strong>对象引用指向当前对象锁</strong>的Lock Record</li>
<li>若Lock Record的地址为 null，则代表这是一次重入，将对象引用设为null后继续</li>
<li>若Lock Record的地址不为 null，则利用CAS指令将<strong>对象锁</strong>的Mark Word恢复为无锁状态，若失败则膨胀为<strong>重量级锁</strong></li>
</ol>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时，每次<strong>重入锁</strong>时仍需要执行CAS操作，偏向锁就是针对轻量级锁的这一点进行了优化</p>
<p>在第一次加锁时，CAS操作仅将<strong>对象锁</strong>的Mark Word中的<strong>biased_lock</strong>置为1，并且存储<strong>当前线程的ID</strong>（23位thread）；在以后得重入过程中，仅判断重入的<strong>线程ID是否相同</strong>即可</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile用于修饰<strong>类中的成员变量或静态成员变量</strong>，其具备两层语义：</p>
<ol>
<li><strong>保证线程间的可见性</strong><ul>
<li><strong>可见性：</strong>指当一个线程修改了共享变量的值后，其他线程能够得知这个修改</li>
</ul>
</li>
<li><strong>禁止进行指令重排序</strong><ul>
<li><strong>指令重排序：</strong>指当代码行之间如果不存在<strong>数据依赖</strong>，则JVM有可能对这些代码行进行重排序，所以在执行时不一定按照<strong>代码行的顺序</strong>执行代码</li>
</ul>
</li>
</ol>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS（<strong>A</strong>bstract <strong>Q</strong>ueued <strong>S</strong>ynchronizer），即抽象队列同步器。是构建锁或其他同步组件的基础框架</p>
<p><strong>AQS与synchronized的区别：</strong></p>
<table>
<thead>
<tr>
<th align="center">synchronized</th>
<th align="center">AQS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关键字，C++语言实现，JVM级别</td>
<td align="center">Java语言实现，API级别</td>
</tr>
<tr>
<td align="center">悲观锁，自动释放锁</td>
<td align="center">悲观锁，手动开启与关闭</td>
</tr>
<tr>
<td align="center">锁竞争激烈都是重量级锁，性能差</td>
<td align="center">锁竞争激烈的情况下，提供了多种解决方案</td>
</tr>
</tbody></table>
<p>AQS常见的实现类：</p>
<ul>
<li><strong>ReentrantLock：</strong>可重入锁</li>
<li><strong>Semaphore：</strong>信号量</li>
<li><strong>CountDownLatch：</strong>倒计时锁</li>
</ul>
<h2 id="基本工作机制"><a href="#基本工作机制" class="headerlink" title="基本工作机制"></a>基本工作机制</h2><ol>
<li>线程使用CAS指令设置<strong>被volatile修饰的state变量</strong>，判断其是否为1（0为无锁，1为有锁）<ul>
<li>若<strong>是</strong>，则将其置为0，获取锁成功，结束</li>
<li>若<strong>否</strong>，则进入由<strong>双向链表</strong>实现的队列的队尾进行等待</li>
</ul>
</li>
</ol>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>支持<strong>公平锁</strong>和<strong>非公平锁</strong>、锁重入、锁打断、条件锁等功能</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://www.cnblogs.com/andy1234/p/17849689.html">线程池拒绝策略详解 - 爱喝茶的安迪 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/m0_61916154/article/details/138533565">线程池的五种状态_线程池状态-CSDN博客</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>473. 火柴拼正方形</title>
    <url>/post/98579bd6/</url>
    <content><![CDATA[<h1 id="473-火柴拼正方形"><a href="#473-火柴拼正方形" class="headerlink" title="473. 火柴拼正方形"></a><a href="https://leetcode.cn/problems/matchsticks-to-square/">473. 火柴拼正方形</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="O-4-n-O-1"><a href="#O-4-n-O-1" class="headerlink" title="$O(4^n)+O(1)$"></a>$O(4^n)+O(1)$</h3><p>逆序排序后，深度优先搜索判断火柴放到 $i,(i\in[0,3])$ 号桶会不会溢出（桶的容量为火柴长度之和 &#x2F; 4），若会则放到下一个桶中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len,tar,sqr[<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ms,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">                <span class="keyword">if</span>(sqr[i]!=tar)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ms[x]+sqr[i]&gt;tar)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            sqr[i]+=ms[x];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(ms,x+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            sqr[i]-=ms[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">makesquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ms)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len=ms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;sum+=ms[i++]);</span><br><span class="line">        <span class="keyword">if</span>(sum&amp;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        tar=sum&gt;&gt;<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">sort</span>(ms.<span class="built_in">begin</span>(),ms.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(ms,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="O-n-times-2-n-O-n"><a href="#O-n-times-2-n-O-n" class="headerlink" title="$O(n\times{2^n})+O(n)$"></a>$O(n\times{2^n})+O(n)$</h3><p>动态规划 + 状态压缩</p>
<p>设 $dp[i]$ 为状态 $i$ 时正方形中<strong>未放满的边</strong>的当前长度，其中状态 $i$ 记录哪些火柴已经放入（$i$ 的二进制下第 $k$ 位为1则表示第 $k$ 根火柴已放入），有以下状态转换方程：<br>$$<br>dp[0]&#x3D;0\<br>i_1\ 表示\ i\ 状态下去掉第\ k\ 根火柴的状态\<br>dp[i]&#x3D;-1,(dp[i_1]&lt;0)\<br>dp[i]&#x3D;(dp[i_1]+matchsticks[k])\ mod\ len,(dp[i_1]&gt;&#x3D;0)<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">N</span><span class="params">(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[N];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">makesquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ms)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">len</span><span class="params">(ms.size())</span>,<span class="title">bd</span><span class="params">(<span class="number">1</span>&lt;&lt;len)</span>,<span class="title">tar</span><span class="params">(accumulate(ms.begin(),ms.end(),<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 不为4的倍数则说明无解</span></span><br><span class="line">        <span class="keyword">if</span>(tar&amp;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        tar&gt;&gt;=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,bd&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;bd;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 左移 j 位 表示放第 j 个火柴时的状态</span></span><br><span class="line">                <span class="type">int</span> t,<span class="built_in">k</span>(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                <span class="keyword">if</span>(i&amp;k==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 异或可以将二进制第 j 位置为 0</span></span><br><span class="line">                <span class="comment">// 1101 ^ 0100 =&gt; 1001</span></span><br><span class="line">                t=i^k;</span><br><span class="line">                <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(dp[t]+ms[j])</span></span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[t]!=<span class="number">-1</span>&amp;&amp;sum&lt;=tar)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=(sum==tar?<span class="number">0</span>:sum);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 二进制全为 1 的状态 即火柴全部放入</span></span><br><span class="line">        <span class="keyword">return</span> dp[bd<span class="number">-1</span>]==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>力扣</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>LCR 170. 交易逆序对的总数</title>
    <url>/post/719e6679/</url>
    <content><![CDATA[<h1 id="LCR-170-交易逆序对的总数-力扣（LeetCode）"><a href="#LCR-170-交易逆序对的总数-力扣（LeetCode）" class="headerlink" title="LCR 170. 交易逆序对的总数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/">LCR 170. 交易逆序对的总数 - 力扣（LeetCode）</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="O-n-2-O-1"><a href="#O-n-2-O-1" class="headerlink" title="$O(n^2)+O(1)$"></a>$O(n^2)+O(1)$</h3><p>遍历数组，对于每个元素都再次遍历数组求当前元素的逆序对数量并求和</p>
<h3 id="O-nlog-2n-O-n"><a href="#O-nlog-2n-O-n" class="headerlink" title="$O(nlog_2n)+O(n)$"></a>$O(nlog_2n)+O(n)$</h3><p>在归并排序的<strong>合并数组</strong>操作中，左数组在原数组的下标一定是小于右数组的</p>
<p>所以对于左数组中的每一个元素 $x$ 来说，如果右数组中有 $n_x$ 个小于 $x$ 的元素，就说明此次合并中有 $n_x$ 个逆序对，记录所有合并操作时的 $\sum{n_x}(x\in{arr_{left}})$ 求和，即为一个数组的所有逆序对的数量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> tmp[<span class="number">50001</span>],len;</span><br><span class="line">    <span class="comment">// 合并操作</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> f;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">mn</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">gap</span><span class="params">(r-l)</span>,p[2]</span>=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(p[<span class="number">0</span>]&lt;gap&amp;&amp;p[<span class="number">1</span>]&lt;gap&amp;&amp;r+p[<span class="number">1</span>]&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[l+p[<span class="number">0</span>]]&gt;arr[r+p[<span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">            	tmp[p[<span class="number">0</span>]+p[<span class="number">1</span>]]=arr[r+p[<span class="number">1</span>]];</span><br><span class="line">                p[<span class="number">1</span>]++;</span><br><span class="line">                mn++;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            	tmp[p[<span class="number">0</span>]+p[<span class="number">1</span>]]=arr[l+p[<span class="number">0</span>]];</span><br><span class="line">                p[<span class="number">0</span>]++;</span><br><span class="line">            	res+=mn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p[<span class="number">0</span>]&lt;gap||p[<span class="number">1</span>]&lt;gap)</span><br><span class="line">		&#123;</span><br><span class="line">			f=p[<span class="number">0</span>]&gt;=gap;</span><br><span class="line">			<span class="keyword">while</span>(p[f]&lt;gap)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(f)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(r+p[<span class="number">1</span>]&gt;=len)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">            		tmp[p[<span class="number">0</span>]+p[<span class="number">1</span>]]=arr[r+p[<span class="number">1</span>]];</span><br><span class="line">                    p[<span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="keyword">else</span></span><br><span class="line">            	&#123;</span><br><span class="line">            		tmp[p[<span class="number">0</span>]+p[<span class="number">1</span>]]=arr[l+p[<span class="number">0</span>]],p[<span class="number">0</span>]++;</span><br><span class="line">					res+=mn;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		gap&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gap&amp;&amp;i+l&lt;len;i++)</span><br><span class="line">            arr[l+i]=tmp[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rec)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        len=rec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> g=<span class="number">1</span>;g&lt;len;g&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i+=(g&lt;&lt;<span class="number">1</span>))</span><br><span class="line">                ans+=<span class="built_in">merge</span>(rec,i,i+g);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>/post/baccfad/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="表达式的执行顺序不同"><a href="#表达式的执行顺序不同" class="headerlink" title="++表达式的执行顺序不同"></a>++表达式的执行顺序不同</h2><p>编译器版本不同，编译出的最终效果不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span>,p[2]</span>=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,x[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    x[p[<span class="number">0</span>]]=x[p[<span class="number">0</span>]++];</span><br><span class="line">    <span class="comment">// 其他 : 1 1</span></span><br><span class="line">    <span class="comment">// tdm-gcc4.9.2 : 1 2</span></span><br><span class="line">    cout&lt;&lt;x[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    x[<span class="number">0</span>]=<span class="number">1</span>,x[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    x[a]=x[a++];</span><br><span class="line">    <span class="comment">// 但这种写法都是输出 : 1 1 </span></span><br><span class="line">    cout&lt;&lt;x[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/post/bae4ff13/</url>
    <content><![CDATA[<p>Redis 全称 <strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver，是完全开源免费的，使用C语言编写的，遵守BSD协议，是一个高性能的 (key&#x2F;value) 分布式内存数据库，基于内存运行并支持持久化的 NoSQL 数据库</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="Redis的速度快"><a href="#Redis的速度快" class="headerlink" title="Redis的速度快"></a>Redis的速度快</h2><ul>
<li>Redis完全基于内存操作，内存访问速度比磁盘快</li>
<li>单线程，单线程相较于多线程，减少了CPU在切换线程时的上下文切换操作</li>
<li>使用I&#x2F;O多路复用模型，非阻塞IO</li>
</ul>
<h2 id="Redis的缓存穿透、击穿和雪崩"><a href="#Redis的缓存穿透、击穿和雪崩" class="headerlink" title="Redis的缓存穿透、击穿和雪崩"></a>Redis的缓存穿透、击穿和雪崩</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>是指用户请求<strong>不存在的数据</strong>，导致缓存未命中从而查询数据库，但数据库也没有查到数据</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器通过一个<strong>比特位数组</strong>来存储元素的状态（是否存在）</p>
<ul>
<li><strong>插入数据：</strong>使用多个哈希函数对元素进行哈希计算，将得出的哈希值对应下标位为1</li>
<li><strong>查询数据：</strong>对元素进行哈希计算后，判断所有哈希值对应下标位是否都为1，都为1则存在</li>
</ul>
<p>由于可能存在哈希值冲突的情况，所以会有<strong>误判存在</strong>的可能，但若判定不存在则<strong>一定不存在</strong></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><strong>缓存空数据：</strong>当请求到不存在的数据时缓存一份空数据在Redis中<ul>
<li>实现简单；占用内存大</li>
</ul>
</li>
<li><strong>布隆过滤器：</strong>在查询Redis缓存之前先访问布隆过滤器，若布隆过滤器中不存在该数据则直接返回<ul>
<li>布隆过滤器会误判，但误判率较低、实现复杂；占用内存小</li>
</ul>
</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>一些<strong>热点key过期</strong>时刚好有<strong>大量并发请求</strong>，这些请求由于没有命中缓存同时请求数据库，可能导致数据库崩溃</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><strong>互斥锁：</strong>当存在多个请求相同数据的线程需要查询数据库时，使用互斥锁允许一个线程写入，其他线程阻塞<strong>等待写入完成</strong>再获取数据<ul>
<li>数据一致性<strong>强</strong>；性能<strong>差</strong></li>
</ul>
</li>
<li><strong>逻辑过期：</strong>数据写入缓存时添加一个<strong>过期时间</strong>字段；当线程命中缓存发现缓存过期后，获取互斥锁后<strong>开启新线程</strong>查询数据库写入缓存并更新缓存中的过期时间，而后主线程返回<strong>过期数据</strong>；其他线程获取互斥锁失败则直接返回过期数据<ul>
<li>数据一致性<strong>弱</strong>；性能<strong>好</strong></li>
</ul>
</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>Redis中<strong>大量缓存过期失效</strong>或<strong>宕机</strong>，使得大量请求到达数据库，可能导致数据库崩溃</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>给缓存的过期时间（TTL）<strong>增加随机值</strong>，防止同时过期</li>
<li>组建<strong>Redis集群</strong>提高可用性</li>
<li>缓存服务<strong>降级限流</strong>策略</li>
</ul>
<h2 id="Redis实现双写一致"><a href="#Redis实现双写一致" class="headerlink" title="Redis实现双写一致"></a>Redis实现双写一致</h2><p><strong>双写一致性：</strong>缓存与数据库中的数据的一致性</p>
<h3 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h3><ul>
<li><strong>读操作：</strong>使用<strong>互斥锁</strong>或<strong>逻辑过期</strong>来实现缓存过期时查询数据库更新缓存</li>
<li><strong>写操作：延迟双删</strong>保证数据一致性</li>
</ul>
<p>先删除缓存，再写入数据库，写入的同时<strong>延迟删除缓存</strong></p>
<blockquote>
<p><strong>延迟删除缓存的原因：</strong>尽可能防止数据库数据未修改前，有线程因为未命中缓存而查询数据库，将<strong>脏数据</strong>写入了缓存中</p>
</blockquote>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>由读写锁保证，有线程写操作<strong>不允许</strong>其他线程读写操作；<strong>允许</strong>多个线程共同读操作</p>
<h3 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h3><ul>
<li><strong>消息队列（Message Queue）：</strong>业务再<strong>写入数据库同时</strong>发送消息到消息队列通知<strong>缓存服务</strong>更新缓存</li>
<li><strong>Canel：</strong>Canel<strong>监听mysql的binlog日志</strong>，若数据改变则通知缓存服务更新缓存</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p> <a href="https://redis.io/download/">Download | Redis</a> 官网下载即可</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h2 id="CLI-操作"><a href="#CLI-操作" class="headerlink" title="CLI 操作"></a>CLI 操作</h2><blockquote>
<p>参考教程： <a href="https://blog.csdn.net/sinat_20471177/article/details/132043998">使用redis-cli操作redis_rediscli连接redis-CSDN博客</a> </p>
</blockquote>
<ul>
<li>cli中的操作不区分大小写</li>
<li>中括号内为可选参数</li>
</ul>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试连接</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ping</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定数据库</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">select</span> <span class="number">0</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="键（key）"><a href="#键（key）" class="headerlink" title="键（key）"></a>键（key）</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置键值对  存在则覆盖</span></span><br><span class="line"><span class="comment"># set key value</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> number <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置多个键值对  字符串不冲突的话不加引号也行</span></span><br><span class="line"><span class="comment"># mset key1 value1 key2 value2 ...</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; mset a <span class="string">&quot;test&quot;</span> b <span class="string">&quot;test&quot;</span> c <span class="string">&quot;test&quot;</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找符合正则表达式的键</span></span><br><span class="line"><span class="comment"># keys pattern</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取键的值  空返回(nil)</span></span><br><span class="line"><span class="comment"># get key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; get a</span><br><span class="line"><span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取多个键的值</span></span><br><span class="line"><span class="comment"># mget key1 key2 ...</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; mget a b</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取键的旧值设置新值</span></span><br><span class="line"><span class="comment"># getset key value</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; getset a test2</span><br><span class="line"><span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化键的值</span></span><br><span class="line"><span class="comment"># dump key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; dump a</span><br><span class="line"><span class="string">&quot;\x00\x04test\x06\x00\x17&#125;\xc7 \x99\xa4\x8c\xd6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 键是否存在 是返回1 否返回0</span></span><br><span class="line"><span class="comment"># exists key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; exists d</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看键类型  不存在返回none</span></span><br><span class="line"><span class="comment"># type key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">type</span> a</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名键</span></span><br><span class="line"><span class="comment"># rename key newkey</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rename a d</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置键过期时间</span></span><br><span class="line"><span class="comment"># expire key seconds</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; expire d <span class="number">60</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看键过期时间</span></span><br><span class="line"><span class="comment"># ttl key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ttl d</span><br><span class="line">(integer) <span class="number">54</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除键过期时间 变持久存在</span></span><br><span class="line"><span class="comment"># persist key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; persist d</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除键 返回删除了的数量</span></span><br><span class="line"><span class="comment"># del key1 key2 ...</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">del</span> a b c d</span><br><span class="line">(integer) <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h3><figure class="highlight plaintext"><figcaption><span>mset get mget getset``` 与[操作键](#操作键（key）)一样</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```powershell</span><br><span class="line"># 获取键的字符串值长度</span><br><span class="line"># strlen key</span><br><span class="line">127.0.0.1:6379&gt; strlen a</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line"># 截取键的字符串值[start,end]下标范围的子字符串（-1表示末尾下标）</span><br><span class="line"># getrange key start end</span><br><span class="line">127.0.0.1:6379&gt; getrange a 0 1</span><br><span class="line">&quot;te&quot;</span><br><span class="line"></span><br><span class="line"># 以下标offset为起点逐字符替换键的字符串值  返回替换后的长度</span><br><span class="line"># setrange key offset value</span><br><span class="line">127.0.0.1:6379&gt; setrange a 0 &quot;abc&quot;</span><br><span class="line">(integer) 4 # test -&gt; abct</span><br><span class="line">127.0.0.1:6379&gt; setrange a 0 &quot;abcde&quot;</span><br><span class="line">(integer) 5 # abct -&gt; abcde</span><br><span class="line"></span><br><span class="line"># 为键的字符串值追加内容</span><br><span class="line"># append key value</span><br><span class="line">127.0.0.1:6379&gt; append a &quot;t&quot;</span><br><span class="line">(integer) 6 # abcde -&gt; abcdet</span><br></pre></td></tr></table></figure>

<h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><blockquote>
<p>注意：非列表类型键无法进行列表操作</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将多个元素推入键的列表值左/右端（不存在则创建）  返回列表的长度</span></span><br><span class="line"><span class="comment"># lpush/rpush key value</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush d test</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; rpush d test2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看键的列表值中[start,end]下标范围内元素</span></span><br><span class="line"><span class="comment"># lrange key start end</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange d <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取键的列表值中下标为index的元素</span></span><br><span class="line"><span class="comment"># lindex key index</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lindex d <span class="number">1</span></span><br><span class="line"><span class="string">&quot;test2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看键的列表值的长度</span></span><br><span class="line"><span class="comment"># llen key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; llen d</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除键的列表值的左/右端元素  返回其值</span></span><br><span class="line"><span class="comment"># lpop/rpop key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpop d</span><br><span class="line"><span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除|count|个键的列表值中的值为value的元素  返回删除的数量</span></span><br><span class="line"><span class="comment"># lrem key count value（count&gt;0从右端开始，count&lt;0从左端开始，count=0删除所有相同元素）</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange e <span class="number">0</span> <span class="literal">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;t2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;t&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;t&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;t&quot;</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrem e <span class="literal">-1</span> <span class="string">&quot;t&quot;</span></span><br><span class="line">(integer) <span class="number">1</span> <span class="comment"># t2 t t</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrem e <span class="number">0</span> <span class="string">&quot;t&quot;</span></span><br><span class="line">(integer) <span class="number">2</span> <span class="comment"># t2</span></span><br></pre></td></tr></table></figure>

<h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><blockquote>
<p>集合中不能存在相同元素</p>
<p>注意：同列表</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加多个元素到键的集合值中（没则创建）  返回添加成功数量</span></span><br><span class="line"><span class="comment"># sadd key member1 member2 ...</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd a <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看键的集合值元素数量</span></span><br><span class="line"><span class="comment"># scard key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; scard a</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 键的集合值中是否存在元素member  是1否0</span></span><br><span class="line"><span class="comment"># sismember key member</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sismember a <span class="number">1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除键的集合值中多个元素  返回移除成功数量</span></span><br><span class="line"><span class="comment"># srem key member1 member2 ...</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; srem a <span class="number">1</span> <span class="number">4</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把元素member从source的集合值移动到target的集合值中  返回移动成功数量</span></span><br><span class="line"><span class="comment"># smove source target member</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smove a b <span class="number">1</span> <span class="comment"># b = &#123;1&#125;</span></span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="散列（hash）"><a href="#散列（hash）" class="headerlink" title="散列（hash）"></a>散列（hash）</h3><blockquote>
<p>Hash 中可保存多个键值对</p>
<p>注意：同列表</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置键的散列值的键值对（没则创建散列）</span></span><br><span class="line"><span class="comment"># hset key field value</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hset a a <span class="number">1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置键的散列值的多个键值对</span></span><br><span class="line"><span class="comment"># hmset key field1 value1 field2 value2 ...</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hmset a b <span class="number">1</span> c <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取键的散列值指定键的值</span></span><br><span class="line"><span class="comment"># hget key field</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hget a a</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取键的散列值多个指定键的值</span></span><br><span class="line"><span class="comment"># hmget key field1 field2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hmget a a b</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取键的散列值的所有键和值</span></span><br><span class="line"><span class="comment"># hgetall key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hgetall a</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取键的散列值的所有键/值</span></span><br><span class="line"><span class="comment"># hkeys/hvals key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hkeys a</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除键的散列值的指定键和其值  返回删除成功数量</span></span><br><span class="line"><span class="comment"># hdel key field1 field2</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; hdel a a b</span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="有序集合（sorted-sets-zset）"><a href="#有序集合（sorted-sets-zset）" class="headerlink" title="有序集合（sorted sets &#x2F; zset）"></a>有序集合（sorted sets &#x2F; zset）</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为键的有序集合值添加多个键值对（没则创建集合）  返回添加成功数量</span></span><br><span class="line"><span class="comment"># zadd key [NX|XX] [CH] [INCR] score1 member1 score2 member2 ...</span></span><br><span class="line"><span class="comment"># 其中score为分值 member为元素</span></span><br><span class="line"><span class="comment"># [NX|XX]	NX表示不只添加新元素 XX表示不添加新元素</span></span><br><span class="line"><span class="comment"># [CH] 		表示返回发生变化的元素总数</span></span><br><span class="line"><span class="comment"># [INCR]	表示指定元素按照分值进行递增操作</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd a <span class="number">100</span> <span class="string">&quot;a&quot;</span> <span class="number">101</span> <span class="string">&quot;b&quot;</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取键的有序集合值内元素数量</span></span><br><span class="line"><span class="comment"># zcard key</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zcard a</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计键的有序集合值中[min,max]分值范围的元素数量</span></span><br><span class="line"><span class="comment"># zcount key min max</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zcount a <span class="number">100</span> <span class="number">100</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 升/降序获取键的有序集合值[min,max]分值范围内元素</span></span><br><span class="line"><span class="comment"># [withscores]	显示分值</span></span><br><span class="line"><span class="comment"># zrangebyscore/zrevrangebyscore key min max [withscores]</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrangebyscore a <span class="number">100</span> <span class="number">100</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 升/降序获取键的有序集合值[start,end]下标范围内元素</span></span><br><span class="line"><span class="comment"># zrange/zrevrange key start end [withscores]（同上）</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange a <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元素member在键的有序集合值中排名</span></span><br><span class="line"><span class="comment"># zrank key member</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrank a b</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取键的有序集合值指定元素的分值</span></span><br><span class="line"><span class="comment"># zscore key member</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zscore a <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加键的有序集合值指定元素的分值</span></span><br><span class="line"><span class="comment"># zincrby key score member</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zincrby a <span class="number">10</span> b</span><br><span class="line"><span class="string">&quot;111&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除键的有序集合值中的多个元素</span></span><br><span class="line"><span class="comment"># zrem key member1 member2 ...</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrem a <span class="string">&quot;a&quot;</span> <span class="string">&quot;b&quot;</span></span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1>]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/post/69c3279c/</url>
    <content><![CDATA[<p>记录一些使用 Git 的一些出现过的问题和有用的经验</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><h2 id="清空分支"><a href="#清空分支" class="headerlink" title="清空分支"></a>清空分支</h2><p>新建分支的话需要选择一个源分支，会导致分支不是空的</p>
<p>我使用到的办法是把仓库中的文件克隆到另一个本地上，再用 <code>git rm -rf .</code> 指令清空本地仓库的所有文件；然后 <code>git commit -m [提交的提示信息]</code> + <code>git push -f [本地分支名] [远程分支名]</code> 覆盖掉分支以达到清空分支的目的</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/post/d32d37e5/</url>
    <content><![CDATA[<p>ElasticSearch（简称 ES）是一个开源的、高扩展的、分布式的、提供多用户能力的<strong>全文搜索引擎</strong>，是基于 <strong>Apache Lucene</strong> 库实现的，可以<strong>近实时</strong>地存储和搜索数据</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><blockquote>
<p>7.x以前的版本是一个Index多个Type，7.x及之后是一个Index一个Type</p>
</blockquote>
<p><strong>官网下载：</strong> <a href="https://www.elastic.co/cn/downloads/elasticsearch">Download Elasticsearch | Elastic</a> </p>
<p>安装完按需安装分词器，基本含中文都建议装IK分词器插件（分词器版本要和ES版本一样）</p>
<p><strong>IK分词器仓库地址：</strong>  <a href="https://github.com/infinilabs/analysis-ik/releases">Releases · infinilabs&#x2F;analysis-ik (github.com)</a> </p>
<p>剩余的如果需要配置之类的可以搜教程</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><blockquote>
<p>参考教程： <a href="https://www.jianshu.com/p/03d278e60ae3">2022.06.21 Linux 安装 Elasticsearch以及 IK分词器插件 - 简书 (jianshu.com)</a> </p>
</blockquote>
<p>完全按照下面步骤走肯定是不对的，有些地方需要换一下参数什么的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载安装包 7.6.1 换成你的版本</span></span><br><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.1-linux-x86_64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf elasticsearch-7.6.1-linux-x86_64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建用户（不能使用root用户启动ES）</span></span><br><span class="line">useradd elastic</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置密码</span></span><br><span class="line">passwd elastic</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">授权用户 后面一串是你的安装目录</span></span><br><span class="line">chown -R elastic:elastic /usr/local/elasticsearch-7.6.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到elastic用户</span></span><br><span class="line">su elastic</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入目录</span></span><br><span class="line">cd /usr/local/elasticsearch-7.2.1/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d代表后台启动</span></span><br><span class="line">sh elasticsearch -d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试是否启动成功  弹出 tagline: <span class="string">&quot;You Know, for Search&quot;</span> 为成功</span></span><br><span class="line">curl localhost:9200</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载IK分词器 也是换成你的版本</span></span><br><span class="line">wget https://github.com/infinilabs/analysis-ik/releases/download/v7.6.1/elasticsearch-analysis-ik-7.6.1.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把参数2解压到参数1目录下</span></span><br><span class="line">unzip -d /usr/local/elasticsearch-7.6.1/plugins/analysis-ik /opt/elasticsearch-analysis-ik-7.6.1.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到elastic用户</span></span><br><span class="line">su elastic</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先杀掉进程，再进入目录、启动</span></span><br><span class="line">jps -l</span><br><span class="line">kill -9 xxxx</span><br></pre></td></tr></table></figure>

<h2 id="Kibana-数据可视化"><a href="#Kibana-数据可视化" class="headerlink" title="Kibana 数据可视化"></a>Kibana 数据可视化</h2><p><strong>官网下载：</strong> <a href="https://www.elastic.co/cn/downloads/kibana">Download Kibana Free | Get Started Now | Elastic</a> </p>
<p>安装完在<strong>config</strong>文件夹下把 <strong>kibana.yml</strong> 配一下（Elasticsearch的端口之类的）</p>
<p>然后在<strong>bin</strong>目录运行后，就可以在 <a href="http://localhost:5601/">http://localhost:5601</a> （默认端口）访问Kibana了</p>
<h2 id="项目引入"><a href="#项目引入" class="headerlink" title="项目引入"></a>项目引入</h2><h3 id="Spring-Data-Elasticsearch"><a href="#Spring-Data-Elasticsearch" class="headerlink" title="Spring Data Elasticsearch"></a>Spring Data Elasticsearch</h3><p>最新的API客户端，可以支持8.x版本的ES，但文档很少</p>
<p>7.6.1版本测试了一下一直报错，上网查似乎是版本不对，就没用了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Rest-High-Level-Client"><a href="#Rest-High-Level-Client" class="headerlink" title="Rest High Level Client"></a>Rest High Level Client</h3><p>不支持8.x的新版本，但是用的最多，文档也很多</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;elasticsearch.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.origin.forumapi.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> ES客户端配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liosq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> 2024/3/11 19:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticsearchConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">restHighLevelClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RestClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> RestClient.builder(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9200</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DSL-操作"><a href="#DSL-操作" class="headerlink" title="DSL 操作"></a>DSL 操作</h2><blockquote>
<p><strong>DSL（Domain Specific Language）：</strong>一种特定领域的查询语言，用于构建复杂的查询和聚合操作</p>
</blockquote>
<p><strong>所有操作</strong>都可以在Kibana里进行，但<strong>不是所有操作</strong>都可以在Postman或ApiFox这种Http请求工具里进行</p>
<p>因为Http请求中body参数必须符合<strong>json格式</strong>，有些操作（比如bulk操作）并不符合</p>
<p>以下操作基于<strong>7.6.1</strong>版本的ES（只列举了一些基本的操作）</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询全部</span></span><br><span class="line">GET /index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// 查询同时带高亮</span></span><br><span class="line">GET /index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;span style=\&quot;color: red\&quot;&gt;&quot;</span><span class="punctuation">,</span> <span class="comment">// 自定义前后标签</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/span&gt;&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// bool查询</span></span><br><span class="line">GET /index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   <span class="comment">// 搜索条件 AND 连接</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span> <span class="comment">// 搜索条件</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 搜索条件 OR 连接</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span> <span class="comment">// 搜索条件</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// range查询（范围查询）</span></span><br><span class="line">GET /index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// greater than or equal</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">20</span>  <span class="comment">// less than or equal</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>查询结果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span> <span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span>  <span class="comment">// 符合的结果总数量 但不是查询返回的数量</span></span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> <span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>...<span class="punctuation">]</span>  <span class="comment">// 里面是对象数组</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Java-API-操作"><a href="#Java-API-操作" class="headerlink" title="Java API 操作"></a>Java API 操作</h2><p><strong>Spring Data Elasticsearch</strong> 的文档比较少而且API比较好学，所以这里演示的是<strong>Rest High Level Client</strong></p>
<p>以下操作基于<strong>7.6.1</strong>版本的ES</p>
<h3 id="判断索引存在"><a href="#判断索引存在" class="headerlink" title="判断索引存在"></a>判断索引存在</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIndexExist</span><span class="params">(String index)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断索引是否存在</span></span><br><span class="line">        <span class="type">GetIndexRequest</span> <span class="variable">getIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(index);</span><br><span class="line">        <span class="keyword">return</span> client.indices().exists(getIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;判断索引 &#123;&#125; 是否存在报错&quot;</span>, index, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建索引和映射"><a href="#创建索引和映射" class="headerlink" title="创建索引和映射"></a>创建索引和映射</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createIndex</span><span class="params">(String index, String mapping)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建索引请求并发送</span></span><br><span class="line">        <span class="type">CreateIndexRequest</span> <span class="variable">createIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(index)</span><br><span class="line">            .mapping(mapping, XContentType.JSON);</span><br><span class="line">        <span class="type">CreateIndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.indices().create(createIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> response.isAcknowledged();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;创建索引 &#123;&#125; 报错&quot;</span>, index, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteIndex</span><span class="params">(String index)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(index);</span><br><span class="line">        <span class="type">AcknowledgedResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> response.isAcknowledged();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;删除索引 &#123;&#125; 报错&quot;</span>, index, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数为批量添加，单独添加只需创建一个IndexRequest并调用client.index请求即可</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">batchInsertData</span><span class="params">(String index, List&lt;T&gt; data)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>(index);</span><br><span class="line">        <span class="keyword">for</span> (T item : data) &#123;</span><br><span class="line">            request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(index).source(JSON.toJSONString(item), XContentType.JSON));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BulkResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> response.status().getStatus() == <span class="number">200</span> &amp;&amp; !response.hasFailures();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125; 批量插入数据报错&quot;</span>, index, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批量更新（单独更新则只请求一个UpdateRequest）</span></span><br><span class="line"><span class="comment">// 传入对象由ES根据ID索引后对文档中不同的字段值进行更新</span></span><br><span class="line"><span class="comment">// getId 是实体类获取ID的方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T, R&gt; <span class="type">boolean</span> <span class="title function_">batchUpdateData</span><span class="params">(String index, List&lt;T&gt; data, Function&lt;T, R&gt; getId)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>(index);</span><br><span class="line">        data.forEach(item -&gt; &#123;</span><br><span class="line">            request.add(<span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(index, getId.apply(item).toString())</span><br><span class="line">                        .doc(JSON.toJSONString(item), XContentType.JSON));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">BulkResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> response.status().getStatus() == <span class="number">200</span> &amp;&amp; !response.hasFailures();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125; 批量更新报错&quot;</span>, index, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询更新 通过编写脚本对文档的字段值进行更新</span></span><br><span class="line"><span class="comment">// Script示例： ctx._source.[field] = 1 （把字段值置为1）</span></span><br><span class="line"><span class="comment">// 可以支持很多复杂的操作</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">updateDataByQuery</span><span class="params">(String index, Collection&lt;T&gt; ids, String script)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">UpdateByQueryRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateByQueryRequest</span>(index);</span><br><span class="line">        request.setQuery(QueryBuilders.termsQuery(<span class="string">&quot;id&quot;</span>, ids))</span><br><span class="line">            .setScript(<span class="keyword">new</span> <span class="title class_">Script</span>(script));</span><br><span class="line"></span><br><span class="line">        <span class="type">BulkByScrollResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.updateByQuery(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> response.getUpdated() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125; 搜索更新失败&quot;</span>, index, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只写了删除单独数据 批量用BulkRequest包装即可</span></span><br><span class="line"><span class="comment">// 实在不会可以参考上面添加更新数据的批量请求方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteData</span><span class="params">(String index, String id)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(index, id);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeleteResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> response.status().getStatus() == <span class="number">200</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125; 删除数据报错&quot;</span>, index, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; PageResult&lt;T&gt; <span class="title function_">searchData</span><span class="params">(String index,</span></span><br><span class="line"><span class="params">                                    Class&lt;T&gt; target,</span></span><br><span class="line"><span class="params">                                    QueryBuilder queryBuilder,</span></span><br><span class="line"><span class="params">                                    HighlightBuilder highlightBuilder,</span></span><br><span class="line"><span class="params">                                    String sortField,</span></span><br><span class="line"><span class="params">                                    SortOrder order,</span></span><br><span class="line"><span class="params">                                    Integer pageNum,</span></span><br><span class="line"><span class="params">                                    Integer pageSize)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">            .from((pageNum - <span class="number">1</span>) * pageSize)</span><br><span class="line">            .size(pageSize)</span><br><span class="line">            .query(queryBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 高亮</span></span><br><span class="line">        <span class="keyword">if</span> (highlightBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">            builder.highlighter(highlightBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">if</span> (sortField != <span class="literal">null</span>) &#123;</span><br><span class="line">            builder.sort(sortField, order);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.source(builder);</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">if</span> (response.status().getStatus() == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>&lt;T&gt;(response.getHits().getHits(), target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125; 搜索报错&quot;</span>, index, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据补全"><a href="#数据补全" class="headerlink" title="数据补全"></a>数据补全</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testSuggest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 可以使用querybuilder缩小建议的范围</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQueryBuilder.mustNot(<span class="keyword">new</span> <span class="title class_">ExistsQueryBuilder</span>(<span class="string">&quot;mainPostId&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">SuggestBuilder</span> <span class="variable">suggestBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuggestBuilder</span>()</span><br><span class="line">        .addSuggestion(<span class="string">&quot;[自定义建议名]&quot;</span>, SuggestBuilders.completionSuggestion(<span class="string">&quot;[字段名]&quot;</span>)</span><br><span class="line">                       .prefix(<span class="string">&quot;[输入的内容（作为前缀）]&quot;</span>)</span><br><span class="line">                       .skipDuplicates(<span class="literal">true</span>)</span><br><span class="line">                       .size(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Suggest</span> <span class="variable">suggest</span> <span class="operator">=</span> elasticsearchUtil.searchSuggest(POST_INDEX, suggestBuilder, boolQueryBuilder, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">CompletionSuggestion</span> <span class="variable">suggestion</span> <span class="operator">=</span> suggest.getSuggestion(<span class="string">&quot;[自定义建议名]&quot;</span>);</span><br><span class="line">    List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestion.getOptions();</span><br><span class="line">    <span class="keyword">for</span> (CompletionSuggestion.Entry.Option option : options) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;option = &quot;</span> + option.getText().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽离的工具类</span></span><br><span class="line"><span class="keyword">public</span> Suggest <span class="title function_">searchSuggest</span><span class="params">(String index,</span></span><br><span class="line"><span class="params">                             SuggestBuilder suggestBuilder,</span></span><br><span class="line"><span class="params">                             QueryBuilder queryBuilder,</span></span><br><span class="line"><span class="params">                             String sortField,</span></span><br><span class="line"><span class="params">                             SortOrder order)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(index);</span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> request.source();</span><br><span class="line">        <span class="keyword">if</span> (queryBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">            sourceBuilder.query(queryBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sourceBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">            sourceBuilder.sort(<span class="string">&quot;&quot;</span>, SortOrder.ASC);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response.getSuggest();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125; 获取搜索建议报错&quot;</span>, index, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="创建的索引的映射不对"><a href="#创建的索引的映射不对" class="headerlink" title="创建的索引的映射不对"></a>创建的索引的映射不对</h2><p>检查是否是调用的 <strong>CreateIndexRequest</strong> 的 <strong>mapping</strong> 方法传入的映射；如果没问题，则检查传入的映射是否包含 <strong>properties属性</strong></p>
<p>Mapping示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="删除索引-1"><a href="#删除索引-1" class="headerlink" title="删除索引"></a>删除索引</h2><h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1>]]></content>
      <categories>
        <category>笔记</category>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>泰拉瑞亚</title>
    <url>/post/d4b2ca09/</url>
    <content><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="存档"><a href="#存档" class="headerlink" title="存档"></a>存档</h2><p>世界存档在 C:\Users\[用户名]\Documents\My Games\Terraria\Worlds 目录下</p>
<p>角色存档在 C:\Users\[用户名]\Documents\My Games\Terraria\Players 目录下</p>
<h1 id="模组"><a href="#模组" class="headerlink" title="模组"></a>模组</h1><p>装Mod之前要在Steam下TModLoader（TML），然后直接启动TML在里面下模组就行</p>
<h2 id="灾厄"><a href="#灾厄" class="headerlink" title="灾厄"></a>灾厄</h2><p>泰拉瑞亚最知名的大型Mod，流程应该是最长的，加了非常多的Boss、地形、武器和饰品等等</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>星露谷物语</title>
    <url>/post/83302da4/</url>
    <content><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="游戏主文件夹"><a href="#游戏主文件夹" class="headerlink" title="游戏主文件夹"></a>游戏主文件夹</h2><p>如果你是Steam上的星露谷的话，那么文件夹在 <strong>[steam安装目录]\steamapps\common\Stardew Valley</strong> 目录下</p>
<p>比如我的Steam安装在 <strong>D:\Steam</strong>，那么游戏文件夹就在 <strong>D:\Steam\steamapps\common\Stardew Valley</strong>下</p>
<h3 id="存档文件"><a href="#存档文件" class="headerlink" title="存档文件"></a>存档文件</h3><p>存档文件不在游戏文件夹里，默认是存在C盘下的 <strong>C:\Users\[用户名]\AppData\Roaming\StardewValley\Saves</strong></p>
<p>跟上面一样把你的用户名填上就能找到</p>
<p>找到目录后会有你创建的所有存档的文件夹，具体的存档文件就是文件夹下的 <strong>[存档名]_xxxxxxxx</strong>（一段数字）</p>
<p>还有一个带 <strong>_old</strong> 的是昨天的存档，所以你最多是可以回档昨天的</p>
<p>存档文件是xml格式的，在网上有修改存档信息的教程（改之前记得备份）</p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="预测器"><a href="#预测器" class="headerlink" title="预测器"></a>预测器</h2><blockquote>
<p> <a href="https://mouseypounds.github.io/stardew-predictor/">Stardew Predictor (mouseypounds.github.io)</a> </p>
</blockquote>
<p>导入你的存档文件，可以预测你的以下信息：</p>
<ul>
<li>矿洞信息</li>
<li>猪车商品</li>
<li>科罗布斯商品</li>
<li>桑迪商品</li>
<li>壁纸</li>
<li>克林特开矿石</li>
<li>火车</li>
<li>夜晚事件</li>
<li>电影院抓娃娃机</li>
<li>垃圾桶</li>
<li>火山附魔</li>
<li>小镇矿洞的宝箱</li>
<li>姜岛宝石鸟 </li>
<li>冬日星盛宴送礼对象</li>
</ul>
<p>等一系列游戏未来通过伪随机生成的信息</p>
<h2 id="完美存档检测"><a href="#完美存档检测" class="headerlink" title="完美存档检测"></a>完美存档检测</h2><blockquote>
<p> <a href="https://mouseypounds.github.io/stardew-checkup/">Stardew Checkup (mouseypounds.github.io)</a> </p>
</blockquote>
<p>导入你的存档文件，可以看到你的存档离完美存档还差些什么</p>
<h2 id="展览会助手"><a href="#展览会助手" class="headerlink" title="展览会助手"></a>展览会助手</h2><blockquote>
<p> <a href="https://mouseypounds.github.io/stardew-fair-helper/">Stardew Fair 助手 (mouseypounds.github.io)</a> </p>
</blockquote>
<p>可以算展览会的分</p>
<h2 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h2><h3 id="国内原版"><a href="#国内原版" class="headerlink" title="国内原版"></a>国内原版</h3><blockquote>
<p> <a href="https://xinglugu.huijiwiki.com/index.php?curid=1">Stardew Valley 中文维基 | 星露谷物语攻略资料站 - 灰机wiki - 北京嘉闻杰诺网络科技有限公司 (huijiwiki.com)</a> </p>
</blockquote>
<h3 id="国外原版"><a href="#国外原版" class="headerlink" title="国外原版"></a>国外原版</h3><blockquote>
<p> <a href="https://stardewvalleywiki.com/Stardew_Valley_Wiki">Stardew Valley Wiki</a> </p>
</blockquote>
<h3 id="国外SVE版"><a href="#国外SVE版" class="headerlink" title="国外SVE版"></a>国外SVE版</h3><blockquote>
<p> <a href="https://stardew-valley-expanded.fandom.com/wiki/Wiki">Wiki | Stardew Valley Expanded Wiki | Fandom</a> </p>
</blockquote>
<p>可能需要挂梯子，Wiki里包含了原版和SVE内容的各种信息</p>
<h1 id="模组"><a href="#模组" class="headerlink" title="模组"></a>模组</h1><p>模组需要到 <a href="https://www.nexusmods.com/stardewvalley/mods/?BH=0">N网</a> 下载（可能要挂梯子），在下Mod之前一定要注意前置Mod，你点下载后他会提示你，一定要把前置Mod都下完才不会报错</p>
<blockquote>
<p>下载之前最好下一个浏览器插件：油猴脚本（Tampermonkey），下载完油猴脚本后，在油猴脚本中搜索Nexus No Wait脚本，下载完并启用脚本，在N网下载Mod就不需要等待5秒了</p>
</blockquote>
<h2 id="Stardew-Modding-API（SMAPI）"><a href="#Stardew-Modding-API（SMAPI）" class="headerlink" title="Stardew Modding API（SMAPI）"></a>Stardew Modding API（SMAPI）</h2><blockquote>
<p> <a href="https://www.nexusmods.com/stardewvalley/mods/2400">SMAPI - Stardew Modding API at Stardew Valley Nexus - Mods and community (nexusmods.com)</a> </p>
</blockquote>
<p>用来给其他模组提供API的模组，而且是<strong>模组的启动器</strong>（类似泰拉瑞亚的TModLoader）</p>
<p>他下载下来会有三种格式的文件是对应不同的<strong>操作系统</strong>的：</p>
<ul>
<li>sh（Linux）</li>
<li>command（MacOS）</li>
<li>bat（Windows）</li>
</ul>
<p>选择对应操作系统的文件并双击运行，根据提示一步步安装就可以了</p>
<p>安装完后你的星露谷游戏目录会有Mods文件夹，用来存放你下载的模组文件（你也可以在这里创建文件夹对模组分类，不会影响模组的正常导入）</p>
<h2 id="模组设置（Generic-Mod-Config-Menu）"><a href="#模组设置（Generic-Mod-Config-Menu）" class="headerlink" title="模组设置（Generic Mod Config Menu）"></a>模组设置（Generic Mod Config Menu）</h2><blockquote>
<p> <a href="https://www.nexusmods.com/stardewvalley/mods/5098">Generic Mod Config Menu at Stardew Valley Nexus - Mods and community (nexusmods.com)</a> </p>
</blockquote>
<p>可以设置所有模组的配置信息，基本是必装的</p>
<h2 id="星露谷拓展（SVE）"><a href="#星露谷拓展（SVE）" class="headerlink" title="星露谷拓展（SVE）"></a>星露谷拓展（SVE）</h2><blockquote>
<p> <a href="https://www.nexusmods.com/stardewvalley/mods/3753">Stardew Valley Expanded at Stardew Valley Nexus - Mods and community (nexusmods.com)</a> </p>
</blockquote>
<p>在原有星露谷的基础上增加了新人物、剧情和地点等等。可以配合其他农场拓展一起用</p>
<h2 id="UI信息（Ui-Info-Suite）"><a href="#UI信息（Ui-Info-Suite）" class="headerlink" title="UI信息（Ui Info Suite）"></a>UI信息（Ui Info Suite）</h2><blockquote>
<p> <a href="https://www.nexusmods.com/stardewvalley/mods/1150">Ui Info Suite at Stardew Valley Nexus - Mods and community (nexusmods.com)</a> </p>
</blockquote>
<p>可以在游戏里查看到很多有用的信息：</p>
<ul>
<li>右上角UI：<ul>
<li>今天的运气</li>
<li>今天的菜谱</li>
<li>今天是什么节日</li>
<li>今天是谁的生日</li>
<li>猪车有没有来</li>
<li>今天是不是树莓（蓝莓）季</li>
<li>升级的工具还有多少天完成</li>
</ul>
</li>
<li>其他信息：<ul>
<li>动物有没有被抚摸、挤奶或剪羊毛等</li>
<li>洒水器、稻草人、蜂箱等带范围的机器的范围显示</li>
<li>工作中的机器还有多久完成</li>
</ul>
</li>
</ul>
<p>还有很多没列举出来，总之很有用就对了 <span class="github-emoji" alias="heart_eyes" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8">&#x1f60d;</span></p>
<h2 id="作弊菜单（CJB-Cheats-Menu）"><a href="#作弊菜单（CJB-Cheats-Menu）" class="headerlink" title="作弊菜单（CJB Cheats Menu）"></a>作弊菜单（CJB Cheats Menu）</h2><blockquote>
<p> <a href="https://www.nexusmods.com/stardewvalley/mods/4">CJB Cheats Menu at Stardew Valley Nexus - Mods and community (nexusmods.com)</a> </p>
</blockquote>
<p>就和修改器一样，可以在游戏里实时改数据</p>
<p>网页上写没有中文但是进去是有中文的</p>
<h2 id="全物品栏（CJB-Item-Spawner）"><a href="#全物品栏（CJB-Item-Spawner）" class="headerlink" title="全物品栏（CJB Item Spawner）"></a>全物品栏（CJB Item Spawner）</h2><blockquote>
<p> <a href="https://www.nexusmods.com/stardewvalley/mods/93">CJB Item Spawner at Stardew Valley Nexus - Mods and community (nexusmods.com)</a> </p>
</blockquote>
<p>游戏中所有的物品（包括正常游戏里拿不到的）</p>
<p>跟上面一样也是游戏里有中文</p>
<h2 id="NPC地图（NPC-Map-Locations）"><a href="#NPC地图（NPC-Map-Locations）" class="headerlink" title="NPC地图（NPC Map Locations）"></a>NPC地图（NPC Map Locations）</h2><blockquote>
<p> <a href="https://www.nexusmods.com/stardewvalley/mods/239">NPC Map Locations at Stardew Valley Nexus - Mods and community (nexusmods.com)</a> </p>
</blockquote>
<p>可以实时显示所有NPC的当前位置，再也不用担心送礼物找不到人啦 <span class="github-emoji" alias="yum" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8">&#x1f60b;</span><span class="github-emoji" alias="yum" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8">&#x1f60b;</span></p>
<h2 id="拖拉机（Tractor-Mod）"><a href="#拖拉机（Tractor-Mod）" class="headerlink" title="拖拉机（Tractor Mod）"></a>拖拉机（Tractor Mod）</h2><blockquote>
<p> <a href="https://www.nexusmods.com/stardewvalley/mods/1401">Tractor Mod at Stardew Valley Nexus - Mods and community (nexusmods.com)</a> </p>
</blockquote>
<p>按退格键 <kbd>BackSpace</kbd> 召唤拖拉机（可以在模组设置里设置没有拖拉机也能召唤）</p>
<p>坐上拖拉机后你现在拿着什么工具他就会在以自己为中心<strong>N × N范围</strong>内自动使用工具</p>
<p>就比如你拿着锄头，坐上拖拉机后就会自动锄地，走到哪锄到哪 <span class="github-emoji" alias="joy" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">&#x1f602;</span></p>
<p>如果你拿着武器他就自动攻击范围内怪物（拿着弹弓会向你鼠标指针位置射N × N次）</p>
<p>很BT的一个Mod，但是自己玩开心就行了，管那么多干嘛 <span class="github-emoji" alias="yum" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8">&#x1f60b;</span></p>
<h2 id="自动化（Automate）"><a href="#自动化（Automate）" class="headerlink" title="自动化（Automate）"></a>自动化（Automate）</h2><blockquote>
<p> <a href="https://www.nexusmods.com/stardewvalley/mods/1063">Automate at Stardew Valley Nexus - Mods and community (nexusmods.com)</a> </p>
</blockquote>
<p>可以把箱子和其他工作机器连一起，机器会自动把箱子内的物品作为原料，然后加工完放回到箱子里（所以可以完成一些连锁性的工作）</p>
<p>很好的Mod，使我的肝愉悦 <span class="github-emoji" alias="yum" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8">&#x1f60b;</span><span class="github-emoji" alias="yum" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8">&#x1f60b;</span></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Html</title>
    <url>/post/b84b57db/</url>
    <content><![CDATA[<h1 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h1><h2 id="富文本div"><a href="#富文本div" class="headerlink" title="富文本div"></a>富文本div</h2><p>设置div的<strong>contenteditable</strong>属性为true即可在div里插入富文本</p>
<p>但是如果用js过滤图片时，如果innerHTML追加了一个<strong>img标签</strong>的话，会自动把img标签内的 &#x2F; 去掉</p>
<p>比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会变成下面这样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/post/da3e1361/</url>
    <content><![CDATA[<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="MyBatis的执行流程"><a href="#MyBatis的执行流程" class="headerlink" title="MyBatis的执行流程"></a>MyBatis的执行流程</h2><ol>
<li><strong>配置mybatis-config.xml：</strong>配置数据库连接信息、Mapper的XML文件信息等</li>
<li>构建 <strong>SqlSessionFactory</strong>（会话工厂）</li>
<li>使用工厂创建 <strong>SqlSession</strong>（会话），包含了执行SQL语句的所有方法</li>
<li><strong>Executor</strong>（执行器），同时负责查询缓存的维护</li>
<li><strong>MappedStatement对象</strong> 映射输入参数，转换输出结果为Java对象</li>
</ol>
<h2 id="MyBatis的延迟加载"><a href="#MyBatis的延迟加载" class="headerlink" title="MyBatis的延迟加载"></a>MyBatis的延迟加载</h2><blockquote>
<p><strong>延迟加载：</strong>当返回对象中含有其他表的实体对象时（1对1、1对n），只当使用到时才对其他表的实体对象进行加载（SQL语句查询数据）</p>
</blockquote>
<h3 id="开启延迟加载"><a href="#开启延迟加载" class="headerlink" title="开启延迟加载"></a>开启延迟加载</h3><ul>
<li><strong>局部开启：</strong>在<code>Mapper.xml</code>文件中<code>resultMap</code>的<code>collection</code>或<code>association</code>标签中加入属性<code>fetchType=&quot;lazy&quot;</code></li>
<li><strong>全局开启：</strong>在<code>mapper-config.xml</code>中的<code>settings</code>标签内加入<code>setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true|false&quot;</code>（默认关闭）</li>
</ul>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ol>
<li>使用<strong>CGLIB</strong>创建目标对象的代理对象</li>
<li>当调用目标中<strong>延迟加载对象</strong>的get方法时，进入拦截器invoke方法<ul>
<li>若发现get返回值为null，则执行SQL查询数据并调用set方法赋值</li>
</ul>
</li>
<li>接着完成get方法的调用，返回数据</li>
</ol>
<h2 id="MyBatis缓存机制"><a href="#MyBatis缓存机制" class="headerlink" title="MyBatis缓存机制"></a>MyBatis缓存机制</h2><p>MyBatis中包含三种缓存：</p>
<ul>
<li><strong>本地缓存：</strong>基于<strong>PerpetualCache</strong>，本质是一个<strong>HashMap</strong></li>
<li><strong>一级缓存：</strong>作用域是<strong>Session</strong>级别</li>
<li><strong>二级缓存：</strong>作用域是<strong>namespace</strong>和<strong>Mapper</strong>，不依赖与Session</li>
</ul>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>MyBatis<strong>默认开启</strong>一级缓存；在<strong>同一Session</strong>（会话）中缓存数据，即使使用不同的Mapper也会缓存数据</p>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>MyBatis<strong>默认关闭</strong>二级缓存，在<code>mapper-config.xml</code>中的<code>settings</code>中加入<code>setting name=&quot;cacheEnabled&quot; value=&quot;true|false&quot;</code></p>
<h3 id="缓存的清理"><a href="#缓存的清理" class="headerlink" title="缓存的清理"></a>缓存的清理</h3><p>当某一作用域（一级缓存：Session &#x2F; 二级缓存：Namespaces）中进行了<strong>增删改</strong>操作后，默认该作用域下<strong>所有SELECT中的缓存</strong>将被清空</p>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{} 和 ${} 的区别"></a><code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的区别</h2><p><code>#&#123;&#125;</code> 底层使用的是 <code>PreparedStatement</code>，会创建<strong>预编译的 SQL 语句</strong>，将 SQL 中的 <code>#&#123;&#125;</code> 替换为 <code>?</code> ，在执行 SQL 时会为预编译 SQL 中的占位符 <code>?</code> 进行赋值，调用 <code>PreparedStatement</code> 的 <code>set</code> 方法来赋值，预编译的 SQL 语句执行效率高，并且可以防止 SQL 注入</p>
<p>MyBatis 处理<code>$&#123;&#125;</code>时，只创建普通的 SQL 语句，然后再执行过程中将 <code>$&#123;&#125;</code> 中的参数值以<strong>字符串拼接</strong>的形式插入到 SQL 语句中</p>
<blockquote>
<p><strong>为什么预编译就可以防止 SQL 注入？</strong></p>
<p>原理是采用了预编译的方法，先将 SQL 语句中可被客户端控制的参数集进行编译，生成对应的临时变量集，再使用对应的设置方法，为临时变量集里面的元素进行赋值，赋值函数 <code>setString()</code>，会对传入的参数进行<strong>强制类型检查</strong>和<strong>安全检查</strong>，所以可以避免 SQL 注入</p>
</blockquote>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="项目引入"><a href="#项目引入" class="headerlink" title="项目引入"></a>项目引入</h2><h3 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h3><p>MyBatisPlus也能写Mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mysql驱动依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mybatis-plus启动依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mybatis配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="comment"># mapper文件的位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&#x27;classpath:mapper/*Mapper.xml&#x27;</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">  	<span class="comment"># 下划线命名和驼峰命名转换</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="报错”Error-instantiating-class”"><a href="#报错”Error-instantiating-class”" class="headerlink" title="报错”Error instantiating class”"></a>报错”Error instantiating class”</h2><p>一般是因为没有无参构造方法</p>
<h2 id="Mapper有传Java对象到XML时报错"><a href="#Mapper有传Java对象到XML时报错" class="headerlink" title="Mapper有传Java对象到XML时报错"></a>Mapper有传Java对象到XML时报错</h2><p>要在Mapper接口的对应方法参数前加@Param注解</p>
<p>或者在XML的crud标签中加上parameterType属性</p>
<h2 id="XML的SQL代码中有重复的需要列举出来的列名"><a href="#XML的SQL代码中有重复的需要列举出来的列名" class="headerlink" title="XML的SQL代码中有重复的需要列举出来的列名"></a>XML的SQL代码中有重复的需要列举出来的列名</h2><p>用sql标签抽离出公共列名，然后用include标签调用</p>
<h2 id="Collection一对多映射只映射了一个的问题"><a href="#Collection一对多映射只映射了一个的问题" class="headerlink" title="Collection一对多映射只映射了一个的问题"></a>Collection一对多映射只映射了一个的问题</h2><p>首先要保证collection中<strong>id的别名</strong>没有重复</p>
<p>其次如果主要对象的<strong>数据库中id字段</strong>也叫id（不是user_id这种），则需要在resultMap中把主要对象的ID也改成别名</p>
<p><strong>例子：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 主要对象为post 一对多映射对象为comments --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;post_detail_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;comments&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.util.ArrayList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.origin.forumapi.pojo.vo.CommentVO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;comment_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="PageHelper在对含有Collection映射的数据分页数据错乱问题"><a href="#PageHelper在对含有Collection映射的数据分页数据错乱问题" class="headerlink" title="PageHelper在对含有Collection映射的数据分页数据错乱问题"></a>PageHelper在对含有Collection映射的数据分页数据错乱问题</h2><p>PageHelper是对sql查询到的<strong>总条数</strong>进行分页，上网搜有几种解决方法：</p>
<ol>
<li>用MyBatis的子查询对Collection进行映射</li>
<li>在service层进行两次查询</li>
<li>封装Page类（没看懂，链接在下面）</li>
</ol>
<blockquote>
<p> <a href="https://code84.com/793576.html">【Java】PageHelper分页总条数和总页数查询不正确 – 源码巴士 (code84.com)</a> </p>
</blockquote>
<h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><h2 id="resultMap注意事项"><a href="#resultMap注意事项" class="headerlink" title="resultMap注意事项"></a>resultMap注意事项</h2><ul>
<li><p>id和result标签就写个<strong>property</strong>和<strong>column</strong>属性就行</p>
</li>
<li><p>如果Java对象的<strong>所有属性</strong>和数据库<strong>列名</strong>只有<strong>驼峰下划线命名冲突</strong>的话可以直接用<strong>autoMapping</strong>（要在配置文件中把map-underscore-to-camel-case设为true）</p>
</li>
<li><p><strong>记得Java对象要加无参构造方法</strong></p>
</li>
</ul>
<h2 id="Intelij的MyBatisX插件"><a href="#Intelij的MyBatisX插件" class="headerlink" title="Intelij的MyBatisX插件"></a>Intelij的MyBatisX插件</h2><p>在写Mapper接口和xml的时候很好用，可以在接口跳转到xml并生成对应方法的<strong>crud标签</strong></p>
<h2 id="一个XML标签写多个SQL语句"><a href="#一个XML标签写多个SQL语句" class="headerlink" title="一个XML标签写多个SQL语句"></a>一个XML标签写多个SQL语句</h2><p><strong>可以实现</strong>，但是要在配置文件中的<strong>数据库url</strong>后面加上<strong>allowMultiQueries&#x3D;true</strong></p>
<h2 id="MyBatis子查询"><a href="#MyBatis子查询" class="headerlink" title="MyBatis子查询"></a>MyBatis子查询</h2><p>如果标签里有<strong>resultMap属性</strong>需要去掉，把resultMap放在子查询的标签里</p>
<p>需要在标签里加<strong>column属性</strong>，其表示<strong>主查询中的字段值到子查询的映射</strong>，格式为<code>&#123;子查询要用的变量名=主查询的字段名&#125;</code>。子查询用<code>#&#123;&#125;</code>调用变量值</p>
<blockquote>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://xiaolincoding.com/interview/spring.html#mybatis%E9%87%8C%E7%9A%84-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB">Spring面试题 | 小林coding (xiaolincoding.com)</a></li>
<li><a href="https://blog.csdn.net/qq_71443736/article/details/134728125">PreparedStatement预编译原理及基础使用_preparestatement-CSDN博客</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/post/6f2612a2/</url>
    <content><![CDATA[<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="SpringBoot-和-Spring"><a href="#SpringBoot-和-Spring" class="headerlink" title="SpringBoot 和 Spring"></a>SpringBoot 和 Spring</h2><p>SpringBoot 的出现是为了简化 Spring 的配置，使开发者可以<strong>专注于业务逻辑的实现</strong>，不需要依赖项的 XML 配置</p>
<h2 id="SpringBoot-自动配置原理"><a href="#SpringBoot-自动配置原理" class="headerlink" title="SpringBoot 自动配置原理"></a>SpringBoot 自动配置原理</h2><ol>
<li>SpringBoot的引导类上有一个注解**@SpringBootApplication**，该注解对三个注解进行了封装：<ul>
<li>@SpringBootConfiguration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>
</li>
<li>其中**@EnableAutoConfiguration<strong>是</strong>实现自动配置的核心注解**<ul>
<li>该注解通过**@Import**注解导入对应的配置选择器</li>
<li>其内部是读取了该项目和该项目引用的<strong>Jar包</strong>的classpath路径下<code>/META-INF/spring.factories</code>文件中所配置的类的全部类名</li>
<li>这些配置类中定义的Bean会根据<strong>条件注解所指定的条件</strong>来决定是否将Bean导入到Spring容器中</li>
</ul>
</li>
<li>条件判断会有像**@ConditionalOnClass<strong>这样的注解，判断是否有对应的</strong>class文件**，如果有则加载该类，把该配置类的所有Bean放入Spring容器中</li>
</ol>
<h2 id="Spring、SpringMVC、SpringBoot常见注解"><a href="#Spring、SpringMVC、SpringBoot常见注解" class="headerlink" title="Spring、SpringMVC、SpringBoot常见注解"></a>Spring、SpringMVC、SpringBoot常见注解</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Component @Controller @Service @Repository</td>
<td align="center">使用在<strong>类</strong>上，用于实例化Bean</td>
</tr>
<tr>
<td align="center">@Autowired</td>
<td align="center">使用在<strong>字段</strong>上，用于<strong>根据类型</strong>依赖注入</td>
</tr>
<tr>
<td align="center">@Qualifier</td>
<td align="center"><strong>结合@Autowired</strong>一齐使用，用于根据Bean名称进行依赖注入</td>
</tr>
<tr>
<td align="center">@Scope</td>
<td align="center">标注@Bean的作用范围</td>
</tr>
<tr>
<td align="center">@Configuration</td>
<td align="center">指定当前类为<strong>Spring配置类</strong>，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td align="center">@ComponentScan</td>
<td align="center">用于指定Spring在<strong>初始化容器</strong>时要扫描的包</td>
</tr>
<tr>
<td align="center">@Bean</td>
<td align="center">使用在<strong>方法</strong>上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td align="center">@Import</td>
<td align="center">使用@Import导入的类会被Spring加载到IoC容器中</td>
</tr>
<tr>
<td align="center">@Aspect @Before @After @Around @Pointcut</td>
<td align="center">AOP注解</td>
</tr>
</tbody></table>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@RequestMapping</td>
<td align="center">用于映射请求路径，可以定义在<strong>类</strong>和<strong>方法</strong>上<br /><strong>用于类上：</strong>表明类中所有方法都是以该地址作为父路径</td>
</tr>
<tr>
<td align="center">@RequestBody</td>
<td align="center">用于接收Http请求中的<strong>JSON数据</strong>，将JSON转换为Java对象</td>
</tr>
<tr>
<td align="center">@RequestParam</td>
<td align="center">指定请求参数的名称</td>
</tr>
<tr>
<td align="center">@PathVariable</td>
<td align="center">接收请求路径中的参数，传递给方法的形式参数</td>
</tr>
<tr>
<td align="center">@ResponseBody</td>
<td align="center">定义在<strong>Controller</strong>上，实现将其中所有方法的返回值转换为<strong>JSON</strong>返回给客户端</td>
</tr>
<tr>
<td align="center">@RequestHeader</td>
<td align="center">获取请求头中的指定参数信息</td>
</tr>
<tr>
<td align="center">@RestController</td>
<td align="center">@Controller + @ResponseBody</td>
</tr>
</tbody></table>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@SpringBootConfiguration</td>
<td align="center">组合了**@Configuration**注解，实现配置文件的功能</td>
</tr>
<tr>
<td align="center">@EnableAutoConfiguration</td>
<td align="center">打开自动配置的功能，也可以关闭某个自动配置</td>
</tr>
<tr>
<td align="center">@ComponentScan</td>
<td align="center">扫描 Spring 组件</td>
</tr>
</tbody></table>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Transactional-不回滚的问题"><a href="#Transactional-不回滚的问题" class="headerlink" title="@Transactional 不回滚的问题"></a><code>@Transactional</code> 不回滚的问题</h2><p><code>@Transational</code>默认只会回滚非受检异常，如果想实现受检异常也回滚需要配置注解<code>@Transactional(rollbackFor = Exception.class)</code></p>
<h2 id="properties-和-yml-配置文件同时存在"><a href="#properties-和-yml-配置文件同时存在" class="headerlink" title=".properties 和 .yml 配置文件同时存在"></a><code>.properties</code> 和 <code>.yml</code> 配置文件同时存在</h2><p>两个文件都有效，但 <strong><code>applicaiton.properties</code> 优先级高于 <code>application.yml</code></strong></p>
<blockquote>
<p>如果多个目录都有配置文件，文件所在<strong>目录级数</strong>越低，优先级越高</p>
</blockquote>
<h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><h2 id="实现IP封禁"><a href="#实现IP封禁" class="headerlink" title="实现IP封禁"></a>实现IP封禁</h2><p>目前只了解了下面这几种实现方法（登录权限拦截思路也一样）</p>
<ul>
<li><strong>全局拦截：</strong>创建Interceptor拦截所有的方法（一劳永逸，但是灵活性不是很高）</li>
<li><strong>自定义注解：</strong>在Interceptor中对每个加了注解的方法进行访问的拦截（可以自定义不同方法的合法访问频率）</li>
</ul>
<h2 id="DTO和VO"><a href="#DTO和VO" class="headerlink" title="DTO和VO"></a>DTO和VO</h2><p>粗略的在网上查了一下，大概是<strong>DTO</strong>是<strong>前端传后端</strong>接收用的对象；<strong>VO</strong>是<strong>后端传前端</strong>发送的对象？</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>后端</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/post/4d712855/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p>Centos 自带 yum，可以直接装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新 yum 软件依赖关系</span></span><br><span class="line">yum -y update</span><br><span class="line">yum install -y mysql-server</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>ubuntu 安装是用的 <code>apt-get</code>，跟 <code>yum</code> 一样也需要 update</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记得不是很清楚，但是命令应该差不多</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install mysql-server</span><br></pre></td></tr></table></figure>

<blockquote>
<p>新 Ubuntu 系统在下之前需要配置一下 apt 源</p>
<p><a href="https://blog.csdn.net/weixin_64972949/article/details/129972385">Ubuntu基础——网络配置+配置apt源（手把手教程）_ubuntu修改apt源-CSDN博客</a> </p>
</blockquote>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>有图形化界面，直接上网下就完了</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="CentOS-Ubuntu"><a href="#CentOS-Ubuntu" class="headerlink" title="CentOS&#x2F;Ubuntu"></a>CentOS&#x2F;Ubuntu</h3><blockquote>
<p> <a href="https://blog.csdn.net/qq_40241957/article/details/90343651">阿里云服务器中安装配置MYSQL数据库完整教程_Java全栈研发大联盟的博客-CSDN博客</a> </p>
</blockquote>
<p>下面这些指令是自己配的时候用到的指令，有的可能不太准确</p>
<p>配云服务器可以照着下面的这个搞，就是有些指令因为 mysql 版本不一样有些区别</p>
<p>配置的 mysql 版本好像是8.0的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动mysql</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ubuntu是mysql</span></span><br><span class="line">systemctl start mysqld.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去日志里找临时生成的密码，有的时候没有初始密码就试试grep <span class="string">&#x27;password&#x27;</span></span></span><br><span class="line">cat /var/log/mysql/mysqld.log | grep &#x27;temporary password&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用密码登录mysql</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以 mysql -uroot -p密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux如果-p没直接跟密码的话，输入的密码是不可见的，所以要记住自己输了什么</span></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p>然后就到 mysql 界面了，在这里每一句指令都要记得加分号，因为都是SQL语句</p>
<p>如果没加分号他会继续让你输，算是提示你没加分号了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> ubuntu直接运行这个似乎就可以了？</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 先把那个检测密码安全等级关闭了</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 这个是安全策略等级，直接先弄到low</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.policy<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 有的时候密码跟用户名一样也不让你设置（比如root），所以也把这个关了</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.check_user_name<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 最低密码长度改为<span class="number">4</span>。最低是<span class="number">4</span>，你改<span class="number">1</span>也是<span class="number">4</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.length<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 现在应该就可以改密码了，上面的有的mysql版本变量名不一样，所以如果报错要去搜一搜</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 有些版本不能直接引号包密码，需要PASSWORD(<span class="string">&#x27;&#x27;</span>)函数转换一下</span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 如果是服务器的mysql要远程连接，就需要再创一个host为<span class="operator">%</span>的root</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 指令大概是这样</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 给刚刚创建的用户赋予权限</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Ubuntu22去掉identified...可以跑</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 下面这个指令是是网上出现最多次的，我记得我好像是不能加<span class="keyword">with</span> <span class="keyword">grant</span> option，建议自己试一下</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;root&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 刷新权限</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 退出mysql，这句不用加;</span><br><span class="line">quit</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 这两句就是检查一下，如果有两个root，一个host是<span class="operator">%</span>，而且授权字符串都一样应该就是没问题可以用datagrip或者navicat连了</span><br><span class="line">USE mysql</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">User</span>, authentication_string, Host <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="深分页优化"><a href="#深分页优化" class="headerlink" title="深分页优化"></a>深分页优化</h2><p>深分页指的是使用 <code>LIMIT x, y</code>  关键字进行分页时，x参数过大导致查询时会先查询<strong>先排序前 x+y 条数据</strong>，然后才返回第 y 到 x+y 条数据</p>
<p>当请求返回的是整行数据时还需要进行<strong>回表查询</strong>（根据聚簇索引查找整行数据），导致效率非常低</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="延迟关联"><a href="#延迟关联" class="headerlink" title="延迟关联"></a>延迟关联</h4><p>使用<strong>聚簇索引</strong>先进行分页查询，再利用查询到的聚簇索引查询整行数据，这样可以<strong>减少回表次数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> target t </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> target LIMIT <span class="number">100000</span> <span class="number">10</span>) t_ids</span><br><span class="line"><span class="keyword">ON</span> t.id <span class="operator">=</span> t_ids.id</span><br></pre></td></tr></table></figure>

<h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><ul>
<li>主节点的事务提交时，将数据的更改记录到<strong>binlog</strong>（二进制日志）中</li>
<li>从节点的<strong>IOthread现成</strong>读取<strong>主节点的二进制日志</strong>并写入到<strong>从节点的relay log</strong>（中继日志）中</li>
<li>从节点的SQLthread<strong>重做中继日志中的事件</strong>，改变自己的数据</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><blockquote>
<p><strong>常见的分库分表中间件：</strong></p>
<ul>
<li>mycat</li>
<li>sharding-sphere</li>
</ul>
</blockquote>
<p>主要的拆分方法分为<strong>垂直拆分</strong>和<strong>水平拆分</strong></p>
<h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><p>以表为依据，<strong>根据业务</strong>将不同的表拆分到不同的库中</p>
<p><strong>特点：</strong></p>
<ul>
<li>按业务对数据分级管理、维护、监控、扩展</li>
<li>在高并发下，提高磁盘IO和数据量连接数</li>
</ul>
<h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>以字段为依据，<strong>根据字段属性</strong>将不同字段拆分到不同表中</p>
<p><strong>拆分规则：</strong></p>
<ul>
<li>不常用的字段单独放到一张表中</li>
<li>将text、blob等大字段单独放到一张附表中</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>冷热数据分离</li>
<li>减少IO过渡争抢资源，两表互不影响</li>
</ul>
<h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><h4 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h4><p>将一个库数据分到多个库中</p>
<p><strong>路由规则：</strong></p>
<ul>
<li>取模路由（id%n）</li>
<li>范围路由（[1,1e5]、[1e5+1,2e5]…）</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>减少单库数据压力</li>
<li>提高了系统可用性</li>
</ul>
<h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h4><p>将一个表数据分到多个表中</p>
<p><strong>特点：</strong></p>
<ul>
<li>减少单表数据压力</li>
<li>避免IO争抢，减少锁表的概率</li>
</ul>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><h3 id="登录控制台"><a href="#登录控制台" class="headerlink" title="登录控制台"></a>登录控制台</h3><p><code>mysql -u[username] -p[password] -h[hostname] -P[port]</code></p>
<h3 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h3><ul>
<li><strong>显示开启事务：</strong><code>begin</code> 或者 <code>start transaction</code></li>
<li><strong>提交事务：</strong><code>commit</code></li>
<li><strong>事务回滚：</strong><code>rollback</code></li>
</ul>
<h3 id="表修改"><a href="#表修改" class="headerlink" title="表修改"></a>表修改</h3><p><strong>统一前缀：</strong><code>alter table 表名</code></p>
<ul>
<li><p><strong>添加列：</strong><code>add [column] 列名 数据类型 [列属性]</code></p>
</li>
<li><p><strong>修改列：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改列数据类型</span><br><span class="line">modify [column] 列名 数据类型 [列属性]</span><br><span class="line">-- 重命名列</span><br><span class="line">change [column] 列名 新列名 数据类型 [列属性]</span><br><span class="line">-- 修改列默认值</span><br><span class="line">alter [column] 列名 set default 默认值</span><br><span class="line">                   drop default</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除列：</strong><code>drop [column] 列名</code></p>
</li>
</ul>
<h3 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h3><p><code>explain</code> 或 <code>desc</code></p>
<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>如果涉及对分组后的每一个组进行操作，可以用窗口函数来解决</p>
<p>例如：给定电影表（电影ID，放映厅ID，放映时间），找出每个电影在每个放映厅的第 N 早的放映时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @N = 3;</span><br><span class="line">SELECT movie_id, room_id, show_time FROM </span><br><span class="line">(SELECT movie_id, room_id, show_time ROW_NUMBER() (PARTITION BY movie_id, room_id ORDER BY show_time) rn)</span><br><span class="line">WHERE rn = @N;</span><br></pre></td></tr></table></figure>

<h3 id="查看所有正在运行的事务"><a href="#查看所有正在运行的事务" class="headerlink" title="查看所有正在运行的事务"></a>查看所有正在运行的事务</h3><p><code>select * from information.innodb_trx\g</code></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><h2 id="查看所有表磁盘空间占用情况"><a href="#查看所有表磁盘空间占用情况" class="headerlink" title="查看所有表磁盘空间占用情况"></a>查看所有表磁盘空间占用情况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    table_schema AS &#x27;数据库&#x27;,</span><br><span class="line">    sum( table_rows ) AS &#x27;记录数&#x27;,</span><br><span class="line">    sum(</span><br><span class="line">    TRUNCATE ( data_length / 1024 / 1024, 2 )) AS &#x27;数据容量(MB)&#x27;,</span><br><span class="line">    sum(</span><br><span class="line">    TRUNCATE ( index_length / 1024 / 1024, 2 )) AS &#x27;索引容量(MB)&#x27;</span><br><span class="line">FROM</span><br><span class="line">    information_schema.TABLES </span><br><span class="line">GROUP BY</span><br><span class="line">    table_schema </span><br><span class="line">ORDER BY</span><br><span class="line">    sum( data_length ) DESC,</span><br><span class="line">    sum( index_length ) DESC;</span><br></pre></td></tr></table></figure>

<h2 id="多表拼接"><a href="#多表拼接" class="headerlink" title="多表拼接"></a>多表拼接</h2><p>当两个表join后<strong>再次join其他表前</strong>，需要用<strong>select语句</strong>将<strong>前两个表join的结果</strong>进行整合</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span> ...) <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> c <span class="keyword">ON</span> ...;</span><br></pre></td></tr></table></figure>

<h2 id="SET变量接收多行数据"><a href="#SET变量接收多行数据" class="headerlink" title="SET变量接收多行数据"></a>SET变量接收多行数据</h2><p>目前在网上找了一圈没有什么非常好的方案，这里举出来一个相对较好的方案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 用GROUP_CONCAT将查询语句返回的多行数据拼接成一个集合</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@ids</span> <span class="operator">=</span> (<span class="keyword">SELECT</span> GROUP_CONCAT(id SEPERATOR <span class="string">&#x27;,&#x27;</span>) <span class="keyword">FROM</span> ...);</span><br><span class="line"># 使用FIND_IN_SET在集合里找目标ID</span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> FIND_IN_SET(id, <span class="variable">@ids</span>);</span><br></pre></td></tr></table></figure>

<p>显而易见，这种方法的局限很大，不能适用于字符串类型的数据</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/post/cc1b9611/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>浏览器都会内置 <strong>JavaScript 的解释器</strong>，如果想要脱离浏览器来执行 JavaScript，可以安装 NodeJS </p>
<h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><h2 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h2><ul>
<li><strong>原理</strong></li>
</ul>
<p>每次调用时设置定时任务，如果在定时任务执行前再次调用则重置定时任务</p>
<ul>
<li><strong>目的</strong></li>
</ul>
<p>达到<strong>减少调用频率</strong>和<strong>保留最后一次调用</strong>的效果</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callback	: 需要防抖处理的函数</span></span><br><span class="line"><span class="comment">// delay	: 防抖的延迟时长</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">callback, delay = <span class="number">200</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 不用箭头函数是因为箭头函数没有this指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            callback.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="异步返回Promise对象"><a href="#异步返回Promise对象" class="headerlink" title="异步返回Promise对象"></a>异步返回Promise对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">asyncDebounce</span> = (<span class="params">callback, delay = <span class="number">200</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(callback.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args));</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1>]]></content>
      <categories>
        <category>笔记</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>37. 解数独</title>
    <url>/post/de1f6638/</url>
    <content><![CDATA[<h1 id="37-解数独-力扣（LeetCode）"><a href="#37-解数独-力扣（LeetCode）" class="headerlink" title="37. 解数独 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/sudoku-solver/description/">37. 解数独 - 力扣（LeetCode）</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="O-n-O-n-2"><a href="#O-n-O-n-2" class="headerlink" title="$O(n!)+O(n^2)$"></a>$O(n!)+O(n^2)$</h3><p>直直直接就是一手 <strong>深度优先搜索</strong> + <strong>回溯</strong></p>
<p>跟八皇后差不多的思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// len和blk可以换，但是数组大小也要跟这变，算是略微增加了一下拓展性</span></span><br><span class="line">    <span class="type">const</span> <span class="type">short</span> len=<span class="number">9</span>,blk=<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ext数组就是每行每列每块的桶</span></span><br><span class="line">    <span class="type">bool</span> ext[<span class="number">27</span>][<span class="number">9</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ep数组是代表所有待填充的位置的属性</span></span><br><span class="line">    <span class="comment">// ep[n][0]表示空白在二维数组的第一个下标</span></span><br><span class="line">    <span class="comment">// ep[n][1]表示空白在二维数组的第二个下标</span></span><br><span class="line">    <span class="comment">// ep[n][2]表示空白要填的值</span></span><br><span class="line">    <span class="type">short</span> el,ep[<span class="number">81</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">short</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 跳出递归 优雅，灰常滴优雅啊</span></span><br><span class="line">        <span class="keyword">if</span>(idx+<span class="number">1</span>&gt;el)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="type">short</span> <span class="title">i</span><span class="params">(ep[idx][<span class="number">0</span>])</span>,<span class="title">j</span><span class="params">(ep[idx][<span class="number">1</span>])</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">short</span> n=<span class="number">0</span>;n&lt;len;n++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ext[i][n]||ext[len+j][n]||ext[(j+blk)/blk+i/blk*blk+(len&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>][n])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ext[i][n]=<span class="number">1</span>;</span><br><span class="line">            ext[len+j][n]=<span class="number">1</span>;</span><br><span class="line">            ext[(j+blk)/blk+i/blk*blk+(len&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>][n]=<span class="number">1</span>;</span><br><span class="line">            ep[idx][<span class="number">2</span>]=n;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(idx+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            ext[i][n]=<span class="number">0</span>;</span><br><span class="line">            ext[len+j][n]=<span class="number">0</span>;</span><br><span class="line">            ext[(j+blk)/blk+i/blk*blk+(len&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>][n]=<span class="number">0</span>;</span><br><span class="line">            ep[idx][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据样例</span></span><br><span class="line">    <span class="type">char</span> bd[<span class="number">9</span>][<span class="number">9</span>]=&#123;</span><br><span class="line">        &#123;<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;3&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;5&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;9&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; bd)</span> </span>&#123;</span><br><span class="line">        el=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">short</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">short</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">                <span class="keyword">if</span>(bd[i][j]!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function"><span class="type">short</span> <span class="title">n</span><span class="params">(bd[i][j]-<span class="string">&#x27;1&#x27;</span>)</span></span>;</span><br><span class="line">                    ext[i][n]=<span class="number">1</span>;</span><br><span class="line">                    ext[len+j][n]=<span class="number">1</span>;</span><br><span class="line">                    ext[(j+blk)/blk+i/blk*blk+(len&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>][n]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ep[el][<span class="number">0</span>]=i;</span><br><span class="line">                    ep[el++][<span class="number">1</span>]=j;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">short</span> i=<span class="number">0</span>;i&lt;el;i++)</span><br><span class="line">            bd[ep[i][<span class="number">0</span>]][ep[i][<span class="number">1</span>]]=ep[i][<span class="number">2</span>]+<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>某云音乐缓存</title>
    <url>/post/91dd4a8a/</url>
    <content><![CDATA[<p>在b站刷到个把某云音乐缓存转成mp3或者flac格式的视频，比较好奇就点开看了一下</p>
<p>那个up是专门做逆向的，用了些反编译的软件和把汇编代码转高级语言代码的软件。从读取缓存到缓存加密的过长一步一步向底层深挖，推导出缓存加密的函数的内存地址，最后发现缓存加密很简单，解密只需要异或一下就行了（开发人员偷大懒）</p>
<p>于是自己也动手试了一下，发现确实是这么个原理。但是有一些不足之处就是不知道缓存文件代表哪首歌，一首一首听是肯定不可能的</p>
<p>上网找了找缓存文件哈希码的含义，发现有一篇文章说缓存文件的哈希码是对应着其歌曲在某云数据库中的一个字段，可以把哈希码作为请求参数请求其api直接获取这首歌的全部信息</p>
<p>于是我便简单封装了一下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cache_path = <span class="string">&#x27;C:\\Users\\...\\AppData\\Local\\Netease\\CloudMusic\\Cache\\Cache&#x27;</span></span><br><span class="line"><span class="comment"># 解码后音乐文件的存储目录</span></span><br><span class="line">target_path = <span class="string">&#x27;...&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_music_names</span>(<span class="params">filenames</span>):</span><br><span class="line">    <span class="comment"># 请求官方api (根本不需要改User-Agent...)</span></span><br><span class="line">    music_ids = <span class="string">&#x27;,&#x27;</span>.join([_[:_.index(<span class="string">&#x27;-&#x27;</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> filenames])</span><br><span class="line">    resp = requests.get(<span class="string">f&#x27;http://music.163.com/api/song/detail/?id=<span class="subst">&#123;music_ids&#125;</span>&amp;ids=[<span class="subst">&#123;music_ids&#125;</span>]&#x27;</span>).json()</span><br><span class="line">    <span class="keyword">return</span> [song[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> song <span class="keyword">in</span> resp[<span class="string">&#x27;songs&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_file</span>(<span class="params">file_name, music_name</span>):</span><br><span class="line">    temp = file_name.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    name = temp[<span class="number">0</span>]</span><br><span class="line">    ext = temp[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ext == <span class="string">&#x27;uc&#x27;</span>:</span><br><span class="line">    	<span class="comment"># 缓存文件夹中有一个记录了缓存文件源格式的文件</span></span><br><span class="line">        <span class="comment"># 打开 info 文件获取文件格式名</span></span><br><span class="line">        info = json.loads(<span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;cache_path&#125;</span>\\<span class="subst">&#123;name&#125;</span>.info&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line">        target_ext = info[<span class="string">&#x27;format&#x27;</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 获取 uc 缓存文件内容</span></span><br><span class="line">            cont = <span class="built_in">bytearray</span>(<span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;cache_path&#125;</span>\\<span class="subst">&#123;file_name&#125;</span>&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">            <span class="comment"># 异或 163 解码内容</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cont)):</span><br><span class="line">                cont[i] ^= <span class="number">163</span></span><br><span class="line">            <span class="comment"># 写入到指定目录中</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;target_path&#125;</span>\\<span class="subst">&#123;music_name&#125;</span>.<span class="subst">&#123;target_ext&#125;</span>&quot;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="built_in">bytes</span>(cont))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;file_name&#125;</span>\t--&#x27;</span></span><br><span class="line">                  <span class="string">f&#x27;-&gt;\t<span class="subst">&#123;music_name&#125;</span>.<span class="subst">&#123;target_ext&#125;</span> 解码成功&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;file_name&#125;</span>\t--&#x27;</span></span><br><span class="line">                  <span class="string">f&#x27;-x\t<span class="subst">&#123;music_name&#125;</span>.<span class="subst">&#123;target_ext&#125;</span> 解码失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_all_files</span>(<span class="params">file_names, music_names</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_names)):</span><br><span class="line">        decode_file(file_names[i], music_names[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">orders = [</span><br><span class="line">    <span class="string">&#x27;解码全部文件&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;解码指定文件&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;退出&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, dirs, file_names <span class="keyword">in</span> os.walk(cache_path):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        file_names = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> file_names <span class="keyword">if</span> _.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] == <span class="string">&#x27;uc&#x27;</span>]</span><br><span class="line">        music_names = get_music_names(file_names)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join([<span class="string">f&#x27;<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>.\t<span class="subst">&#123;orders[i]&#125;</span>&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(orders))]))</span><br><span class="line">        order = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入序号: &#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> order == <span class="number">1</span>:</span><br><span class="line">            decode_all_files(file_names)</span><br><span class="line">        <span class="keyword">elif</span> order == <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join([<span class="string">f&#x27;<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>\t- <span class="subst">&#123;music_names[i]&#125;</span>&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(music_names))]))</span><br><span class="line">            order = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入指定文件序号: &#x27;</span>))</span><br><span class="line">            decode_file(file_names[order - <span class="number">1</span>], music_names[order - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> order == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;无该选项&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>学报文献数据</title>
    <url>/post/4fc25800/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>知识库的项目缺数据，学长在群里本来让其他两个人爬数据来着，但是过了一周开会他们也没爬到数据，说还在学什么的</p>
<p>从语气可以感觉到学长有点生气了，开始催我们抓紧进度什么的，然后问我会爬虫吗？让我也开始学爬虫</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>其实那一周我是学了一下爬虫的，记得周三有一节物联网课没心思听课就打算爬一下百度翻译的api</p>
<p>因为前端还行，所以很快定位到了请求接口，发现请求参数都很正常。除了一个sign，是一直变化，而且似乎是根据你传入文本的值变化而变化</p>
<p>没想到刚开始学就碰上硬茬了，正琢磨怎么生成这个签名呢。突然想起来上学期实训考试，老师在旁边说考试网站有bug，你们要能找出来就能满分。我就一步一步打断点分析考试数据是怎么渲染到浏览器上，结果就发现了请求获取到的数据里有答案</p>
<p>于是我就沿用那次的方法，一步一步打断点，找到了生成签名的函数，函数很长，而且感觉是被混淆加密过的。索性就把整个函数搬过来，上网查了查怎么在Python里调用JavaScript函数，导了个包就解决了。当时搞完已经是快下课了，当时心情就是非常激动，然后就把代码封装成一个类，每次想用翻译就直接引入这个类就ok</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"><span class="comment"># lan_list是一个语言映射列表，也是直接拦截请求就能找到</span></span><br><span class="line"><span class="keyword">from</span> baidufanyi.languages <span class="keyword">import</span> lan_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduTranslate</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;fanyi.baidu.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;https://fanyi.baidu.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.76&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;BIDUPSID=3C574EAB32054FCD30DC5846A976DC4B; PSTM=1688952101; ab_jid=4eb88762366f56ee5a5d3c3092286b01c2d9; ab_jid_BFESS=4eb88762366f56ee5a5d3c3092286b01c2d9; BAIDUID=3C574EAB32054FCDB33D0B497C31F8D1:SL=0:NR=10:FG=1; BDUSS=VaRk5sd1Z-V1FuNzhhT0VRdG5KV3JZS21EUFNaQTVtSXBtWk9WbnlFY0ttLWxrSVFBQUFBJCQAAAAAAAAAAAEAAAA7lO9Os8K4r9XmzNjDtMnuaQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOwmQKDsJkWX; BDUSS_BFESS=VaRk5sd1Z-V1FuNzhhT0VRdG5KV3JZS21EUFNaQTVtSXBtWk9WbnlFY0ttLWxrSVFBQUFBJCQAAAAAAAAAAAEAAAA7lO9Os8K4r9XmzNjDtMnuaQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOwmQKDsJkWX; H_PS_PSSID=39841_39935_39937_39933_39943_39938_39999_40013_40044; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; H_WISE_SIDS=39841_39935_39937_39933_39943_39938_39999_40013_40044; H_WISE_SIDS_BFESS=39841_39935_39937_39933_39943_39938_39999_40013_40044; BA_HECTOR=00a12k8kakal8g8h0ga58520f1i3ti1iojb081t; delPer=0; PSINO=7; ZFY=bCJZ:BP4jc0fMbEy0wl0IlAEUqO85tc5LYTDqupa4wQQ:C; BAIDUID_BFESS=3C574EAB32054FCDB33D0B497C31F8D1:SL=0:NR=10:FG=1; ab_bid=6bcd63a63cfe1563cd9c774b846c036f7250; ab_sr=1.0.1_YzNhOTYzM2E1ZjMwZmQ4Y2NiNDQwNTFmMTY1YTVhOGU0NmZiYzY3N2M0MDBhNjhkMDY2M2JmYjAyMzk3MjFkYjYxNTIxZDBmY2VmZWUyYzU1MGJjZTFkZTkyY2UzYTVlMjM1MDhiYTE1OTQ2NmJhY2IwNzQwNDkzNTJmNzY0M2RhZDUwMTVlM2JiYjAxMjc2NjY0MWNmZTIwNzdjMWU4NWFmMmRjYjFiYThkZGI5NDdkZTA4MjM0ZTczODhjZDRj&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Acs-Token&#x27;</span>: <span class="string">&#x27;1703476878072_1703520782449_cuD4/9ppyjvk6OcczGm+t0+Euqsb3taki25RxfARn3AKX75f5Dq2nr+XaKK47r99gxrJeRwQsph6sRla0fgqoyg7boTYST5KS8F5iwPRRgL1R0OFaqIxxdPpFxcMSB8ScBu34BYQrqJ44t82KFN1jkV9Y9myo9uadOHMOkIHq4mBNdX2hH9ZWCX1zSOPjzpNx0VrSOeVRZUahZoQSf3lLm40ESAKAhkpQ1KlV3XL6hUxjJalKjgCU2nIlDRExu+UGV/QXYZ25uVCvztRMSk8WHEDzsDeXiGEG3iFOqnNC7b1oItuEKUpPN1umjTqGTXl8OnYM2Yk4YIJLKkM/OM+ZEOcdtfoVxgh1bW4onnvR15CyQNBSDa6Gk9QA99gyAAa62+VuoaCLJ0W2hkLcPL7ya4BP8Ovj8c9J6pQNSpwTHeNxGIwcyeep+YH3KWZ2BUwT0nySVqcECqwghq0Jj7a2ZXo2sr90TQyewpCQvAJQ+u1ZcBio0liWnpeK18d/VVP&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.data = &#123;</span><br><span class="line">            <span class="string">&#x27;query&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;transtype&#x27;</span>: <span class="string">&#x27;realtime&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;token&#x27;</span>: <span class="string">&#x27;a15d651ffb02721a9d3943e0d724387c&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;simple_means_flag&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;common&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ts&#x27;</span>: <span class="built_in">int</span>(time.time_ns() / <span class="number">1e6</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        self.ctx = execjs.<span class="built_in">compile</span>(<span class="built_in">open</span>(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;sign.js&#x27;</span>), <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line">        self.log = <span class="built_in">open</span>(os.path.join(os.path.dirname(__file__), <span class="string">&#x27;translate.log&#x27;</span>), <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        self.log_params = &#123;</span><br><span class="line">            <span class="string">&quot;from_lan&quot;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;to_lan&quot;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;result&quot;</span>: <span class="string">&#x27;无&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;code&quot;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;response&quot;</span>: <span class="string">&#x27;无&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;cost_time&quot;</span>: <span class="string">&#x27;请求失败&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detect_lan</span>(<span class="params">self, content</span>):</span><br><span class="line">        resp = requests.post(<span class="string">f&#x27;https://fanyi.baidu.com/langdetect&#x27;</span>,</span><br><span class="line">                             headers=self.headers,</span><br><span class="line">                             data=&#123;<span class="string">&#x27;query&#x27;</span>: content&#125;)</span><br><span class="line">        <span class="keyword">if</span> resp.ok:</span><br><span class="line">            json = resp.json()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;lan&#x27;</span> <span class="keyword">in</span> json:</span><br><span class="line">                <span class="keyword">return</span> json[<span class="string">&#x27;lan&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;zh&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">translate</span>(<span class="params">self, from_lan, to_lan, content</span>):</span><br><span class="line">        <span class="keyword">if</span> from_lan <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            from_lan = self.detect_lan(content)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> lan_key <span class="keyword">in</span> lan_list.keys():</span><br><span class="line">            <span class="keyword">if</span> lan_list[lan_key] == from_lan:</span><br><span class="line">                self.log_params[<span class="string">&#x27;from_lan&#x27;</span>] = lan_key</span><br><span class="line">            <span class="keyword">elif</span> lan_list[lan_key] == to_lan:</span><br><span class="line">                self.log_params[<span class="string">&#x27;to_lan&#x27;</span>] = lan_key</span><br><span class="line">        self.log_params[<span class="string">&#x27;content&#x27;</span>] = content</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> from_lan == to_lan:</span><br><span class="line">            self.print_log()</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;源语言类型与目标语言相同&#x27;</span></span><br><span class="line"></span><br><span class="line">        sign = self.ctx.call(<span class="string">&#x27;getSign&#x27;</span>, content)</span><br><span class="line">        url = <span class="string">f&#x27;https://fanyi.baidu.com/v2transapi?from=<span class="subst">&#123;from_lan&#125;</span>&amp;to=<span class="subst">&#123;to_lan&#125;</span>&#x27;</span></span><br><span class="line">        self.data[<span class="string">&#x27;sign&#x27;</span>] = sign</span><br><span class="line">        self.data[<span class="string">&#x27;query&#x27;</span>] = content</span><br><span class="line"></span><br><span class="line">        clock = time.time_ns()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = requests.post(url, headers=self.headers, data=self.data, timeout=(<span class="number">3.0</span>, <span class="number">5.0</span>))</span><br><span class="line">        <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">            self.print_log()</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;请求失败&#x27;</span></span><br><span class="line">        <span class="keyword">except</span> requests.ReadTimeout <span class="keyword">or</span> requests.Timeout:</span><br><span class="line">            self.print_log()</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;请求超时&#x27;</span></span><br><span class="line"></span><br><span class="line">        clock = (time.time_ns() - clock) / <span class="number">1e9</span></span><br><span class="line">        <span class="keyword">if</span> clock &lt; <span class="number">10</span>:</span><br><span class="line">            clock = <span class="built_in">round</span>(clock, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">elif</span> clock &lt; <span class="number">100</span>:</span><br><span class="line">            clock = <span class="built_in">round</span>(clock, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> clock &lt; <span class="number">1000</span>:</span><br><span class="line">            clock = <span class="built_in">round</span>(clock, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            clock = <span class="built_in">int</span>(clock)</span><br><span class="line">        self.log_params[<span class="string">&#x27;cost_time&#x27;</span>] = <span class="built_in">str</span>(clock)</span><br><span class="line">        self.log_params[<span class="string">&#x27;code&#x27;</span>] = <span class="built_in">str</span>(resp.status_code)</span><br><span class="line">        res = resp.json()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;trans_result&#x27;</span> <span class="keyword">in</span> res.keys():</span><br><span class="line">            result = res[<span class="string">&#x27;trans_result&#x27;</span>][<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;dst&#x27;</span>]</span><br><span class="line">            self.log_params[<span class="string">&#x27;result&#x27;</span>] = result</span><br><span class="line">            self.print_log()</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        self.log_params[<span class="string">&#x27;response&#x27;</span>] = resp.text</span><br><span class="line">        self.print_log()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这个是改进后的，想拓展一下打个日志</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_log</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;———————\t<span class="subst">&#123;datetime.now()&#125;</span>\t————————\n&quot;</span></span><br><span class="line">              <span class="string">f&quot;源语言类型:\t<span class="subst">&#123;self.log_params[<span class="string">&#x27;from_lan&#x27;</span>]&#125;</span>\n&quot;</span></span><br><span class="line">              <span class="string">f&quot;目标语言类型:\t<span class="subst">&#123;self.log_params[<span class="string">&#x27;to_lan&#x27;</span>]&#125;</span>\n&quot;</span></span><br><span class="line">              <span class="string">f&quot;翻译内容:\t<span class="subst">&#123;self.log_params[<span class="string">&#x27;content&#x27;</span>]&#125;</span>\n&quot;</span></span><br><span class="line">              <span class="string">f&quot;翻译结果:\t<span class="subst">&#123;self.log_params[<span class="string">&#x27;result&#x27;</span>]&#125;</span>\n&quot;</span></span><br><span class="line">              <span class="string">f&quot;请求耗时:\t<span class="subst">&#123;self.log_params[<span class="string">&#x27;cost_time&#x27;</span>]&#125;</span> ms\n&quot;</span></span><br><span class="line">              <span class="string">f&quot;请求状态:\t<span class="subst">&#123;self.log_params[<span class="string">&#x27;code&#x27;</span>]&#125;</span>\n&quot;</span></span><br><span class="line">              <span class="string">f&quot;请求返回内容:\t<span class="subst">&#123;self.log_params[<span class="string">&#x27;response&#x27;</span>]&#125;</span>&quot;</span>, file=self.log)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">choose_lan</span>(<span class="params">self, tip</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            res = <span class="built_in">input</span>(tip)</span><br><span class="line">            keys = [key <span class="keyword">for</span> key <span class="keyword">in</span> lan_list.keys() <span class="keyword">if</span> key.find(res) &gt;= <span class="number">0</span>]</span><br><span class="line">            vals = [val <span class="keyword">for</span> val <span class="keyword">in</span> lan_list.values() <span class="keyword">if</span> val.find(res) &gt;= <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(vals) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(keys) == <span class="number">1</span>:</span><br><span class="line">                res = lan_list[keys[<span class="number">0</span>]]</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(vals) == <span class="number">1</span>:</span><br><span class="line">                res = vals[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">                flag = <span class="built_in">input</span>(<span class="string">f&quot;是 <span class="subst">&#123;key&#125;</span> 吗? (y/...): &quot;</span>).lower() == <span class="string">&#x27;y&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    res = lan_list[key]</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> vals:</span><br><span class="line">                flag = <span class="built_in">input</span>(<span class="string">f&quot;是 <span class="subst">&#123;val&#125;</span> 吗? (y/...): &quot;</span>).lower() == <span class="string">&#x27;y&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    res = val</span><br><span class="line">                    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>再然后，我就开始爬文献了。第一次爬的是中南大学学报，看了看请求发现网站居然是前后端分离的，直接把接口cv过来就爬完了。我马上在群里问学长数据是这样吗，学长也是很惊讶我当天晚上就爬完了（但也确实很简单）​ <span class="github-emoji" alias="slightly_smiling_face" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f642.png?v8">&#x1f642;</span>	</p>
<p>再再然后，我就专门负责爬数据了，转而开始爬其他大学学报的数据，因为大学学报的文献都是免费下载的，所以也不存在爬数据违法（至少学长是这么说的）。爬的时候才发现原来前后端分离的只是少数，绝大部分学报用的都是后端直接返回网页的模式，而且似乎好多学报的网站架构都差不多，只能爬完网页嗯分析了 <span class="github-emoji" alias="sob" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">&#x1f62d;</span></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>scrcpy</title>
    <url>/post/2035aef/</url>
    <content><![CDATA[<h1 id="scrcpy"><a href="#scrcpy" class="headerlink" title="scrcpy"></a>scrcpy</h1><blockquote>
<p> <a href="https://github.com/Genymobile/scrcpy">GitHub - Genymobile&#x2F;scrcpy: Display and control your Android device</a> </p>
</blockquote>
<p>一个手机投屏的软件，没有GUI，但是延迟巨低，自己实际用起来感觉延迟只有几十毫秒，但是有些限制屏幕录像或者截图的页面就会黑屏。比如微信支付码、学习通考试什么的…可以共享手机相机的画面</p>
<h3 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h3><p>去github找到项目（上面的链接），在releases里找到最新的版本下载下来压缩包解压就能用了</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>手机第一次连需要用usb连电脑，把<strong>开发者模式、usb调试</strong>什么的打开，然后手机电脑连同一个wifi用**–tcp-ip**启动就能直接连了</p>
<p>有点鸡肋的地方就是如果电脑关机，那手机又要用usb连了。就相当于可以无线投屏维持到电脑关机前</p>
<p>也可以直接运行我写好的<strong>startcpy.bat</strong>（文件名改了的话需要编辑一下脚本）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先<span class="built_in">cd</span>到scrcpy.exe那个目录下</span></span><br><span class="line">cd ....</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接运行.exe程序，用wifi连就加--tcp-ip</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实第一次连就加--tcp-ip也是可以的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还有什么全屏投屏好像是-f，可以去github看看官方文档</span></span><br><span class="line">.\scrcpy.exe</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>油猴脚本</title>
    <url>/post/e4f71868/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>油猴脚本能在网页里植入js脚本代码，在需要对网页中的众多元素进行统一操作时（包括但不限于各类用户事件、提取数据等），很有帮助</p>
<h2 id="一些注意的点"><a href="#一些注意的点" class="headerlink" title="一些注意的点"></a>一些注意的点</h2><ul>
<li>如果该网页中导入了类似jQuery这种的js库文件，可以在脚本里直接使用</li>
<li>若在获取网页元素总获取不到，大概率是因为js的启动函数是在html渲染元素之前就执行的，要吗setTimeout一下，要吗搞个回调函数（我是没怎么用过）</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>202104-2 邻域均值</title>
    <url>/post/950f0727/</url>
    <content><![CDATA[<h1 id="202104-2-邻域均值"><a href="#202104-2-邻域均值" class="headerlink" title="202104-2 邻域均值"></a>202104-2 邻域均值</h1><p><img data-src="/images/typora/1664697486178.png" alt="1664697486178"></p>
<p><img data-src="/images/typora/1664697506205.png" alt="1664697506205"></p>
<p><img data-src="/images/typora/1664697517077.png" alt="1664697517077"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,l,r,t,<span class="built_in">ans</span>(<span class="number">0</span>),sum[<span class="number">601</span>][<span class="number">601</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;l&gt;&gt;r&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;sum[i][j];</span><br><span class="line">			sum[i][j]+=sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">int</span> <span class="title">sx</span><span class="params">(max(i-r,<span class="number">1</span>))</span>,<span class="title">sy</span><span class="params">(max(j-r,<span class="number">1</span>))</span>,<span class="title">ex</span><span class="params">(min(i+r,n))</span>,<span class="title">ey</span><span class="params">(min(j+r,n))</span>,<span class="title">size</span><span class="params">((ex-sx+<span class="number">1</span>)*(ey-sy+<span class="number">1</span>))</span></span>;</span><br><span class="line">			<span class="keyword">if</span>(sum[ex][ey]-sum[ex][sy<span class="number">-1</span>]-sum[sx<span class="number">-1</span>][ey]+sum[sx<span class="number">-1</span>][sy<span class="number">-1</span>]&lt;=t*size)</span><br><span class="line">				ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>202109-2 非零段划分</title>
    <url>/post/977c9d1f/</url>
    <content><![CDATA[<h1 id="202109-2-非零段划分"><a href="#202109-2-非零段划分" class="headerlink" title="202109-2 非零段划分"></a>202109-2 非零段划分</h1><p><img data-src="/images/typora/1664696907681.png" alt="1664696907681"></p>
<p><img data-src="/images/typora/1664696919841.png" alt="1664696919841"></p>
<p><img data-src="/images/typora/1664696927370.png" alt="1664696927370"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,<span class="built_in">bl</span>(<span class="number">0</span>),<span class="built_in">tl</span>(<span class="number">0</span>),<span class="built_in">ans</span>(<span class="number">0</span>),x[<span class="number">500002</span>],b[<span class="number">500002</span>],t[<span class="number">500002</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;cin&gt;&gt;x[i++]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x[i]==x[i+<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(x[i]&gt;x[i+<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			t[tl++]=x[i];</span><br><span class="line">			<span class="keyword">while</span>(x[i]&gt;=x[i+<span class="number">1</span>])</span><br><span class="line">				i++;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			b[bl++]=x[i];</span><br><span class="line">			<span class="keyword">while</span>(x[i]&lt;=x[i+<span class="number">1</span>])</span><br><span class="line">				i++;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(b,b+bl);</span><br><span class="line">	<span class="built_in">sort</span>(t,t+tl);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bl;i++)</span><br><span class="line">		ans=<span class="built_in">max</span>(tl-(<span class="type">int</span>)(<span class="built_in">upper_bound</span>(t,t+tl,b[i])-t<span class="number">-1</span>)-bl+i,ans);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>202112-2 序列查询新解</title>
    <url>/post/e4dfb6a1/</url>
    <content><![CDATA[<h1 id="202112-2-序列查询新解"><a href="#202112-2-序列查询新解" class="headerlink" title="202112-2 序列查询新解"></a>202112-2 序列查询新解</h1><p><img data-src="/images/typora/1664693848039.png" alt="1664693848039"></p>
<p><img data-src="/images/typora/1664693866662.png" alt="1664693866662"></p>
<p><img data-src="/images/typora/1664693886630.png" alt="1664693886630"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,N,tr,r;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;N;</span><br><span class="line">	tr=r=N/(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> t,i=<span class="number">1</span>;i&lt;=n;i++,r+=tr)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;t;</span><br><span class="line">		ans+=<span class="built_in">abs</span>(r-t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(r&lt;=N)</span><br><span class="line">	&#123;</span><br><span class="line">		ans+=(N-r);</span><br><span class="line">		r+=tr;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>202203-2 出行计划</title>
    <url>/post/e5982e2b/</url>
    <content><![CDATA[<h1 id="202203-2-出行计划"><a href="#202203-2-出行计划" class="headerlink" title="202203-2 出行计划"></a>202203-2 出行计划</h1><p><img data-src="/images/typora/1664687324853.png" alt="1664687324853"></p>
<p><img data-src="/images/typora/1664687332544.png" alt="1664687332544"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,k,ed,ans[<span class="number">200001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> s,e,i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;s&gt;&gt;e;</span><br><span class="line">		ans[<span class="built_in">max</span>(s-e+<span class="number">1</span>,<span class="number">0</span>)]++;</span><br><span class="line">		ans[s+<span class="number">1</span>]--;</span><br><span class="line">		ed=<span class="built_in">max</span>(end,s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=ed;ans[i]+=ans[i<span class="number">-1</span>],i++);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> q,i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;q;</span><br><span class="line">		<span class="keyword">if</span>(q+k&gt;<span class="number">200000</span>)</span><br><span class="line">			cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout&lt;&lt;ans[q+k]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>202206-2 寻宝！大冒险！</title>
    <url>/post/7e781e6e/</url>
    <content><![CDATA[<h1 id="202206-2-寻宝！大冒险！"><a href="#202206-2-寻宝！大冒险！" class="headerlink" title="202206-2 寻宝！大冒险！"></a>202206-2 寻宝！大冒险！</h1><p><img data-src="/images/typora/1664686787143.png" alt="1664686787143"></p>
<p><img data-src="/images/typora/1664686801211.png" alt="1664686801211"></p>
<p><img data-src="/images/typora/1664686812090.png" alt="1664686812090"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>,map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt; &gt;tr;</span><br><span class="line"><span class="type">int</span> n,l,s,<span class="built_in">ans</span>(<span class="number">0</span>),tx[<span class="number">1000</span>],ty[<span class="number">1000</span>];</span><br><span class="line"><span class="type">bool</span> mp[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;l&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		tx[i]=x;</span><br><span class="line">		ty[i]=y;</span><br><span class="line">		tr[x][y]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=s;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=s;j++)</span><br><span class="line">			cin&gt;&gt;mp[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(tx[i])</span>,<span class="title">y</span><span class="params">(ty[i])</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=s;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=s;k++)</span><br><span class="line">				<span class="keyword">if</span>(tr[x+j][y+k]!=mp[j][k]||x+j&gt;l||y+k&gt;l)</span><br><span class="line">					<span class="keyword">goto</span> bk;</span><br><span class="line">		ans++;</span><br><span class="line">		bk:</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>202209-2 何以包邮？</title>
    <url>/post/918fa3c7/</url>
    <content><![CDATA[<h1 id="202209-2-何以包邮？"><a href="#202209-2-何以包邮？" class="headerlink" title="202209-2 何以包邮？"></a>202209-2 何以包邮？</h1><p><img data-src="/images/typora/1664684773431.png" alt="1664684773431"></p>
<p><img data-src="/images/typora/1664684810840.png" alt="1664684810840"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,x,bk[<span class="number">31</span>],dp[<span class="number">300001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;cin&gt;&gt;bk[i++]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">300000</span>;j&gt;=bk[i];j--)</span><br><span class="line">			dp[j]=<span class="built_in">max</span>(dp[j-bk[i]]+bk[i],dp[j]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;<span class="number">1</span>;i++)</span><br><span class="line">		<span class="keyword">if</span>(dp[i]&gt;=x)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;dp[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSP</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>工程化高精度类</title>
    <url>/post/8766dedf/</url>
    <content><![CDATA[<p>基于C++语言的封装类，用于高精度整数和小数（包括负整数和负小数）之间的基本运算和判断大小</p>
<p>主要使用<strong>字符串</strong>实现高精度</p>
<h1 id="高精度类-工程化"><a href="#高精度类-工程化" class="headerlink" title="高精度类(工程化)"></a>高精度类(工程化)</h1><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>令 c++ 中 string 最大能存储的字符个数为 $x$</p>
<p>则整数大小：$-10^{x}$ ~ $10^{x}$</p>
<h2 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h2><table>
<thead>
<tr>
<th align="center">更新内容</th>
<th align="center">时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">创建了高精度类；完成了对四则运算符、输入输出运算符和判断大小运算符的重载；除法输出类型为int，加减乘法输出类型为高精</td>
<td align="center">‎2022‎年‎8‎月‎20‎日‏‎13:31:44</td>
</tr>
<tr>
<td align="center">更新了加减乘法对负数的处理；扩宽了除法的输出范围(unsigned long long)；增加了判断对象是否为整数和负数的函数以及求相反数的函数；添加了成员变量prec描述对象的小数精确位数</td>
<td align="center">2022年8月21日10:37:57</td>
</tr>
<tr>
<td align="center">添加了对高精类数据的初始化(去除数字和负号以外的字符)；添加了高精类的快速幂函数(指数不为高精)</td>
<td align="center">2022年8月21日18:07:10</td>
</tr>
<tr>
<td align="center">更新了加减法和初始化对小数的处理；将成员变量prec改为了ptp(描述对象小数点所在位置)；优化了判断整数和大小的函数方法</td>
<td align="center">2022年8月23日11:34:17</td>
</tr>
<tr>
<td align="center">更新了乘法对小数的处理；添加了高精取模运算；对初始化进行了速度优化</td>
<td align="center">2022年8月24日11:27:13</td>
</tr>
<tr>
<td align="center">修复了初始化和加法的一些bug</td>
<td align="center">2022年8月24日18:51:49</td>
</tr>
<tr>
<td align="center">记以往版本为v1.0，更新版本至v2.0，将数字的表达结合为(负号)+整数位+(小数点)+小数位，数据结构也随即更改为2个string类型digit和decim分别表示整数位和小数位、2个bool类型dec和neg分别表示是否为小数和是否为负数；此次更新暂时只修改了v1.0的加法</td>
<td align="center">2022年11月21日22:17:26</td>
</tr>
<tr>
<td align="center">同步了v1.0的乘法和减法</td>
<td align="center">2022年11月26日11:05:21</td>
</tr>
</tbody></table>
<h2 id="计算速度"><a href="#计算速度" class="headerlink" title="计算速度"></a>计算速度</h2><h3 id="v1-0版本"><a href="#v1-0版本" class="headerlink" title="v1.0版本"></a>v1.0版本</h3><table>
<thead>
<tr>
<th>数据数量</th>
<th>加法</th>
<th>减法</th>
<th>乘法</th>
<th>除法</th>
<th>取模</th>
</tr>
</thead>
<tbody><tr>
<td>1k</td>
<td>7-8ms</td>
<td>8-10ms</td>
<td>2.06s</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5k</td>
<td>37-38ms</td>
<td>44-47ms</td>
<td>60.8s</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1w</td>
<td>71-73ms</td>
<td>87-91ms</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5w</td>
<td>360-375ms</td>
<td>457-470ms</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10w</td>
<td>736-747ms</td>
<td>932-945ms</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigNum</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> dec, neg;</span><br><span class="line">	string digit, decim;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">number_add</span><span class="params">(string&amp;, string&amp;, <span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">number_sub</span><span class="params">(string&amp;, string&amp;, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BigNum</span>() &#123; digit = <span class="string">&quot;0&quot;</span>, decim = <span class="string">&quot;&quot;</span>, dec = <span class="literal">false</span>, neg = <span class="literal">false</span>; &#125;</span><br><span class="line">	<span class="built_in">BigNum</span>(<span class="type">const</span> BigNum&amp; num) &#123; digit = num.digit, decim = num.decim, dec = num.dec, neg = num.neg; &#125;</span><br><span class="line">	<span class="built_in">BigNum</span>(<span class="type">const</span> string&amp; digit, string&amp; decim, <span class="type">const</span> <span class="type">bool</span> dec, <span class="type">const</span> <span class="type">bool</span> neg) &#123; <span class="keyword">this</span>-&gt;dec = dec, <span class="keyword">this</span>-&gt;neg = neg, <span class="keyword">this</span>-&gt;digit = digit, <span class="keyword">this</span>-&gt;decim = decim; &#125;</span><br><span class="line">	<span class="built_in">BigNum</span>(<span class="type">const</span> string&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(s.size())</span>, <span class="title">i</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">		neg = s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		dec = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dec = <span class="literal">true</span>;</span><br><span class="line">				decim = (i &lt; size ? s.<span class="built_in">substr</span>(i + <span class="number">1</span>, size - <span class="number">1</span>) : <span class="string">&quot;&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (neg)</span><br><span class="line">			digit = s.<span class="built_in">substr</span>(<span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			digit = s.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;, BigNum&amp;);</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="type">const</span> BigNum&amp;);</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> BigNum&amp;);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> BigNum <span class="keyword">operator</span>+(<span class="type">const</span> BigNum&amp;);</span><br><span class="line">	<span class="type">const</span> BigNum <span class="keyword">operator</span>-(<span class="type">const</span> BigNum&amp;);</span><br><span class="line">	<span class="type">const</span> BigNum <span class="keyword">operator</span>*(<span class="type">const</span> BigNum&amp;);</span><br><span class="line">	<span class="type">const</span> BigNum <span class="keyword">operator</span>/(<span class="type">const</span> BigNum&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, BigNum&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	string temp;</span><br><span class="line">	is &gt;&gt; temp;</span><br><span class="line">	num = <span class="built_in">BigNum</span>(temp);</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> BigNum&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; (num.neg ? <span class="string">&quot;-&quot;</span> + num.digit : num.digit) + (num.dec ? <span class="string">&quot;.&quot;</span> + num.decim : num.decim);</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> BigNum::<span class="keyword">operator</span>&lt;(<span class="type">const</span> BigNum&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (neg ^ num.neg)</span><br><span class="line">		<span class="keyword">return</span> !neg;</span><br><span class="line">	<span class="keyword">if</span> (digit == num.digit)</span><br><span class="line">		<span class="keyword">return</span> neg ^ (decim &lt; num.decim);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (digit.<span class="built_in">size</span>() == num.digit.<span class="built_in">size</span>())</span><br><span class="line">			<span class="keyword">return</span> neg ^ (digit &lt; num.digit);</span><br><span class="line">		<span class="keyword">return</span> neg ^ (digit.<span class="built_in">size</span>() &lt; num.digit.<span class="built_in">size</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BigNum::number_add</span><span class="params">(string&amp; ans, string&amp; plus, <span class="type">int</span> extra = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">reverse</span>(plus.<span class="built_in">begin</span>(), plus.<span class="built_in">end</span>());</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">temp</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">ans_size</span><span class="params">(ans.size())</span>, <span class="title">plus_size</span><span class="params">(plus.size())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; plus_size)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = extra + plus[i] + ans[i] - <span class="number">96</span>;</span><br><span class="line">		extra = temp / <span class="number">10</span>;</span><br><span class="line">		ans[i] = temp % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= ans_size)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = extra + plus[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			extra = temp / <span class="number">10</span>;</span><br><span class="line">			ans += temp % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (extra)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; ans_size)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[i] += extra % <span class="number">10</span>;</span><br><span class="line">			extra = ans[i] - <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span> (extra &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ans[i++] -= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= ans_size)</span><br><span class="line">			ans += extra % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> extra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BigNum::number_sub</span><span class="params">(string&amp; ans, string&amp; sub, <span class="type">int</span> borrow = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ans == sub)</span><br><span class="line">	&#123;</span><br><span class="line">		ans = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">reverse</span>(sub.<span class="built_in">begin</span>(), sub.<span class="built_in">end</span>());</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">ans_size</span><span class="params">(ans.size())</span>, <span class="title">sub_size</span><span class="params">(sub.size())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; sub_size)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[i] -= borrow;</span><br><span class="line">		ans[i] -= sub[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (ans[i] &lt; <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			ans[i] += <span class="number">10</span>, borrow = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			borrow = <span class="number">0</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; ans_size &amp;&amp; borrow)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[i] -= borrow;</span><br><span class="line">		<span class="keyword">if</span> (ans[i] &lt; <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			ans[i] += <span class="number">10</span>, borrow = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			borrow = <span class="number">0</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> borrow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> BigNum BigNum::<span class="keyword">operator</span>+(<span class="type">const</span> BigNum&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;neg ^ num.neg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">BigNum <span class="title">num1</span><span class="params">(*<span class="keyword">this</span>)</span>, <span class="title">num2</span><span class="params">(num)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (num.neg)</span><br><span class="line">		&#123;</span><br><span class="line">			num2.neg = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">return</span> num1 - num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			num1.neg = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">return</span> num2 - num1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">extra</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">dec</span><span class="params">(<span class="keyword">this</span>-&gt;dec || num.dec)</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">ans_digit</span><span class="params">(<span class="keyword">this</span>-&gt;digit)</span>, <span class="title">plus_digit</span><span class="params">(num.digit)</span>, <span class="title">ans_decim</span><span class="params">(<span class="keyword">this</span>-&gt;decim)</span>, <span class="title">plus_decim</span><span class="params">(num.decim)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (dec)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">extra_size</span><span class="params">(ans_decim.size() - plus_decim.size())</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (extra_size &gt; <span class="number">0</span>)</span><br><span class="line">			plus_decim.<span class="built_in">append</span>(extra_size, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (extra_size &lt; <span class="number">0</span>)</span><br><span class="line">			ans_decim.<span class="built_in">append</span>(-extra_size, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		extra = <span class="built_in">number_add</span>(ans_decim, plus_decim);</span><br><span class="line">		<span class="keyword">if</span> (extra &gt; <span class="number">0</span>)</span><br><span class="line">			ans_decim.<span class="built_in">erase</span>(ans_decim.<span class="built_in">begin</span>());</span><br><span class="line">		<span class="keyword">for</span> (string::iterator it = ans_decim.<span class="built_in">end</span>(); it != ans_decim.<span class="built_in">begin</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*it == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">				it = ans_decim.<span class="built_in">erase</span>(it);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dec = ans_decim.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans_digit.<span class="built_in">size</span>() &lt; plus_digit.<span class="built_in">size</span>())</span><br><span class="line">		<span class="built_in">swap</span>(ans_digit, plus_digit);</span><br><span class="line">	<span class="built_in">number_add</span>(ans_digit, plus_digit, extra);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">BigNum</span>(ans_digit, ans_decim, dec, <span class="keyword">this</span>-&gt;neg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> BigNum BigNum::<span class="keyword">operator</span>-(<span class="type">const</span> BigNum&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;neg ^ num.neg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">BigNum <span class="title">num1</span><span class="params">(*<span class="keyword">this</span>)</span>, <span class="title">num2</span><span class="params">(num)</span></span>;</span><br><span class="line">		num2.neg = !num.neg;</span><br><span class="line">		<span class="keyword">return</span> num1 + num2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">borrow</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">dec</span><span class="params">(<span class="keyword">this</span>-&gt;dec || num.dec)</span>, <span class="title">neg</span><span class="params">(<span class="keyword">this</span>-&gt;neg)</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">ans_digit</span><span class="params">(<span class="keyword">this</span>-&gt;digit)</span>, <span class="title">sub_digit</span><span class="params">(num.digit)</span>, <span class="title">ans_decim</span><span class="params">(<span class="keyword">this</span>-&gt;decim)</span>, <span class="title">sub_decim</span><span class="params">(num.decim)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (ans_digit.<span class="built_in">size</span>() &lt; sub_digit.<span class="built_in">size</span>() || (ans_digit.<span class="built_in">size</span>() == sub_digit.<span class="built_in">size</span>() &amp;&amp; ans_digit &lt; sub_digit))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(ans_digit, sub_digit);</span><br><span class="line">		<span class="built_in">swap</span>(ans_decim, sub_decim);</span><br><span class="line">		neg ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dec)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ans_digit == sub_digit)</span><br><span class="line">		&#123;</span><br><span class="line">			neg = ans_decim &lt; sub_decim;</span><br><span class="line">			<span class="keyword">if</span> (neg)</span><br><span class="line">				<span class="built_in">swap</span>(ans_decim, sub_decim);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">extra_size</span><span class="params">(ans_decim.size() - sub_decim.size())</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (extra_size &gt; <span class="number">0</span>)</span><br><span class="line">			sub_decim.<span class="built_in">append</span>(extra_size, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (extra_size &lt; <span class="number">0</span>)</span><br><span class="line">			ans_decim.<span class="built_in">append</span>(-extra_size, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		borrow = <span class="built_in">number_sub</span>(ans_decim, sub_decim);</span><br><span class="line">		<span class="keyword">for</span> (string::iterator it = ans_decim.<span class="built_in">end</span>() - <span class="number">1</span>; it != ans_decim.<span class="built_in">begin</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*it == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">				it = ans_decim.<span class="built_in">erase</span>(it);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ans_decim[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; ans_decim.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">			ans_decim = <span class="string">&quot;&quot;</span>, dec = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">number_sub</span>(ans_digit, sub_digit, borrow);</span><br><span class="line">	<span class="keyword">for</span> (string::iterator it = ans_digit.<span class="built_in">begin</span>(); it != ans_digit.<span class="built_in">end</span>() - <span class="number">1</span>;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			it = ans_digit.<span class="built_in">erase</span>(it);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">BigNum</span>(ans_digit, ans_decim, dec, <span class="keyword">this</span>-&gt;neg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> BigNum BigNum::<span class="keyword">operator</span>*(<span class="type">const</span> BigNum&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">dec</span><span class="params">(<span class="keyword">this</span>-&gt;dec || num.dec)</span>, <span class="title">neg</span><span class="params">(<span class="keyword">this</span>-&gt;neg != num.neg)</span></span>;</span><br><span class="line">	string ans, <span class="built_in">mul_1</span>(<span class="keyword">this</span>-&gt;digit + <span class="keyword">this</span>-&gt;decim), <span class="built_in">mul_2</span>(num.digit + num.decim);</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">mul_1_size</span><span class="params">(mul_1.size())</span>, <span class="title">mul_2_size</span><span class="params">(mul_2.size())</span></span>;</span><br><span class="line">	<span class="built_in">reverse</span>(mul_1.<span class="built_in">begin</span>(), mul_1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">reverse</span>(mul_2.<span class="built_in">begin</span>(), mul_2.<span class="built_in">end</span>());</span><br><span class="line">	ans.<span class="built_in">append</span>(mul_1_size + mul_2_size, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mul_2_size; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; mul_1_size; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[i + j] += (mul_1[j] - <span class="string">&#x27;0&#x27;</span>) * (mul_2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			ans[i + j + <span class="number">1</span>] += (ans[i + j] / <span class="number">10</span>);</span><br><span class="line">			ans[i + j] %= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> size = ans.<span class="built_in">size</span>(), i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		ans[i] += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">	string::iterator it = ans.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (it != ans.<span class="built_in">end</span>() - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> (*it == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			it = ans.<span class="built_in">erase</span>(it);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">decim_index</span><span class="params">(ans.size() - <span class="keyword">this</span>-&gt;decim.size() - num.decim.size())</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">ans_digit</span><span class="params">(ans.substr(<span class="number">0</span>, decim_index))</span>, <span class="title">ans_decim</span><span class="params">((dec ? ans.substr(decim_index, ans.size()) : <span class="string">&quot;&quot;</span>))</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">BigNum</span>(ans_digit, ans_decim, dec, <span class="keyword">this</span>-&gt;neg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	BigNum a, b, c;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	c = a * b;</span><br><span class="line">	cout &lt;&lt; c;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码记录</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>算法小全</title>
    <url>/post/b9a52fbf/</url>
    <content><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>[TOC]</p>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>时间复杂度：$O(log_2n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickPower</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">base</span><span class="params">(a)</span>, <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &amp; <span class="number">1</span>)</span><br><span class="line">			ans *= base;</span><br><span class="line">		base *= base;</span><br><span class="line">		x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>时间复杂度：$O(n log_2n) $</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span>* num, <span class="type">int</span> head, <span class="type">int</span> tail)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pivot</span><span class="params">(num[head])</span>, <span class="title">i</span><span class="params">(head)</span>, <span class="title">j</span><span class="params">(tail)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (num[j] &gt;= pivot &amp;&amp; i &lt; j)</span><br><span class="line">				--j;</span><br><span class="line">			<span class="built_in">swap</span>(num[i], num[j]);</span><br><span class="line">			<span class="keyword">while</span> (num[i] &lt;= pivot &amp;&amp; i &lt; j)</span><br><span class="line">				++i;</span><br><span class="line">			<span class="built_in">swap</span>(num[i], num[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">quickSort</span>(num, i + <span class="number">1</span>, tail);</span><br><span class="line">		<span class="built_in">quickSort</span>(num, head, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>时间复杂度：$O(n^2)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span>* num, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">d</span><span class="params">(size / <span class="number">2</span>)</span>, j, temp</span>;</span><br><span class="line">	<span class="keyword">while</span> (d &gt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;= size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = num[i];</span><br><span class="line">			j = i - d;</span><br><span class="line">			<span class="keyword">while</span> ((j &gt;= <span class="number">0</span>) &amp;&amp; (num[j] &gt; temp))</span><br><span class="line">			&#123;</span><br><span class="line">				num[j + d] = num[j];</span><br><span class="line">				j -= d;</span><br><span class="line">			&#125;</span><br><span class="line">			num[j + d] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		d /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>时间复杂度：$O(nlog_2n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>* num, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mid - left == <span class="number">1</span> || mid &gt; right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">arrLen</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">i</span><span class="params">(left)</span>, <span class="title">j</span><span class="params">(mid)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt;= right)</span><br><span class="line">		<span class="keyword">if</span> (num[i] == num[j])</span><br><span class="line">			tArr[arrLen++] = num[i++],tArr[arrLen++] = num[j++];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt; num[j])</span><br><span class="line">			tArr[arrLen++] = num[j++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tArr[arrLen++] = num[i++];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; mid)</span><br><span class="line">		tArr[arrLen++] = num[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">		tArr[arrLen++] = num[j++];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; arrLen; p++)</span><br><span class="line">		*(num + p + left) = tArr[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>* num, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> (i + <span class="number">1</span> &lt; size &amp;&amp; num[i] &gt; num[i + <span class="number">1</span>])</span><br><span class="line">			<span class="built_in">swap</span>(num[i], num[i + <span class="number">1</span>]);</span><br><span class="line">	<span class="type">int</span> length = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (; length &lt; size; length *= <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += length * <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">if</span> (i + <span class="number">2</span> * length &lt; size)</span><br><span class="line">				<span class="built_in">merge</span>(num, i, i + length, i + <span class="number">2</span> * length - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">merge</span>(num, i, i + length, size - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">merge</span>(num, <span class="number">0</span>, length / <span class="number">2</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>时间复杂度：$O(n log_2n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">excHeap</span><span class="params">(<span class="type">int</span>* num, <span class="type">int</span> i, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> largestIndex = i;</span><br><span class="line">	<span class="keyword">if</span> (left &lt; size &amp;&amp; num[left] &gt; num[largestIndex])</span><br><span class="line">		largestIndex = left;</span><br><span class="line">	<span class="keyword">if</span> (right &lt; size &amp;&amp; num[right] &gt; num[largestIndex])</span><br><span class="line">		largestIndex = right;</span><br><span class="line">	<span class="keyword">if</span> (largestIndex != i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(num[i], num[largestIndex]);</span><br><span class="line">		<span class="built_in">excHeap</span>(num, largestIndex, size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span>* num, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = size;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temp; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = size / <span class="number">2</span> - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">			<span class="built_in">excHeap</span>(num, j, size);</span><br><span class="line">		<span class="built_in">swap</span>(num[<span class="number">0</span>], num[size]);</span><br><span class="line">		size--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> y ? <span class="built_in">gcd</span>(y, x % y) : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h2><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> com[maxN]; <span class="comment">//表示是否为合数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">end</span><span class="params">(sqrt(maxN))</span></span>;</span><br><span class="line">	com[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; end;i++)</span><br><span class="line">		<span class="keyword">if</span>(!com[i])</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = i * <span class="number">2</span>;j &lt; maxN;j += i)</span><br><span class="line">				com[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pri[maxM], <span class="built_in">cnt</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">bool</span> com[maxN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	com[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; maxN;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!com[i])</span><br><span class="line">			pri[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * pri[j] &lt; maxN;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			com[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % pri[j] == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字典生成哈夫曼编码</title>
    <url>/post/d98c846b/</url>
    <content><![CDATA[<p>使用哈夫曼树实现的编码</p>
<p>录入字符数字和其权重，即可生成用于加密解密程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">sz</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">dt</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">wt</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">pt</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">lc</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">rc</span><span class="params">(<span class="number">4</span>)</span>, HT[5][101]</span>;</span><br><span class="line">string HCode[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cout &lt;&lt; (<span class="type">char</span>)HT[dt][i] &lt;&lt; <span class="string">&quot; :&quot;</span> &lt;&lt; HCode[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findMin</span><span class="params">(<span class="type">int</span>* m1, <span class="type">int</span>* m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> min = <span class="number">6666</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">		<span class="keyword">if</span> (HT[pt][i] == <span class="number">0</span> &amp;&amp; HT[wt][i] &lt;= min)</span><br><span class="line">		&#123;</span><br><span class="line">			*m1 = i;</span><br><span class="line">			min = HT[wt][i];</span><br><span class="line">		&#125;</span><br><span class="line">	min = <span class="number">6666</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">		<span class="keyword">if</span> (HT[pt][i] == <span class="number">0</span> &amp;&amp; HT[wt][i] &lt;= min &amp;&amp; i != *m1)</span><br><span class="line">		&#123;</span><br><span class="line">			*m2 = i;</span><br><span class="line">			min = HT[wt][i];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">n</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt; sz; i++)</span><br><span class="line">		<span class="keyword">if</span> (!HT[pt][i])</span><br><span class="line">			n++;</span><br><span class="line">	<span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffmanCode</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> lf = n;</span><br><span class="line">	<span class="keyword">while</span> (HT[pt][n] != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (HT[lc][HT[pt][n]] == n)</span><br><span class="line">		&#123;</span><br><span class="line">			n = HT[pt][n];</span><br><span class="line">			HCode[lf].<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			n = HT[pt][n];</span><br><span class="line">			HCode[lf].<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatHuffmanTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m1, m2;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isFull</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">findMin</span>(&amp;m1, &amp;m2);</span><br><span class="line">		HT[wt][sz] = HT[wt][m1] + HT[wt][m2];</span><br><span class="line">		HT[pt][sz] = <span class="number">0</span>;</span><br><span class="line">		HT[lc][sz] = m1;</span><br><span class="line">		HT[rc][sz] = m2;</span><br><span class="line">		HT[pt][m1] = HT[pt][m2] = sz;</span><br><span class="line">		sz++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">HuffmanCode</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffmanDecode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string code;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请根据字典输入哈夫曼编码：&quot;</span>;</span><br><span class="line">	cin &gt;&gt; code;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;哈夫曼译码为：&quot;</span>;</span><br><span class="line">	<span class="type">int</span> p = sz - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; code.<span class="built_in">length</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (code[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			p = HT[lc][p];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p = HT[rc][p];</span><br><span class="line">		<span class="keyword">if</span> (HT[lc][p] == <span class="number">0</span> &amp;&amp; HT[rc][p] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; (<span class="type">char</span>)HT[dt][p];</span><br><span class="line">			p = sz - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toHuffmanCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> code;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请根据输入哈夫曼译码(结尾加上#)：&quot;</span>;</span><br><span class="line">	code = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (code != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (code == (<span class="type">char</span>)HT[dt][i])</span><br><span class="line">				cout &lt;&lt; HCode[i];</span><br><span class="line">		code = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">screen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;———1.输出字典———&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;———2.加    密———&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;———3.解    密———&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;———4.结    束———&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;使用 “统计生成字典”程序生成字典\n请输入：&quot;</span>;</span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">	cin &gt;&gt; w;</span><br><span class="line">	<span class="keyword">while</span> (w &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		HCode[sz] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		HT[dt][sz] = c;</span><br><span class="line">		HT[pt][sz] = <span class="number">0</span>;</span><br><span class="line">		HT[lc][sz] = <span class="number">0</span>;</span><br><span class="line">		HT[rc][sz] = <span class="number">0</span>;</span><br><span class="line">		HT[wt][sz++] = w;</span><br><span class="line">		cin &gt;&gt; c &gt;&gt; w;</span><br><span class="line">	&#125;</span><br><span class="line">	n = sz;</span><br><span class="line">	<span class="built_in">creatHuffmanTree</span>();</span><br><span class="line">loop:</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">	<span class="built_in">screen</span>();</span><br><span class="line">	<span class="type">int</span> input;</span><br><span class="line">	cin &gt;&gt; input;</span><br><span class="line">	<span class="keyword">switch</span> (input)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">print</span>(); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">toHuffmanCode</span>(); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">HuffmanDecode</span>(); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">default</span>:cout &lt;&lt; <span class="string">&quot;输入有误&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> enter = <span class="built_in">getchar</span>();</span><br><span class="line">	enter = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">goto</span> loop;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码记录</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>二叉树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计生成字典</title>
    <url>/post/c4f8c1c8/</url>
    <content><![CDATA[<p>这个程序是为了和之前写的哈夫曼编码配套用（只能输英文 <span class="github-emoji" alias="sob" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">&#x1f62d;</span>）</p>
<p>主要功能为输入一段文本，对其中的字符、数字和符号进行统计然后输出。懒得搞读文件了 <span class="github-emoji" alias="yum" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8">&#x1f60b;</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASCII_BEGIN 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASCII_MAX_SIZE 128</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll asc[ASCII_MAX_SIZE];</span><br><span class="line">map&lt;<span class="type">char</span>,ll&gt; otr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> end;</span><br><span class="line">	<span class="function"><span class="type">short</span> <span class="title">out</span><span class="params">(<span class="number">0</span>)</span>,bnd</span>;</span><br><span class="line">	<span class="comment">// 初始化 </span></span><br><span class="line">	<span class="built_in">memset</span>(asc,<span class="number">0</span>,<span class="built_in">sizeof</span>(asc));</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;输入一个字符和其连续出现的次数作为结束标志：\n&quot;</span>;</span><br><span class="line">	cin&gt;&gt;end&gt;&gt;bnd;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 开始统计 </span></span><br><span class="line">	<span class="function"><span class="type">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(out&lt;bnd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 获取字符 </span></span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 判断结束 </span></span><br><span class="line">		<span class="keyword">if</span>(c==end)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(++out&gt;=bnd)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> asc[end]+=out,out=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 越界视为其他字符 </span></span><br><span class="line">		<span class="keyword">if</span>(c&gt;=ASCII_MAX_SIZE) otr[c]++;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 统计</span></span><br><span class="line">		asc[c]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=ASCII_BEGIN;i&lt;ASCII_MAX_SIZE;i++)</span><br><span class="line">		<span class="keyword">if</span>(asc[i]&gt;<span class="number">0</span>)</span><br><span class="line">			cout&lt;&lt;(<span class="type">char</span>)i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;asc[i]&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(map&lt;<span class="type">char</span>,ll&gt;::iterator it=otr.<span class="built_in">begin</span>();it!=otr.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="type">char</span> <span class="title">key</span><span class="params">(it-&gt;first)</span></span>;</span><br><span class="line">		cout&lt;&lt;key&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;otr[key]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;end&lt;&lt;<span class="string">&quot; 0\n&quot;</span>;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码记录</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>中序表达式计算</title>
    <url>/post/7c813e30/</url>
    <content><![CDATA[<h1 id="中序表达式计算"><a href="#中序表达式计算" class="headerlink" title="中序表达式计算"></a>中序表达式计算</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ope;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stack</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">	node* top;</span><br><span class="line">&#125;ope, num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(stack* s, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*s).size++;</span><br><span class="line">	node* t = <span class="keyword">new</span> node;</span><br><span class="line">	t-&gt;data = data;</span><br><span class="line">	<span class="keyword">if</span> ((*s).top == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		(*s).top = t;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;next = (*s).top;</span><br><span class="line">	(*s).top = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(stack* s, <span class="type">char</span> ope, <span class="type">int</span> pri)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*s).size++;</span><br><span class="line">	node* t = <span class="keyword">new</span> node;</span><br><span class="line">	t-&gt;ope = ope;</span><br><span class="line">	t-&gt;data = pri;</span><br><span class="line">	<span class="keyword">if</span> ((*s).top == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		(*s).top = t;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;next = (*s).top;</span><br><span class="line">	(*s).top = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(stack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*s).size--;</span><br><span class="line">	node* temp = (*s).top;</span><br><span class="line">	(*s).top = (*s).top-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(stack s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (s.size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickPower</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>, bs = base;</span><br><span class="line">	<span class="keyword">while</span> (exp &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (exp &amp; <span class="number">1</span>)</span><br><span class="line">			ans *= bs;</span><br><span class="line">		bs *= bs;</span><br><span class="line">		exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">char</span> ope, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (ope)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span><span class="number">&#x27;</span>+<span class="string">&#x27;:return a + b;</span></span><br><span class="line"><span class="string">	case&#x27;</span>-<span class="string">&#x27;:return a - b;</span></span><br><span class="line"><span class="string">	case&#x27;</span>*<span class="string">&#x27;:return a * b;</span></span><br><span class="line"><span class="string">	case&#x27;</span>/<span class="string">&#x27;:return a / b;</span></span><br><span class="line"><span class="string">	case&#x27;</span>%<span class="string">&#x27;:return a % b;</span></span><br><span class="line"><span class="string">	case&#x27;</span>^<span class="string">&#x27;:return quickPower(a, b);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void preSum()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	if (f)</span></span><br><span class="line"><span class="string">	&#123;</span></span><br><span class="line"><span class="string">		ans = sum(ope.top-&gt;ope, num.top-&gt;next-&gt;data, num.top-&gt;data);</span></span><br><span class="line"><span class="string">		f = 0;</span></span><br><span class="line"><span class="string">		pop(&amp;num);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		ans = sum(ope.top-&gt;ope, ans, num.top-&gt;data);</span></span><br><span class="line"><span class="string">	pop(&amp;num);</span></span><br><span class="line"><span class="string">	pop(&amp;ope);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	cout &lt;&lt; &quot;请在中序表达式结尾加上#：&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	char c = getchar();</span></span><br><span class="line"><span class="string">	while (c != &#x27;</span>#<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">	&#123;</span></span><br><span class="line"><span class="string">		if (c &gt;= &#x27;</span><span class="number">0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">			<span class="built_in">push</span>(&amp;num, c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span> (c)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span><span class="number">&#x27;</span>+<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				if (isEmpty(ope));</span></span><br><span class="line"><span class="string">				else if (ope.top-&gt;data &gt;= 1)</span></span><br><span class="line"><span class="string">					while (ope.top-&gt;data &gt;= 1)</span></span><br><span class="line"><span class="string">						preSum();</span></span><br><span class="line"><span class="string">				push(&amp;ope, &#x27;</span>+<span class="string">&#x27;, 1);</span></span><br><span class="line"><span class="string">				break;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			case&#x27;</span>-<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				if (isEmpty(ope));</span></span><br><span class="line"><span class="string">				else if (ope.top-&gt;data &gt;= 1)</span></span><br><span class="line"><span class="string">					while (ope.top-&gt;data &gt;= 1)</span></span><br><span class="line"><span class="string">						preSum();</span></span><br><span class="line"><span class="string">				push(&amp;ope, &#x27;</span>-<span class="string">&#x27;, 1);</span></span><br><span class="line"><span class="string">				break;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			case&#x27;</span>*<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				if (isEmpty(ope));</span></span><br><span class="line"><span class="string">				else if (ope.top-&gt;data &gt;= 2)</span></span><br><span class="line"><span class="string">					while (ope.top-&gt;data &gt;= 2)</span></span><br><span class="line"><span class="string">						preSum();</span></span><br><span class="line"><span class="string">				push(&amp;ope, &#x27;</span>*<span class="string">&#x27;, 2);</span></span><br><span class="line"><span class="string">				break;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			case&#x27;</span>/<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				if (isEmpty(ope));</span></span><br><span class="line"><span class="string">				else if (ope.top-&gt;data &gt;= 2)</span></span><br><span class="line"><span class="string">					while (ope.top-&gt;data &gt;= 2)</span></span><br><span class="line"><span class="string">						preSum();</span></span><br><span class="line"><span class="string">				push(&amp;ope, &#x27;</span>/<span class="string">&#x27;, 2);</span></span><br><span class="line"><span class="string">				break;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			case&#x27;</span>%<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				if (isEmpty(ope));</span></span><br><span class="line"><span class="string">				else if (ope.top-&gt;data &gt;= 2)</span></span><br><span class="line"><span class="string">					while (ope.top-&gt;data &gt;= 2)</span></span><br><span class="line"><span class="string">						preSum();</span></span><br><span class="line"><span class="string">				push(&amp;ope, &#x27;</span>%<span class="string">&#x27;, 2);</span></span><br><span class="line"><span class="string">				break;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			case&#x27;</span>^<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				if (isEmpty(ope));</span></span><br><span class="line"><span class="string">				else if (ope.top-&gt;data == 3)</span></span><br><span class="line"><span class="string">					while (ope.top-&gt;data == 3)</span></span><br><span class="line"><span class="string">						preSum();</span></span><br><span class="line"><span class="string">				push(&amp;ope, &#x27;</span>^<span class="string">&#x27;, 3);</span></span><br><span class="line"><span class="string">				break;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			case&#x27;</span>(<span class="string">&#x27;:push(&amp;ope, &#x27;</span>(<span class="string">&#x27;, 0); break;</span></span><br><span class="line"><span class="string">			case&#x27;</span>)<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				while (ope.top-&gt;ope != &#x27;</span>(<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">					preSum();</span></span><br><span class="line"><span class="string">				pop(&amp;ope);</span></span><br><span class="line"><span class="string">				break;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		c = getchar();</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	while (!isEmpty(ope))</span></span><br><span class="line"><span class="string">		preSum();</span></span><br><span class="line"><span class="string">	cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码记录</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角</title>
    <url>/post/4ee864f8/</url>
    <content><![CDATA[<h1 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">66666</span>]; <span class="comment">//循环使用后两个数组</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">p</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//跳转两个数组的变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 每行的循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 单行的每列的循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) </span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 单独判断杨辉三角 1 的情况</span></span><br><span class="line">			<span class="keyword">if</span> (!j <span class="keyword">or</span> !(j - i)) </span><br><span class="line">			&#123;</span><br><span class="line">				a[p][j] = <span class="number">1</span>;</span><br><span class="line">				cout &lt;&lt; a[p][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			a[p][j] = a[!p][j - <span class="number">1</span>] + a[!p][j];</span><br><span class="line">			cout &lt;&lt; a[p][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = !p;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码记录</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
